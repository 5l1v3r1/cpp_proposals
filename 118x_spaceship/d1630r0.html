<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2019-06-01" />
  <title>Spaceship needs a tune-up</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    background-color: #ffffff;
    color: #a0a0a0;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #a0a0a0;  padding-left: 4px; }
div.sourceCode
  { color: #1f1c1b; background-color: #f6f8fa; }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span. { color: #1f1c1b; } /* Normal */
code span.al { color: #bf0303; background-color: #f7e6e6; font-weight: bold; } /* Alert */
code span.an { color: #ca60ca; } /* Annotation */
code span.at { color: #0057ae; } /* Attribute */
code span.bn { color: #b08000; } /* BaseN */
code span.bu { color: #1f1c1b; } /* BuiltIn */
code span.cf { color: #0057ae; } /* ControlFlow */
code span.ch { color: #924c9d; } /* Char */
code span.cn { color: #aa5500; } /* Constant */
code span.co { color: #898887; font-style: italic; } /* Comment */
code span.cv { color: #0095ff; } /* CommentVar */
code span.do { color: #607880; } /* Documentation */
code span.dt { color: #0057ae; } /* DataType */
code span.dv { color: #b08000; } /* DecVal */
code span.er { color: #bf0303; text-decoration: underline; } /* Error */
code span.ex { color: #0095ff; font-weight: bold; } /* Extension */
code span.fl { color: #b08000; } /* Float */
code span.fu { color: #644a9b; } /* Function */
code span.im { color: #ff5500; } /* Import */
code span.in { color: #b08000; } /* Information */
code span.kw { color: #0057ae; } /* Keyword */
code span.op { color: #1f1c1b; } /* Operator */
code span.ot { color: #006e28; } /* Other */
code span.pp { color: #006e28; } /* Preprocessor */
code span.re { color: #0057ae; background-color: #e0e9f8; } /* RegionMarker */
code span.sc { color: #3daee9; } /* SpecialChar */
code span.ss { color: #ff5500; } /* SpecialString */
code span.st { color: #bf0303; } /* String */
code span.va { color: #006e28; } /* Variable */
code span.vs { color: #bf0303; } /* VerbatimString */
code span.wa { color: #bf0303; } /* Warning */
  </style>
  <style type="text/css">
body {
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a { text-decoration: none; }
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1 { line-height: 1; }
h2 { line-height: 1; }
h3 { line-height: 1; }
h4 { line-height: 1; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
div.marginalizedparent {
position: relative;
left: -5em;
}
li > div.marginalizedparent { left: -7em; }
li > ul > li > div.marginalizedparent { left: -9em; }
li > ul > li > ul > li > div.marginalizedparent { left: -11em; }
li > ul > li > ul > li > ul > li > div.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "‚üµ"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
code {
font-family: monospace;
font-style: normal;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
code span.co { color: green; font-style: italic; font-family: serif; }
code span.kw { color: #00607c; }
code span.cf { color: #00607c; }
code span.at { color: #00607c; }
code span.op { color: #af1915; }
code span.pp { color: #6F4E37; }
code span.dt { color: black; }
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.self-link {
position: absolute;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
bottom: 1px;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
text-decoration: none;
}
a.self-link:hover {
opacity: 1;
}
a.self-link::before {
content: "¬ß";
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
h1,h2,h3,h4,h5,h6 { position: relative; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
#title-block-header td { border: 0; }
a[name] { display: inline-block; padding-top: 40px; margin-top: -40px; }
</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Spaceship needs a tune-up</h1>
<h3 class="subtitle" style="text-align:center">Addressing some discovered issues with P0515 and P1185</h3>

<table style="border:none;float:right">
  <tr>
    <td>Document #: </td>
    <td>D1630R0</td>
  </tr>
  <tr>
    <td>Date: </td>
    <td>2019-06-01</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project: </td>
    <td>Programming Language C++<br>
      CWG, EWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to: </td>
    <td>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span> <span></span>Introduction</a></li>
<li><a href="#tomaszs-example"><span class="toc-section-number">2</span> <span></span>Tomasz‚Äôs example</a><ul>
<li><a href="#changing-the-result-of-overload-resolution"><span class="toc-section-number">2.1</span> <span></span>Changing the result of overload resolution</a></li>
<li><a href="#code-that-becomes-ambiguous"><span class="toc-section-number">2.2</span> <span></span>Code that becomes ambiguous</a></li>
<li><a href="#similar-examples"><span class="toc-section-number">2.3</span> <span></span>Similar examples</a></li>
<li><a href="#todays-guidance"><span class="toc-section-number">2.4</span> <span></span>Today‚Äôs Guidance</a></li>
<li><a href="#proposal"><span class="toc-section-number">2.5</span> <span></span>Proposal</a></li>
</ul></li>
<li><a href="#camerons-example"><span class="toc-section-number">3</span> <span></span>Cameron‚Äôs Example</a><ul>
<li><a href="#proposal-1"><span class="toc-section-number">3.1</span> <span></span>Proposal</a></li>
</ul></li>
<li><a href="#richards-example"><span class="toc-section-number">4</span> <span></span>Richard‚Äôs Example</a><ul>
<li><a href="#proposal-2"><span class="toc-section-number">4.1</span> <span></span>Proposal</a></li>
</ul></li>
<li><a href="#default-comparisons-for-reference-data-members"><span class="toc-section-number">5</span> <span></span>Default comparisons for reference data members</a><ul>
<li><a href="#anonymous-unions"><span class="toc-section-number">5.1</span> <span></span>Anonymous unions</a></li>
<li><a href="#design-intent"><span class="toc-section-number">5.2</span> <span></span>Design intent</a></li>
<li><a href="#proposal-3"><span class="toc-section-number">5.3</span> <span></span>Proposal</a></li>
</ul></li>
<li><a href="#wording"><span class="toc-section-number">6</span> <span></span>Wording</a></li>
</ul>
</div>
<h1 id="introduction" style="border-bottom:1px solid #cccccc"><span class="header-section-number">1</span> <a href="#introduction" class="self-link"></a>Introduction</h1>
<p>The introduction of <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code> into the language (<span class="citation" data-cites="P0515R3">[<a href="#ref-P0515R3" role="doc-biblioref">P0515R3</a>]</span> with relevant extension <span class="citation" data-cites="P0905R1">[<a href="#ref-P0905R1" role="doc-biblioref">P0905R1</a>]</span>) added a novel aspect to name lookup: candidate functions can now include both candidates with different names and a reversed order of arguments. The expression <code class="sourceCode cpp">a <span class="op">&lt;</span> b</code> used to always only find candidates like <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;(</span>a, b<span class="op">)</span></code> and <code class="sourceCode cpp">a<span class="op">.</span><span class="kw">operator</span><span class="op">&lt;(</span>b<span class="op">)</span></code> now also finds <code class="sourceCode cpp"><span class="op">(</span>a <span class="op">&lt;=&gt;</span> b<span class="op">)</span> <span class="op">&lt;</span> <span class="dv">0</span></code> and <code class="sourceCode cpp"><span class="dv">0</span> <span class="op">&lt;</span> <span class="op">(</span>b <span class="op">&lt;=&gt;</span> a<span class="op">)</span></code>. This change makes it much easier to write comparisons - since you only need to write the one <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code>.</p>
<p>However, that ended up being insufficient due to the problems pointed out in <span class="citation" data-cites="P1190R0">[<a href="#ref-P1190R0" role="doc-biblioref">P1190R0</a>]</span>, and in response <span class="citation" data-cites="P1185R2">[<a href="#ref-P1185R2" role="doc-biblioref">P1185R2</a>]</span> was adopted in Kona which made the following changes:</p>
<ol type="1">
<li>Changing candidate sets for equality and inequality
<ol type="a">
<li><code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> is no longer a candidate for either equality or inequality<br />
</li>
<li><code class="sourceCode cpp"><span class="op">==</span></code> gains <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code>‚Äôs ability for both reversed and rewritten candidates<br />
</li>
</ol></li>
<li>Defaulted <code class="sourceCode cpp"><span class="op">==</span></code> does memberwise equality, defaulted <code class="sourceCode cpp"><span class="op">!=</span></code> invokes <code class="sourceCode cpp"><span class="op">==</span></code> instead of <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code>.<br />
</li>
<li>Strong structural equality is defined in terms of <code class="sourceCode cpp"><span class="op">==</span></code> instead of <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code><br />
</li>
<li>Defaulted <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> can also implicitly declare defaulted <code class="sourceCode cpp"><span class="op">==</span></code></li>
</ol>
<p>Between P0515 and P1185, several issues have come up in the reflectors that this paper hopes to address. These issues are largely independent from each other, and will be discussed independently.</p>
<h1 id="tomaszs-example" style="border-bottom:1px solid #cccccc"><span class="header-section-number">2</span> <a href="#tomaszs-example" class="self-link"></a>Tomasz‚Äôs example</h1>
<p>Consider the following example <span class="citation" data-cites="CWG2407">[<a href="#ref-CWG2407" role="doc-biblioref">CWG2407</a>]</span> (note that the use of <code class="sourceCode cpp"><span class="kw">int</span></code> is not important, simply that we have two types, one of which is implicitly convertible to the other):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">struct</span> A <span class="op">{</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="kw">operator</span> <span class="kw">int</span><span class="op">()</span> <span class="at">const</span>;</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">bool</span> <span class="kw">operator</span><span class="op">==(</span>A, <span class="kw">int</span><span class="op">)</span>;              <span class="co">// #1</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co">// builtin bool operator==(int, int); // #2</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co">// builtin bool operator!=(int, int); // #3</span></a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">int</span> check<span class="op">(</span>A x, A y<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-10" title="10">  <span class="cf">return</span> <span class="op">(</span>x <span class="op">==</span> y<span class="op">)</span> <span class="op">+</span>  <span class="co">// In C++17, calls #1; in C++20, ambiguous between #1 and reversed #1</span></a>
<a class="sourceLine" id="cb1-11" title="11">    <span class="op">(</span><span class="dv">10</span> <span class="op">==</span> x<span class="op">)</span> <span class="op">+</span>      <span class="co">// In C++17, calls #2; in C++20, calls #1</span></a>
<a class="sourceLine" id="cb1-12" title="12">    <span class="op">(</span><span class="dv">10</span> <span class="op">!=</span> x<span class="op">)</span>;       <span class="co">// In C++17, calls #3; in C++20, calls #1</span></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="op">}</span>    </a></code></pre></div>
<p>There are two separate issues demonstrated in this example: code that changes which function gets called, and code that becomes ambiguous.</p>
<h2 id="changing-the-result-of-overload-resolution"><span class="header-section-number">2.1</span> <a href="#changing-the-result-of-overload-resolution" class="self-link"></a>Changing the result of overload resolution</h2>
<p>The expression <code class="sourceCode cpp"><span class="dv">10</span> <span class="op">==</span> x</code> in C++17 had only one viable candidate: <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==(</span><span class="kw">int</span>, <span class="kw">int</span><span class="op">)</span></code>, converting the <code class="sourceCode cpp">A</code> to an <code class="sourceCode cpp"><span class="kw">int</span></code>. But in C++20, due to P1185, equality and inequality get reversed candidates as well. Since equality is symmetric, <code class="sourceCode cpp"><span class="dv">10</span> <span class="op">==</span> x</code> is an equivalent expression to <code class="sourceCode cpp">x <span class="op">==</span> <span class="dv">10</span></code>, and we consider both forms. This gives us two candidates:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">int</span>, A<span class="op">)</span>;   <span class="co">// #1 (reversed)</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">int</span>, <span class="kw">int</span><span class="op">)</span>; <span class="co">// #2 (builtin)</span></a></code></pre></div>
<p>The first is an Exact Match, whereas the second requires a Conversion, so the first is the best viable candidate.</p>
<p>Silently changing which function gets executed is facially the worst thing we can do, but in this particular situation doesn‚Äôt seem that bad. We‚Äôre already in a situation where, in C++17, <code class="sourceCode cpp">x <span class="op">==</span> <span class="dv">10</span></code> and <code class="sourceCode cpp"><span class="dv">10</span> <span class="op">==</span> x</code> invoke different kinds of functions (the former invokes a user-defined function, the latter a builtin) and if those two give different answers, that seems like an inherently questionable program.</p>
<p>The inequality expression behaves the same way. In C++17, <code class="sourceCode cpp"><span class="dv">10</span> <span class="op">!=</span> x</code> had only one viable candidate: the <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">!=(</span><span class="kw">int</span>, <span class="kw">int</span><span class="op">)</span></code> builtin, but in C++20 also acquires the reversed and rewritten candidate <code class="sourceCode cpp"><span class="op">(</span>x <span class="op">==</span> <span class="dv">10</span><span class="op">)</span> <span class="op">?</span> <span class="kw">false</span> <span class="op">:</span> <span class="kw">true</span></code>, which would be an Exact Match. Here, the status quo was that <code class="sourceCode cpp">x <span class="op">!=</span> <span class="dv">10</span></code> and <code class="sourceCode cpp"><span class="dv">10</span> <span class="op">!=</span> x</code> both invoke the same function - but again, if that function gave a different answer from <code class="sourceCode cpp"><span class="op">!(</span>x <span class="op">==</span> <span class="dv">10</span><span class="op">)</span></code> or <code class="sourceCode cpp"><span class="op">!(</span><span class="dv">10</span> <span class="op">==</span> x<span class="op">)</span></code>, that seems suspect.</p>
<h2 id="code-that-becomes-ambiguous"><span class="header-section-number">2.2</span> <a href="#code-that-becomes-ambiguous" class="self-link"></a>Code that becomes ambiguous</h2>
<p>The homogeneous comparison is more interesting. <code class="sourceCode cpp">x <span class="op">==</span> y</code> in C++17 had only one candidate: <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==(</span>A, <span class="kw">int</span><span class="op">)</span></code>, converting <code class="sourceCode cpp">y</code> to an <code class="sourceCode cpp"><span class="kw">int</span></code>. But in C++20, it now has two:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">bool</span> <span class="kw">operator</span><span class="op">==(</span>A, <span class="kw">int</span><span class="op">)</span>; <span class="co">// #1</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">int</span>, A<span class="op">)</span>; <span class="co">// #1 reversed</span></a></code></pre></div>
<p>The first candidate has an Exact Match in the 1st argument and a Conversion in the 2nd, the second candidate has a Conversion in the 1st argument and an Exact Match in the 2nd. While we do have a tiebreaker to choose the non-reversed candidate over the reversed candidate (<a href="http://eel.is/c++draft/over.match.best#2.9">[over.match.best]/2.9</a>), that only happens when each argument‚Äôs conversion sequence <em>is not worse than</em> the other candidates‚Äô (<a href="http://eel.is/c++draft/over.match.best#2">[over.match.best]/2</a>)‚Ä¶ and that‚Äôs just not the case here. We have one better sequence and one worse sequence, each way.</p>
<p>As a result, this becomes ambiguous.</p>
<p>Note that the same thing can happen with <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> in a similar situation:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">struct</span> C <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">operator</span> <span class="kw">int</span><span class="op">()</span> <span class="at">const</span>;</a>
<a class="sourceLine" id="cb4-3" title="3">    strong_ordering <span class="kw">operator</span><span class="op">&lt;=&gt;(</span><span class="kw">int</span><span class="op">)</span> <span class="at">const</span>;</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb4-5" title="5"></a>
<a class="sourceLine" id="cb4-6" title="6">C<span class="op">{}</span> <span class="op">&lt;=&gt;</span> C<span class="op">{}</span>; <span class="co">// error: ambiguous</span></a></code></pre></div>
<p>But in this case, it‚Äôs completely new code which is ambiguous - rather than existing, functional code.</p>
<h2 id="similar-examples"><span class="header-section-number">2.3</span> <a href="#similar-examples" class="self-link"></a>Similar examples</h2>
<p>There are several other examples in this vein that are important to keep in mind, courtesy of Davis Herring.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">struct</span> B <span class="op">{</span></a>
<a class="sourceLine" id="cb5-2" title="2">    B<span class="op">(</span><span class="kw">int</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb5-3" title="3"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">bool</span> <span class="kw">operator</span><span class="op">==(</span>B,B<span class="op">)</span>;</a>
<a class="sourceLine" id="cb5-5" title="5"><span class="kw">bool</span> f<span class="op">()</span> <span class="op">{</span><span class="cf">return</span> B<span class="op">()==</span><span class="dv">0</span>;<span class="op">}</span></a></code></pre></div>
<p>We want this example to work, regardless of whatever rule changes we pursue. One potential rule change under consideration was reversing the arguments rather than parameters, which would lead to the above becoming ambiguous between the two argument orderings.</p>
<p>Also:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">struct</span> C <span class="op">{</span><span class="kw">operator</span> <span class="kw">int</span><span class="op">()</span>;<span class="op">}</span>;</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">struct</span> D <span class="op">:</span> C <span class="op">{}</span>;</a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="kw">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> C<span class="op">&amp;</span>,<span class="kw">int</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="kw">bool</span> g<span class="op">()</span> <span class="op">{</span><span class="cf">return</span> D<span class="op">()==</span>C<span class="op">()</span>;<span class="op">}</span></a></code></pre></div>
<p>The normal candidate has Conversion and User, the reversed parameter candidate has User and Exact Match, which makes this similar to Tomasz‚Äôs example: valid in C++17, ambiguous in C++20 under the status quo rules.</p>
<h2 id="todays-guidance"><span class="header-section-number">2.4</span> <a href="#todays-guidance" class="self-link"></a>Today‚Äôs Guidance</h2>
<p>From Herb Sutter‚Äôs post <span class="citation" data-cites="herb">[<a href="#ref-herb" role="doc-biblioref">herb</a>]</span> on the topic:</p>
<blockquote>
<p>Actually, C++20 is removing a pre-C++20 can of worms we can now unlearn.</p>
</blockquote>
<blockquote>
<p>This example is ‚Äúbad‚Äù code that breaks two rules we teach today, and compiling it in C++20 will make it strictly better:</p>
</blockquote>
<blockquote>
<ol type="1">
<li>It violates today‚Äôs guidance that you should write symmetric overloads of a heterogeneous <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> to avoid surprises. In this case, they provided <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==(</span>A,<span class="kw">int</span><span class="op">)</span></code> but failed to provide <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==(</span><span class="kw">int</span>,A<span class="op">)</span></code>. As a result, today we have to explain arcane details of why <code class="sourceCode cpp"><span class="dv">10</span><span class="op">==</span>x</code> and <code class="sourceCode cpp">x<span class="op">==</span><span class="dv">10</span></code> do different and possibly inconsistent things in this code, which forces us to explain several language rules plus teach a coding guideline to always remember to provide two overloads of a heterogeneous operator== (because if you forget, this code will compile but do inconsistent things depending on the order of <code class="sourceCode cpp"><span class="dv">10</span><span class="op">==</span>x</code> and <code class="sourceCode cpp">x<span class="op">==</span><span class="dv">10</span></code>). That‚Äôs a can of worms we can stop teaching in C++20.</li>
</ol>
</blockquote>
<blockquote>
<ol start="2" type="1">
<li>It violates today‚Äôs guidance that you should also write a homogeneous <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> to avoid a performance and/or correctness pitfall. In this case, they forgot to provide <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==(</span>A,A<span class="op">)</span></code>. As a result, today we have to explain why <code class="sourceCode cpp">x<span class="op">==</span>y</code> ‚Äúworks‚Äù in this code, but that‚Äôs a bug not a feature ‚Äì it ‚Äúworks‚Äù only because we already violated (1) above, and that it ‚Äúworks‚Äù is harboring a performance bug (implicit conversion) and possibly a correctness bug (if comparing two A‚Äôs directly might do something different than first converting one to an int). If today the programmer had not violated (1), they would already get a compile-time error; so the fact that <code class="sourceCode cpp">x<span class="op">==</span>y</code> is ambiguous is not actually new in C++20, what is new is that you will now consistently always get the compile-time error that you are missing <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==(</span>A,A<span class="op">)</span></code> instead of having it masked sometimes if you broke another rule.</li>
</ol>
</blockquote>
<blockquote>
<p>So recompiling this ‚Äúbad‚Äù code in C++20 mode is strictly good: For (1), C++20 silently fixes the bug, because the existing <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==(</span>A,<span class="kw">int</span><span class="op">)</span></code> now does what the user almost certainly intended. For (2), C++20 removes the pitfall by making the existing compile-time diagnostic guaranteed instead of just likely.</p>
</blockquote>
<blockquote>
<p>Operationally, the main place you‚Äôll notice a difference in C++20 is in code that a wise man once described as ‚Äúcode that deserves to be broken.‚Äù</p>
</blockquote>
<blockquote>
<p>Educationally, C++20 does remove a pre-C++20 can of worms, but mostly the only ones who will notice are us ‚Äúarcana experts‚Äù who are steeped in today‚Äôs complexity (because we have to unlearn our familiar wormcan); most ‚Äúnormals‚Äù will only notice that now C++ does what they thought it did. :)</p>
</blockquote>
<h2 id="proposal"><span class="header-section-number">2.5</span> <a href="#proposal" class="self-link"></a>Proposal</h2>
<p>The model around comparisons is better in the working draft than it was in C++17. We‚Äôre also now in a position where it‚Äôs simply much easier to write comparisons for types - we no longer have to live in this world where everybody only declares <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;</span></code> for their types and then everybody writes algorithms that pretend that only <code class="sourceCode cpp"><span class="op">&lt;</span></code> exists. Or, more relevantly, where everybody only declares <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> for their types and nobody uses <code class="sourceCode cpp"><span class="op">!=</span></code>. This is a Good Thing.</p>
<p>Coming up with a way to design the rewrite rules in a way that makes satisfies both Tomasz‚Äôs and Davis‚Äôs examples leads to a <em>very</em> complex set of rules, all to fix code that is fundamentally ambiguous.</p>
<p>This paper proposes that the status quo is the very best of the quos. Some code will fail to compile, that code can be easily fixed by adding either a homogeneous comparison operator or, if not that, doing an explicit conversion at the call sites. This lets us have the best language rules for the long future this language still has ahead of it. Instead, we add an Annex C entry.</p>
<h1 id="camerons-example" style="border-bottom:1px solid #cccccc"><span class="header-section-number">3</span> <a href="#camerons-example" class="self-link"></a>Cameron‚Äôs Example</h1>
<p>Cameron daCamara submitted the following example <span class="citation" data-cites="cameron">[<a href="#ref-cameron" role="doc-biblioref">cameron</a>]</span> after MSVC implemented <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code> and P1185R2:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Lhs, <span class="kw">typename</span> Rhs<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">struct</span> BinaryHelper <span class="op">{</span></a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="kw">using</span> UnderLhs <span class="op">=</span> <span class="kw">typename</span> Lhs<span class="op">::</span>Scalar;</a>
<a class="sourceLine" id="cb7-4" title="4">  <span class="kw">using</span> UnderRhs <span class="op">=</span> <span class="kw">typename</span> Rhs<span class="op">::</span>Scalar;</a>
<a class="sourceLine" id="cb7-5" title="5">  <span class="kw">operator</span> <span class="kw">bool</span><span class="op">()</span> <span class="at">const</span>;</a>
<a class="sourceLine" id="cb7-6" title="6"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="kw">struct</span> OnlyEq <span class="op">{</span></a>
<a class="sourceLine" id="cb7-9" title="9">  <span class="kw">using</span> Scalar <span class="op">=</span> <span class="kw">int</span>;</a>
<a class="sourceLine" id="cb7-10" title="10">  <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Rhs<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb7-11" title="11">  <span class="at">const</span> BinaryHelper<span class="op">&lt;</span>OnlyEq, Rhs<span class="op">&gt;</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> Rhs<span class="op">&amp;)</span> <span class="at">const</span>;</a>
<a class="sourceLine" id="cb7-12" title="12"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb7-13" title="13"> </a>
<a class="sourceLine" id="cb7-14" title="14"><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...&gt;</span></a>
<a class="sourceLine" id="cb7-15" title="15"><span class="kw">using</span> <span class="dt">void_t</span> <span class="op">=</span> <span class="kw">void</span>;</a>
<a class="sourceLine" id="cb7-16" title="16"> </a>
<a class="sourceLine" id="cb7-17" title="17"><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb7-18" title="18"><span class="kw">constexpr</span> T<span class="op">&amp;</span> declval<span class="op">()</span>;</a>
<a class="sourceLine" id="cb7-19" title="19"> </a>
<a class="sourceLine" id="cb7-20" title="20"><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span>, <span class="kw">typename</span> <span class="op">=</span> <span class="kw">void</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb7-21" title="21"><span class="kw">constexpr</span> <span class="kw">bool</span> has_neq_operation <span class="op">=</span> <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb7-22" title="22"></a>
<a class="sourceLine" id="cb7-23" title="23"><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb7-24" title="24"><span class="kw">constexpr</span> <span class="kw">bool</span> has_neq_operation<span class="op">&lt;</span>T, <span class="dt">void_t</span><span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>declval<span class="op">&lt;</span>T<span class="op">&gt;()</span> <span class="op">!=</span> declval<span class="op">&lt;</span><span class="kw">int</span><span class="op">&gt;())&gt;&gt;</span> <span class="op">=</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb7-25" title="25"></a>
<a class="sourceLine" id="cb7-26" title="26"><span class="kw">static_assert</span><span class="op">(!</span>has_neq_operation<span class="op">&lt;</span>OnlyEq<span class="op">&gt;)</span>;</a></code></pre></div>
<p>In C++17, this example compiles fine. <code class="sourceCode cpp">OnlyEq</code> has no <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">!=</span></code> candidate at all. But, the wording in [over.match.oper] currently states that:</p>
<blockquote>
<p>‚Ä¶ the rewritten candidates include all member, non-member, and built-in candidates for the operator <code class="sourceCode cpp"><span class="op">==</span></code> for which the rewritten expression <code class="sourceCode cpp"><span class="op">(</span>x <span class="op">==</span> y<span class="op">)</span></code> is well-formed when contextually converted to <code class="sourceCode cpp"><span class="kw">bool</span></code> using that operator <code class="sourceCode cpp"><span class="op">==</span></code>.</p>
</blockquote>
<p>Checking to see whether <code class="sourceCode cpp">OnlyEq</code>‚Äôs <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code>‚Äôs result is contextually convertible to <code class="sourceCode cpp"><span class="kw">bool</span></code> is not SFINAE-friendly; it is an error outside of the immediate context of the substitution. As a result, this well-formed C++17 program becomes ill-formed in C++20.</p>
<p>The problem here in particular is that C++20 is linking together the semantics of <code class="sourceCode cpp"><span class="op">==</span></code> and <code class="sourceCode cpp"><span class="op">!=</span></code> in a way that they were not linked before ‚Äì which leads to errors in situations where there was no intent for them to have been linked.</p>
<h2 id="proposal-1"><span class="header-section-number">3.1</span> <a href="#proposal-1" class="self-link"></a>Proposal</h2>
<p>This example we must address, and the best way to address is to carve out less space for rewrite candidates. The current rule is too broad:</p>
<blockquote>
<p>For the <code class="sourceCode cpp"><span class="op">!=</span></code> operator ([expr.eq]), the rewritten candidates include all member, non-member, and built-in candidates for the operator <code class="sourceCode cpp"><span class="op">==</span></code> for which the rewritten expression <code class="sourceCode cpp"><span class="op">(</span>x <span class="op">==</span> y<span class="op">)</span></code> is well-formed when <strong>contextually converted to <code class="sourceCode cpp"><span class="kw">bool</span></code></strong> using that operator <code class="sourceCode cpp"><span class="op">==</span></code>. For the equality operators, the rewritten candidates also include a synthesized candidate, with the order of the two parameters reversed, for each member, non-member, and built-in candidate for the operator == for which the rewritten expression <code class="sourceCode cpp"><span class="op">(</span>y <span class="op">==</span> x<span class="op">)</span></code> is well-formed when <strong>contextually converted to <code class="sourceCode cpp"><span class="kw">bool</span></code></strong> using that operator <code class="sourceCode cpp"><span class="op">==</span></code>.</p>
</blockquote>
<p>We really don‚Äôt need ‚Äúcontextually converted to <code class="sourceCode cpp"><span class="kw">bool</span></code>‚Äù - in fact, we‚Äôre probably not even getting any benefit as a language from taking that broad a stance. After all, if you wrote a <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> that returned <code class="sourceCode cpp"><span class="bu">std::</span>true_type</code>, you probably have good reasons for that and don‚Äôt necessarily want an <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">!=</span></code> that returns just <code class="sourceCode cpp"><span class="kw">bool</span></code>. And for types that are even less <code class="sourceCode cpp"><span class="kw">bool</span></code>-like than <code class="sourceCode cpp"><span class="bu">std::</span>true_type</code>, this consideration makes even less sense.</p>
<p>This paper proposes that we reduce this scope to <em>just</em> those cases where <code class="sourceCode cpp"><span class="op">(</span>x <span class="op">==</span> y<span class="op">)</span></code> is a valid expression that has type exactly <code class="sourceCode cpp"><span class="kw">bool</span></code>. This unbreaks Cameron‚Äôs example ‚Äì <code class="sourceCode cpp">BinaryHelper<span class="op">&lt;</span>OnlyEq, Rhs<span class="op">&gt;</span></code> is definitely not <code class="sourceCode cpp"><span class="kw">bool</span></code> and so <code class="sourceCode cpp">OnlyEq</code> continues to have no <code class="sourceCode cpp"><span class="op">!=</span></code> candidates ‚Äì while also both simplifying the language rule, simplifying the specification, and not reducing the usability of the rule at all. Win, win, win.</p>
<h1 id="richards-example" style="border-bottom:1px solid #cccccc"><span class="header-section-number">4</span> <a href="#richards-example" class="self-link"></a>Richard‚Äôs Example</h1>
<p>Daveed Vandevoorde pointed out that the wording in [over.match.oper] for determining rewritten candidates is currently:</p>
<blockquote>
<p>For the relational (7.6.9) operators, the rewritten candidates include all member, non-member, and built-in candidates for the operator <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> for which the rewritten expression <code class="sourceCode cpp"><span class="op">(</span>x <span class="op">&lt;=&gt;</span> y<span class="op">)</span> @ <span class="dv">0</span></code> is <strong>well-formed</strong> using that <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code>.</p>
</blockquote>
<p>Well-formed is poor word choice here, as that implies that we would have to fully instantiate both the <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> invocation and the <code class="sourceCode cpp">@</code> invocation. What we really want to do is simply check if this is viable in a SFINAE-like manner. This led Richard Smith to submit the following example <span class="citation" data-cites="smith">[<a href="#ref-smith" role="doc-biblioref">smith</a>]</span>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">struct</span> Base <span class="op">{</span> </a>
<a class="sourceLine" id="cb8-2" title="2">  <span class="kw">friend</span> <span class="kw">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span><span class="at">const</span> Base<span class="op">&amp;</span>, <span class="at">const</span> Base<span class="op">&amp;)</span>;  <span class="co">// #1</span></a>
<a class="sourceLine" id="cb8-3" title="3">  <span class="kw">friend</span> <span class="kw">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> Base<span class="op">&amp;</span>, <span class="at">const</span> Base<span class="op">&amp;)</span>; </a>
<a class="sourceLine" id="cb8-4" title="4"><span class="op">}</span>; </a>
<a class="sourceLine" id="cb8-5" title="5"><span class="kw">struct</span> Derived <span class="op">:</span> Base <span class="op">{</span> </a>
<a class="sourceLine" id="cb8-6" title="6">  <span class="kw">friend</span> <span class="bu">std::</span>strong_equality<span class="op"> </span><span class="kw">operator</span><span class="op">&lt;=&gt;(</span><span class="at">const</span> Derived<span class="op">&amp;</span>, <span class="at">const</span> Derived<span class="op">&amp;)</span>; <span class="co">// #2</span></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="op">}</span>; </a>
<a class="sourceLine" id="cb8-8" title="8"><span class="kw">bool</span> f<span class="op">(</span>Derived d1, Derived d2<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> d1 <span class="op">&lt;</span> d2; <span class="op">}</span> </a></code></pre></div>
<p>The status quo is that <code class="sourceCode cpp">d1 <span class="op">&lt;</span> d<span class="dv">2</span></code> invokes <code class="sourceCode cpp"><span class="pp">#1</span></code>. <code class="sourceCode cpp"><span class="pp">#2</span></code> is not actually a candidate because we have to consider the full expression <code class="sourceCode cpp"><span class="op">(</span>d1 <span class="op">&lt;=&gt;</span> d2<span class="op">)</span> <span class="op">&lt;</span> <span class="dv">0</span></code>. While <code class="sourceCode cpp"><span class="op">(</span>d1 <span class="op">&lt;=&gt;</span> d2<span class="op">)</span></code> is a valid expression, <code class="sourceCode cpp"><span class="op">(</span>d1 <span class="op">&lt;=&gt;</span> d2<span class="op">)</span> <span class="op">&lt;</span> <span class="dv">0</span></code> is not, which removes it from consideration.</p>
<p>The question here is: should we even consider the <code class="sourceCode cpp">@ <span class="dv">0</span></code> part of the rewritten expression for validity? If we did not, then <code class="sourceCode cpp"><span class="pp">#2</span></code> would become not only a candidate but also the best candidate. As a result, <code class="sourceCode cpp">d1 <span class="op">&lt;</span> d<span class="dv">2</span></code> becomes ill-formed by way of <code class="sourceCode cpp"><span class="pp">#2</span></code> because <code class="sourceCode cpp"><span class="op">(</span>d1 <span class="op">&lt;=&gt;</span> d2<span class="op">)</span> <span class="op">&lt;</span> <span class="dv">0</span></code> is not a valid expression. We‚Äôre no longer hiding that issue.</p>
<p>The reasoning here is that by considering the <code class="sourceCode cpp">@ <span class="dv">0</span></code> part of the expression for determining viable candidates, we are effectively overloading on return type. That doesn‚Äôt seem right.</p>
<h2 id="proposal-2"><span class="header-section-number">4.1</span> <a href="#proposal-2" class="self-link"></a>Proposal</h2>
<p>This paper agrees with Richard that we should not consider the validity of the <code class="sourceCode cpp">@ <span class="dv">0</span></code> part of the comparison in determining the candidate set. The provided example is well-formed in the current working draft, but becomes ill-formed as a result of this proposal. This change does not affect any C++17 code.</p>
<h1 id="default-comparisons-for-reference-data-members" style="border-bottom:1px solid #cccccc"><span class="header-section-number">5</span> <a href="#default-comparisons-for-reference-data-members" class="self-link"></a>Default comparisons for reference data members</h1>
<p>The last issue, also raised by Daveed Vandevoorde (<span class="citation" data-cites="vdv">[<a href="#ref-vdv" role="doc-biblioref">vdv</a>]</span>) is what should happen for the case where we try to default a comparison for a class that has data members of reference type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">struct</span> A <span class="op">{</span></a>
<a class="sourceLine" id="cb9-2" title="2">    <span class="kw">int</span> <span class="at">const</span><span class="op">&amp;</span> r;</a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span>A <span class="at">const</span><span class="op">&amp;</span>, A <span class="at">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</a>
<a class="sourceLine" id="cb9-4" title="4"><span class="op">}</span>;</a></code></pre></div>
<p>What should that do? The current wording in [class.compare.default] talks about a list of subobjects, and reference members aren‚Äôt actually subobjects, so it‚Äôs not clear what the intent is. There are three behaviors that such a defaulted comparison could have:</p>
<ol type="1">
<li>The comparison could be defined as deleted (following copy assignment with reference data members)</li>
<li>The comparison could compare the identity of the referent (following copy construction with reference data members)</li>
<li>The comparison could compare through the reference (following what rote expression substitution would do)</li>
</ol>
<p>In other words:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">int</span> i <span class="op">=</span> <span class="dv">0</span>, j <span class="op">=</span> <span class="dv">0</span>, k <span class="op">=</span> <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb10-2" title="2">              <span class="co">// |  option 1  | option 2 | option 3 |</span></a>
<a class="sourceLine" id="cb10-3" title="3">A<span class="op">{</span>i<span class="op">}</span> <span class="op">==</span> A<span class="op">{</span>i<span class="op">}</span>; <span class="co">// | ill-formed |   true   |   true   |</span></a>
<a class="sourceLine" id="cb10-4" title="4">A<span class="op">{</span>i<span class="op">}</span> <span class="op">==</span> A<span class="op">{</span>j<span class="op">}</span>; <span class="co">// | ill-formed |   false  |   true   |</span></a>
<a class="sourceLine" id="cb10-5" title="5">A<span class="op">{</span>i<span class="op">}</span> <span class="op">==</span> A<span class="op">{</span>k<span class="op">}</span>; <span class="co">// | ill-formed |   false  |   false  |</span></a></code></pre></div>
<p>Note however that reference data members add one more quirk in conjunction with <span class="citation" data-cites="P0732R2">[<a href="#ref-P0732R2" role="doc-biblioref">P0732R2</a>]</span>: does <code class="sourceCode cpp">A</code> count as having strong structural equality, and what would it mean for:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">int</span><span class="op">&amp;&gt;</span> <span class="kw">struct</span> X <span class="op">{</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="kw">template</span> <span class="op">&lt;</span>A<span class="op">&gt;</span> <span class="kw">struct</span> Y <span class="op">{</span> <span class="op">}</span>;</a>
<a class="sourceLine" id="cb11-3" title="3"><span class="at">static</span> <span class="kw">int</span> i <span class="op">=</span> <span class="dv">0</span>, j <span class="op">=</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb11-4" title="4">X<span class="op">&lt;</span>i<span class="op">&gt;</span> xi;</a>
<a class="sourceLine" id="cb11-5" title="5">X<span class="op">&lt;</span>j<span class="op">&gt;</span> xj;</a>
<a class="sourceLine" id="cb11-6" title="6"></a>
<a class="sourceLine" id="cb11-7" title="7">Y<span class="op">&lt;</span>A<span class="op">{</span>i<span class="op">}&gt;</span> yi;</a>
<a class="sourceLine" id="cb11-8" title="8">Y<span class="op">&lt;</span>A<span class="op">{</span>j<span class="op">}&gt;</span> yj;</a></code></pre></div>
<p>In even C++17, <code class="sourceCode cpp">xi</code> and <code class="sourceCode cpp">xj</code> are both well-formed and have different types. Under option 1 above, the declaration of <code class="sourceCode cpp">Y</code> is ill-formed because <code class="sourceCode cpp">A</code> does not have strong structural equality because its <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> would be defined as deleted. Under option 2, this would be well-formed and <code class="sourceCode cpp">yi</code> and <code class="sourceCode cpp">yj</code> would have different types ‚Äì consistent with <code class="sourceCode cpp">xi</code> and <code class="sourceCode cpp">xj</code>. Under option 3, <code class="sourceCode cpp">yi</code> and <code class="sourceCode cpp">yj</code> would be well-formed but somehow have the same type, which is a bad result. We would need to introduce a special rule that classes with reference data members cannot have strong structural equality.</p>
<h2 id="anonymous-unions"><span class="header-section-number">5.1</span> <a href="#anonymous-unions" class="self-link"></a>Anonymous unions</h2>
<p>In the same post <span class="citation" data-cites="vdv">[<a href="#ref-vdv" role="doc-biblioref">vdv</a>]</span>, Daveed also questioned what defaulted comparisons would do in the case of anonymous unions:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">struct</span> B <span class="op">{</span></a>
<a class="sourceLine" id="cb12-2" title="2">    <span class="kw">union</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb12-3" title="3">        <span class="kw">int</span> i;</a>
<a class="sourceLine" id="cb12-4" title="4">        <span class="kw">char</span> c;</a>
<a class="sourceLine" id="cb12-5" title="5">    <span class="op">}</span>;</a>
<a class="sourceLine" id="cb12-6" title="6">    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;(</span>B <span class="at">const</span><span class="op">&amp;</span>, B <span class="at">const</span><span class="op">&amp;)</span> <span class="op">=</span> <span class="cf">default</span>;</a>
<a class="sourceLine" id="cb12-7" title="7"><span class="op">}</span>;</a></code></pre></div>
<p>What does this mean? We can generalize this question to also include union-like classes - or any class that has a variant member. This is an interesting case to explore in the future, since at constexpr time such comparisons could be defined as valid whereas at normal runtime it really couldn‚Äôt be. But for now, the easy answer is to consider such defaulted comparisons as being defined as deleted and to make this decision more explicit in the wording.</p>
<h2 id="design-intent"><span class="header-section-number">5.2</span> <a href="#design-intent" class="self-link"></a>Design intent</h2>
<p>P0515 clearly lays out the design intent as comparison following copying, emphasis mine:</p>
<blockquote>
<p>This proposal unifies and regularizes the noncontroversial parts of previous proposals, and incorporates EWG direction to pursue three-way comparison, <strong>letting default copying guide default comparison</strong>, and having a simple way to write a memberwise comparison function body.</p>
</blockquote>
<p>and</p>
<blockquote>
<p>For raw pointers [‚Ä¶] I‚Äôm going with <code class="sourceCode cpp">strong_ordering</code>, <strong>on the basis of maintaining a strict parallel between default copying and default comparison</strong> (we copy raw pointer members, so we should compare them too unless there is a good reason to do otherwise [‚Ä¶])</p>
</blockquote>
<p>and</p>
<blockquote>
<p>For copyable arrays <code class="sourceCode cpp">T<span class="op">[</span>N<span class="op">]</span></code> (i.e., that are nonstatic data members), <code class="sourceCode cpp">T<span class="op">[</span>N<span class="op">]</span> <span class="op">&lt;=&gt;</span> T<span class="op">[</span>N<span class="op">]</span></code> returns the same type as <code class="sourceCode cpp">T</code>‚Äôs <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> and performs lexicographical elementwise comparison. For other arrays, <strong>there is no <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> because the arrays are not copyable.</strong></p>
</blockquote>
<h2 id="proposal-3"><span class="header-section-number">5.3</span> <a href="#proposal-3" class="self-link"></a>Proposal</h2>
<p>This paper proposes making more explicit that defaulted comparisons for classes that have reference data members or variant data members are defined as deleted. It‚Äôs the safest rule for now and is most consistent with the design intent as laid out in P0515.</p>
<p>A future proposal can always relax this restriction for reference data members by pursuing option 2 above.</p>
<h1 id="wording" style="border-bottom:1px solid #cccccc"><span class="header-section-number">6</span> <a href="#wording" class="self-link"></a>Wording</h1>
<p>Insert a new paragraph after 11.10.1 [class.compare.default]/1:</p>
<div class="add" style="color: #006e28">

<blockquote>
<p>A defaulted comparison operator function for class <code class="sourceCode cpp">C</code> is defined as deleted if any non-static data member of <code class="sourceCode cpp">C</code> is of reference type or <code class="sourceCode cpp">C</code> is a union-like class ([class.union.anon]).</p>
</blockquote>

</div>
<p>Change 11.10.1 [class.compare.default]/3.2:</p>
<blockquote>
<p>A type <code class="sourceCode cpp">C</code> has <em>strong structural equality</em> if, given a glvalue <code class="sourceCode cpp">x</code> of type <code class="sourceCode cpp"><span class="at">const</span> C</code>, either:</p>
<ul>
<li><code class="sourceCode cpp">C</code> is a non-class type and <code class="sourceCode cpp">x <span class="op">&lt;=&gt;</span> x</code> is a valid expression of type <code class="sourceCode cpp"><span class="bu">std::</span>strong_ordering</code> or <code class="sourceCode cpp"><span class="bu">std::</span>strong_equality</code>, or</li>
<li><code class="sourceCode cpp">C</code> is a class type with an <code class="sourceCode cpp"><span class="op">==</span></code> operator defined as defaulted in the definition of <code class="sourceCode cpp">C</code>, <code class="sourceCode cpp">x <span class="op">==</span> x</code> is <span class="rm" style="color: #bf0303"><del>well-formed when contextually converted to <span><code class="sourceCode cpp"><span class="kw">bool</span></code></span></del></span> <span class="add" style="color: #006e28"><ins>a valid expression of type <span><code class="sourceCode cpp"><span class="kw">bool</span></code></span></ins></span>, all of <code class="sourceCode cpp">C</code>‚Äôs base class subobjects and non-static data members have strong structural equality, and <code class="sourceCode cpp">C</code> has no <code class="sourceCode cpp"><span class="at">mutable</span></code> or <code class="sourceCode cpp"><span class="at">volatile</span></code> subobjects.</li>
</ul>
</blockquote>
<p>Change 12.3.1.2 [over.match.oper]/3.4:</p>
<blockquote>
<p>For the relational ([expr.rel]) operators, the rewritten candidates include all member, non-member, and built-in candidates for the <code class="sourceCode cpp"><span class="kw">operator</span> <span class="op">&lt;=&gt;</span></code> for which the rewritten expression <span class="rm" style="color: #bf0303"><del><span><code class="sourceCode cpp"><span class="op">(</span>x <span class="op">&lt;=&gt;</span> y<span class="op">)</span> @ <span class="dv">0</span></code></span> is well-formed using that operator<span><code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code></span></del></span> <span class="add" style="color: #006e28"><ins><span><code class="sourceCode cpp"><span class="op">(</span>x <span class="op">&lt;=&gt;</span> y<span class="op">)</span></code></span> is valid</ins></span>. For the relational ([expr.rel]) and three-way comparison ([expr.spaceship]) operators, the rewritten candidates also include a synthesized candidate, with the order of the two parameters reversed, for each member, non-member, and built-in candidate for the operator <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> for which the rewritten expression <span class="rm" style="color: #bf0303"><del><span><code class="sourceCode cpp"><span class="dv">0</span> @ <span class="op">(</span>y <span class="op">&lt;=&gt;</span> x<span class="op">)</span></code></span> is well-formed using that <span><code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code></span></del></span> <span class="add" style="color: #006e28"><ins><span><code class="sourceCode cpp"><span class="op">(</span>y <span class="op">&lt;=&gt;</span> x<span class="op">)</span></code></span> is valid</ins></span>. For the <code class="sourceCode cpp"><span class="op">!=</span></code> operator ([expr.eq]), the rewritten candidates include all member, non-member, and built-in candidates for the operator == for which the rewritten expression <code class="sourceCode cpp"><span class="op">(</span>x <span class="op">==</span> y<span class="op">)</span></code> is <span class="rm" style="color: #bf0303"><del>well-formed when contextually converted to <span><code class="sourceCode cpp"><span class="kw">bool</span></code></span> using that operator <span><code class="sourceCode cpp"><span class="op">==</span></code></span></del></span> <span class="add" style="color: #006e28"><ins>valid and of type <span><code class="sourceCode cpp"><span class="kw">bool</span></code></span></ins></span>. For the equality operators, the rewritten candidates also include a synthesized candidate, with the order of the two parameters reversed, for each member, non-member, and built-in candidate for the operator <code class="sourceCode cpp"><span class="op">==</span></code> for which the rewritten expression <code class="sourceCode cpp"><span class="op">(</span>y <span class="op">==</span> x<span class="op">)</span></code> is <span class="rm" style="color: #bf0303"><del>well-formed when contextually converted to <span><code class="sourceCode cpp"><span class="kw">bool</span></code></span> using that operator <span><code class="sourceCode cpp"><span class="op">==</span></code></span></del></span> <span class="add" style="color: #006e28"><ins>valid and of type <span><code class="sourceCode cpp"><span class="kw">bool</span></code></span></ins></span>. [-Note: A candidate synthesized from a member candidate has its implicit object parameter as the second parameter, thus implicit conversions are considered for the first, but not for the second, parameter. ‚Äîend note] In each case, rewritten candidates are not considered in the context of the rewritten expression. For all other operators, the rewritten candidate set is empty.</p>
</blockquote>
<p>Change 12.3.1.2 [over.match.oper]/8 to use <code class="sourceCode cpp"><span class="op">!</span></code> instead of <code class="sourceCode cpp"><span class="op">?:</span></code></p>
<blockquote>
<p>If a rewritten candidate is selected by overload resolution for a relational or three-way comparison operator <code class="sourceCode cpp">@</code>, <code class="sourceCode cpp">x @ y</code> is interpreted as the rewritten expression: <code class="sourceCode cpp"><span class="dv">0</span> @ <span class="op">(</span>y <span class="op">&lt;=&gt;</span> x<span class="op">)</span></code> if the selected candidate is a synthesized candidate with reversed order of parameters, or <code class="sourceCode cpp"><span class="op">(</span>x <span class="op">&lt;=&gt;</span> y<span class="op">)</span> @ <span class="dv">0</span></code> otherwise, using the selected rewritten <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code> candidate. If a rewritten candidate is selected by overload resolution for a <code class="sourceCode cpp"><span class="op">!=</span></code> operator, <code class="sourceCode cpp">x <span class="op">!=</span> y</code> is interpreted as <span class="rm" style="color: #bf0303"><del><span><code class="sourceCode cpp"><span class="op">(</span>y <span class="op">==</span> x<span class="op">)</span> <span class="op">?</span> <span class="kw">false</span> <span class="op">:</span> <span class="kw">true</span></code></span></del></span> <span class="add" style="color: #006e28"><ins><span><code class="sourceCode cpp"><span class="op">!(</span>y <span class="op">==</span> x<span class="op">)</span></code></span></ins></span> if the selected candidate is a synthesized candidate with reversed order of parameters, or <span class="rm" style="color: #bf0303"><del><span><code class="sourceCode cpp"><span class="op">(</span>x <span class="op">==</span> y<span class="op">)</span> <span class="op">?</span> <span class="kw">false</span> <span class="op">:</span> <span class="kw">true</span></code></span></del></span> <span class="add" style="color: #006e28"><ins><span><code class="sourceCode cpp"><span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span></code></span></ins></span> otherwise, using the selected rewritten operator== candidate. If a rewritten candidate is selected by overload resolution for an <code class="sourceCode cpp"><span class="op">==</span></code> operator, <code class="sourceCode cpp">x <span class="op">==</span> y</code> is interpreted as <span class="rm" style="color: #bf0303"><del><span><code class="sourceCode cpp"><span class="op">(</span>y <span class="op">==</span> x<span class="op">)</span> <span class="op">?</span> <span class="kw">true</span> <span class="op">:</span> <span class="kw">false</span></code></span></del></span> <span class="add" style="color: #006e28"><ins><span><code class="sourceCode cpp"><span class="op">(</span>y <span class="op">==</span> x<span class="op">)</span></code></span></ins></span> using the selected rewritten <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> candidate.</p>
</blockquote>
<p>Add a new entry to [diff.cpp17.over]:</p>
<div class="add" style="color: #006e28">

<blockquote>
<p><strong>Affected subclause</strong>: [over.match.oper] <br /> <strong>Change</strong>: Equality and inequality expressions can now find reversed and rewritten candidates. <br /> <strong>Rationale:</strong> Improve consistency of equality with spaceship and make it easier to write the full complement of equality operations. <br /> <strong>Effect on original feature:</strong> Equality and inequality expressions between two objects of different types, where one is convertible to the other, could change which operator is invoked. Equality and inequality expressions between two objects of the same type could become ambiguous.</p>
<div class="sourceCode" id="cb13" style="color: inherit"><pre class="sourceCode default"><code class="sourceCode default"><a class="sourceLine" id="cb13-1" title="1">struct A {</a>
<a class="sourceLine" id="cb13-2" title="2">  operator int() const;</a>
<a class="sourceLine" id="cb13-3" title="3">};</a>
<a class="sourceLine" id="cb13-4" title="4"></a>
<a class="sourceLine" id="cb13-5" title="5">bool operator==(A, int);              // #1</a>
<a class="sourceLine" id="cb13-6" title="6">// builtin bool operator==(int, int); // #2</a>
<a class="sourceLine" id="cb13-7" title="7">// builtin bool operator!=(int, int); // #3</a>
<a class="sourceLine" id="cb13-8" title="8"></a>
<a class="sourceLine" id="cb13-9" title="9">int check(A x, A y) {</a>
<a class="sourceLine" id="cb13-10" title="10">  return (x == y) +  // ill-formed; previously well-formed</a>
<a class="sourceLine" id="cb13-11" title="11">    (10 == x) +      // calls #1, previously called #2</a>
<a class="sourceLine" id="cb13-12" title="12">    (10 != x);       // calls #1, previously called #3</a>
<a class="sourceLine" id="cb13-13" title="13">}</a></code></pre></div>
</blockquote>

</div>
<div id="refs" class="references" role="doc-bibliography">
<div id="ref-cameron">
<p>[cameron] Cameron daCamara. 2019. Potential issue after P1185R2 - SFINAE breaking change. <br />
<a href="http://lists.isocpp.org/core/2019/04/5935.php">http://lists.isocpp.org/core/2019/04/5935.php</a></p>
</div>
<div id="ref-CWG2407">
<p>[CWG2407] Tomasz Kami≈Ñski. 2019. Missing entry in Annex C for defaulted comparison operators. <br />
<a href="http://wiki.edg.com/pub/Wg21cologne2019/CoreIssuesProcessingTeleconference2019-03-25/cwg_active.html#2407">http://wiki.edg.com/pub/Wg21cologne2019/CoreIssuesProcessingTeleconference2019-03-25/cwg_active.html#2407</a></p>
</div>
<div id="ref-herb">
<p>[herb] Herb Sutter. 2019. Overload resolution changes as a result of P1185R2. <br />
<a href="http://lists.isocpp.org/ext/2019/03/8704.php">http://lists.isocpp.org/ext/2019/03/8704.php</a></p>
</div>
<div id="ref-P0515R3">
<p>[P0515R3] Herb Sutter, Jens Maurer, Walter E. Brown. 2017. Consistent comparison. <br />
<a href="https://wg21.link/p0515r3">https://wg21.link/p0515r3</a></p>
</div>
<div id="ref-P0732R2">
<p>[P0732R2] Jeff Snyder, Louis Dionne. 2018. Class Types in Non-Type Template Parameters. <br />
<a href="https://wg21.link/p0732r2">https://wg21.link/p0732r2</a></p>
</div>
<div id="ref-P0905R1">
<p>[P0905R1] Tomasz Kami≈Ñski, Herb Sutter, Richard Smith. 2018. Symmetry for spaceship. <br />
<a href="https://wg21.link/p0905r1">https://wg21.link/p0905r1</a></p>
</div>
<div id="ref-P1185R2">
<p>[P1185R2] Barry Revzin. 2019. &lt;=&gt; != ==. <br />
<a href="https://wg21.link/p1185r2">https://wg21.link/p1185r2</a></p>
</div>
<div id="ref-P1190R0">
<p>[P1190R0] David Stone. 2018. I did not order this! Why is it on my bill? <br />
<a href="https://wg21.link/p1190r0">https://wg21.link/p1190r0</a></p>
</div>
<div id="ref-smith">
<p>[smith] Richard Smith. 2019. Processing relational/spaceship operator rewrites. <br />
<a href="http://lists.isocpp.org/core/2019/05/6420.php">http://lists.isocpp.org/core/2019/05/6420.php</a></p>
</div>
<div id="ref-vdv">
<p>[vdv] Daveed Vandevoorde. 2019. Generating comparison operators for classes with reference or anonymous union members. <br />
<a href="http://lists.isocpp.org/core/2019/05/6462.php">http://lists.isocpp.org/core/2019/05/6462.php</a></p>
</div>
</div>
</div>
</div>
</body>
</html>
