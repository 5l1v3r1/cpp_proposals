<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2019-06-15" />
  <title>The Mothership has Landed</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f6f8fa; }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span. { } /* Normal */
code span.al { color: #ff0000; } /* Alert */
code span.an { } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #9f6807; } /* BaseN */
code span.bu { color: #9f6807; } /* BuiltIn */
code span.cf { color: #00607c; } /* ControlFlow */
code span.ch { color: #9f6807; } /* Char */
code span.cn { } /* Constant */
code span.co { color: #008000; font-style: italic; } /* Comment */
code span.cv { color: #008000; font-style: italic; } /* CommentVar */
code span.do { color: #008000; } /* Documentation */
code span.dt { color: #00607c; } /* DataType */
code span.dv { color: #9f6807; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #9f6807; } /* Float */
code span.fu { } /* Function */
code span.im { } /* Import */
code span.in { color: #008000; } /* Information */
code span.kw { color: #00607c; } /* Keyword */
code span.op { color: #af1915; } /* Operator */
code span.ot { } /* Other */
code span.pp { color: #6f4e37; } /* Preprocessor */
code span.re { } /* RegionMarker */
code span.sc { color: #9f6807; } /* SpecialChar */
code span.ss { color: #9f6807; } /* SpecialString */
code span.st { color: #9f6807; } /* String */
code span.va { } /* Variable */
code span.vs { color: #9f6807; } /* VerbatimString */
code span.wa { color: #008000; font-weight: bold; } /* Warning */
code.diff {color: #898887}
code.diff span.va {color: #006e28}
code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li > span.marginalizedparent { left: -7em; }
li > ul > li > span.marginalizedparent { left: -9em; }
li > ul > li > ul > li > span.marginalizedparent { left: -11em; }
li > ul > li > ul > li > ul > li > span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }
div#refs p { padding-left: 32px; text-indent: -32px; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
:root {
--diff-ins: #e6ffed;
--diff-strongins: #acf2bd;
--diff-del: #ffdddd;
--diff-strongdel: #ff8888;
}
span.diffins {
background-color: var(--diff-strongins);
}
span.diffdel {
background-color: var(--diff-strongdel);
}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu, span.addu {
color: #006e28;
background-color: var(--diff-ins);
}

div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu pre { background-color: var(--diff-ins); }
div.add, div.add pre { background-color: var(--diff-ins); }
div.addu > blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
code.diff span.va { color: #000000; background-color: var(--diff-ins); }
code.diff span.st { color: #000000; background-color: var(--diff-del); }
</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">The Mothership has Landed</h1>
<h3 class="subtitle" style="text-align:center">Adding <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> to the Library</h3>

<table style="border:none;float:right">
  <tr>
    <td>Document #: </td>
    <td>D1614R1</td>
  </tr>
  <tr>
    <td>Date: </td>
    <td>2019-06-15</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project: </td>
    <td>Programming Language C++<br>
      LWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to: </td>
    <td>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#revision-history"><span class="toc-section-number">1</span> Revision History<span></span></a></li>
<li><a href="#introduction"><span class="toc-section-number">2</span> Introduction<span></span></a></li>
<li><a href="#friendship"><span class="toc-section-number">3</span> Friendship<span></span></a><ul>
<li><a href="#was-well-formed-now-ill-formed"><span class="toc-section-number">3.1</span> Was well-formed, now ill-formed<span></span></a></li>
<li><a href="#was-ill-formed-now-well-formed"><span class="toc-section-number">3.2</span> Was ill-formed, now well-formed<span></span></a></li>
<li><a href="#alternatives"><span class="toc-section-number">3.3</span> Alternatives<span></span></a></li>
<li><a href="#proposed-direction"><span class="toc-section-number">3.4</span> Proposed Direction<span></span></a></li>
</ul></li>
<li><a href="#acknowledgements"><span class="toc-section-number">4</span> Acknowledgements<span></span></a></li>
<li><a href="#wording"><span class="toc-section-number">5</span> Wording<span></span></a><ul>
<li><a href="#clause-16-library-introduction"><span class="toc-section-number">5.1</span> Clause 16: Library Introduction<span></span></a></li>
<li><a href="#clause-17-language-support-library"><span class="toc-section-number">5.2</span> Clause 17: Language support library<span></span></a></li>
<li><a href="#clause-18-concepts-library"><span class="toc-section-number">5.3</span> Clause 18: Concepts Library<span></span></a></li>
<li><a href="#clause-19-diagnostics-library"><span class="toc-section-number">5.4</span> Clause 19: Diagnostics Library<span></span></a></li>
<li><a href="#clause-20-general-utilities-library"><span class="toc-section-number">5.5</span> Clause 20: General utilities library<span></span></a></li>
<li><a href="#clause-21-strings-library"><span class="toc-section-number">5.6</span> Clause 21: Strings library<span></span></a></li>
<li><a href="#clause-22-containers-library"><span class="toc-section-number">5.7</span> Clause 22: Containers library<span></span></a></li>
<li><a href="#clause-23-iterators-library"><span class="toc-section-number">5.8</span> Clause 23: Iterators library<span></span></a></li>
<li><a href="#clause-24-ranges-library"><span class="toc-section-number">5.9</span> Clause 24: Ranges library<span></span></a></li>
<li><a href="#clause-25-algorithms-library"><span class="toc-section-number">5.10</span> Clause 25: Algorithms library<span></span></a></li>
<li><a href="#clause-26-numerics-library"><span class="toc-section-number">5.11</span> Clause 26: Numerics library<span></span></a></li>
<li><a href="#clause-27-time-library"><span class="toc-section-number">5.12</span> Clause 27: Time library<span></span></a></li>
<li><a href="#clause-28-localization-library"><span class="toc-section-number">5.13</span> Clause 28: Localization library<span></span></a></li>
<li><a href="#clause-29-inputoutput-library"><span class="toc-section-number">5.14</span> Clause 29: Input/output library<span></span></a></li>
<li><a href="#clause-30-regular-expressions-library"><span class="toc-section-number">5.15</span> Clause 30: Regular expressions library<span></span></a></li>
<li><a href="#clause-31-atomic-operations-library"><span class="toc-section-number">5.16</span> Clause 31: Atomic operations library<span></span></a></li>
<li><a href="#clause-32-thread-support-library"><span class="toc-section-number">5.17</span> Clause 32: Thread support library<span></span></a></li>
</ul></li>
<li><a href="#references"><span class="toc-section-number">6</span> References<span></span></a></li>
</ul>
</div>
<h1 id="revision-history" style="border-bottom:1px solid #cccccc"><span class="header-section-number">1</span> Revision History<a href="#revision-history" class="self-link"></a></h1>
<p><span class="citation" data-cites="P1614R0">[<a href="#ref-P1614R0" role="doc-biblioref">P1614R0</a>]</span> took the route of adding the new comparison operators as hidden friends. This paper instead preserves the current method of declaring comparisons - typically as non-member functions. See <a href="#friendship">friendship</a> for a more thorough discussion.</p>
<p>The comparisons between <code class="sourceCode cpp">unique_ptr<span class="op">&lt;</span>T, D<span class="op">&gt;</span></code> and <code class="sourceCode cpp"><span class="kw">nullptr</span></code> were originally removed and replaced with a <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code>, but this was reverted.</p>
<p>Additionally, R0 used the <code class="sourceCode default">3WAY</code><code class="sourceCode cpp"><span class="op">&lt;</span>R<span class="op">&gt;</span></code> wording from <span class="citation" data-cites="P1186R1">[<a href="#ref-P1186R1" role="doc-biblioref">P1186R1</a>]</span>, which was removed in the subsequent <span class="citation" data-cites="D1186R2">[<a href="#ref-D1186R2" role="doc-biblioref">D1186R2</a>]</span> - so the relevant wording for the fallback objects was changed as well.</p>
<h1 id="introduction" style="border-bottom:1px solid #cccccc"><span class="header-section-number">2</span> Introduction<a href="#introduction" class="self-link"></a></h1>
<p>The work of integrating <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code> into the library has been performed by multiple different papers, each addressing a different aspect of the integration. In the interest of streamlining review by the Library Working Group, the wording has been combined into a single paper. This is that paper.</p>
<p>In San Diego and Kona, several papers were approved by LEWG adding functionality to the library related to comparisons. What follows is the list of those papers, in alphabetical order, with a brief description of what those papers are. The complete motivation and design rationale for each can be found within the papers themselves.</p>
<ul>
<li><span class="citation" data-cites="P0790R2">[<a href="#ref-P0790R2" role="doc-biblioref">P0790R2</a>]</span> - adding <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code> to the standard library types whose behavior is not dependent on a template parameter.</li>
<li><span class="citation" data-cites="P0891R2">[<a href="#ref-P0891R2" role="doc-biblioref">P0891R2</a>]</span> - making the <code class="sourceCode cpp">XXX_order</code> algorithms customization points and introducing <code class="sourceCode cpp">compare_XXX_order_fallback</code> algorithms that preferentially invoke the former algorithm and fallback to synthesizing an ordering from <code class="sourceCode cpp"><span class="op">==</span></code> and <code class="sourceCode cpp"><span class="op">&lt;</span></code> (using the rules from <span class="citation" data-cites="P1186R1">[<a href="#ref-P1186R1" role="doc-biblioref">P1186R1</a>]</span>).</li>
<li><span class="citation" data-cites="P1154R1">[<a href="#ref-P1154R1" role="doc-biblioref">P1154R1</a>]</span> - adding the type trait <code class="sourceCode cpp">has_strong_structural_equality<span class="op">&lt;</span>T<span class="op">&gt;</span></code> (useful to check if a type can be used as a non-type template parameter).</li>
<li><span class="citation" data-cites="P1188R0">[<a href="#ref-P1188R0" role="doc-biblioref">P1188R0</a>]</span> - adding the type trait <code class="sourceCode cpp">compare_three_way_result<span class="op">&lt;</span>T<span class="op">&gt;</span></code>, the concepts <code class="sourceCode cpp">ThreeWayComparable<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp">ThreeWayComparableWith<span class="op">&lt;</span>T,U<span class="op">&gt;</span></code>, removing the algorithm <code class="sourceCode cpp">compare_3way</code> and replacing it with a function comparison object <code class="sourceCode cpp">compare_three_way</code> (i.e. the <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> version of <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>less</code>).</li>
<li><span class="citation" data-cites="P1189R0">[<a href="#ref-P1189R0" role="doc-biblioref">P1189R0</a>]</span> - adding <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code> to the standard library types whose behavior is dependent on a template parameter, removing those equality operators made redundant by <span class="citation" data-cites="P1185R2">[<a href="#ref-P1185R2" role="doc-biblioref">P1185R2</a>]</span> and defaulting <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> where appropriate.</li>
<li><span class="citation" data-cites="P1191R0">[<a href="#ref-P1191R0" role="doc-biblioref">P1191R0</a>]</span> - adding equality to several previously incomparable standard library types.</li>
<li><span class="citation" data-cites="P1295R0">[<a href="#ref-P1295R0" role="doc-biblioref">P1295R0</a>]</span> - adding equality and <code class="sourceCode cpp">common_type</code> for the comparison categories.</li>
<li><span class="citation" data-cites="P1380R1">[<a href="#ref-P1380R1" role="doc-biblioref">P1380R1</a>]</span> - extending the floating point customization points for <code class="sourceCode cpp">strong_order</code> and <code class="sourceCode cpp">weak_order</code>.</li>
</ul>
<h1 id="friendship" style="border-bottom:1px solid #cccccc"><span class="header-section-number">3</span> Friendship<a href="#friendship" class="self-link"></a></h1>
<p>LEWG’s unanimous preference was that the new <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code>s be declared as hidden friends. It would follow therefore that we would move the <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code>s to be declared the same way as well, since it would be pretty odd if the two different comparison operators had different semantics.</p>
<p>However, a few issues have come up with this approach that are worth presenting clearly here.</p>
<h2 id="was-well-formed-now-ill-formed"><span class="header-section-number">3.1</span> Was well-formed, now ill-formed<a href="#was-well-formed-now-ill-formed" class="self-link"></a></h2>
<p>Here is an example that came up while I attempted to implement these changes to measure any improvements in build time that might come up. This is a reproduction from the LLVM codebase:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">struct</span> StringRef <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    StringRef<span class="op">(</span>std<span class="op">::</span>string <span class="kw">const</span><span class="op">&amp;)</span>; <span class="co">// NB: non-explicit</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="kw">operator</span> std<span class="op">::</span>string<span class="op">()</span> <span class="kw">const</span>;  <span class="co">// NB: non-explicit</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="op">}</span>;</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>StringRef, StringRef<span class="op">)</span>;</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="dt">bool</span> f<span class="op">(</span>StringRef a, std<span class="op">::</span>string b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span class="cf">return</span> a <span class="op">==</span> b; <span class="co">// (*)</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="op">}</span></span></code></pre></div>
<p>In C++17, the marked line is well-formed. The <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> for <code class="sourceCode cpp">basic_string</code> is a non-member function template, and so would not be considered a candidate; the only viable candidate is the <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> taking two <code class="sourceCode cpp">StringRef</code>s. With the proposed changes, the <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> for <code class="sourceCode cpp">basic_string</code> becomes a non-member hidden friend, <em>non-template</em>, which makes it a candidate (converting <code class="sourceCode cpp">a</code> to a <code class="sourceCode cpp">string</code>). That candidate is ambiguous with the <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==(</span>StringRef, StringRef<span class="op">)</span></code> candidate - each requires a conversion in one argument, so the call becomes ill-formed.</p>
<p>Many people might consider such a type - implicitly convertible in both directions (note that <code class="sourceCode cpp">string</code> to <code class="sourceCode cpp">string_view</code> is implicit, but <code class="sourceCode cpp">string_view</code> to <code class="sourceCode cpp">string</code> is explicit) - questionable. But this is still a breaking change to consider.</p>
<h2 id="was-ill-formed-now-well-formed"><span class="header-section-number">3.2</span> Was ill-formed, now well-formed<a href="#was-ill-formed-now-well-formed" class="self-link"></a></h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="dt">bool</span> ref_equal<span class="op">(</span>std<span class="op">::</span>reference_wrapper<span class="op">&lt;</span>std<span class="op">::</span>string<span class="op">&gt;</span> a,</span>
<span id="cb2-2"><a href="#cb2-2"></a>               std<span class="op">::</span>reference_wrapper<span class="op">&lt;</span>std<span class="op">::</span>string<span class="op">&gt;</span> b<span class="op">)</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="cf">return</span> a <span class="op">==</span> b;</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="op">}</span></span></code></pre></div>
<p>The comparisons for <code class="sourceCode cpp">std<span class="op">::</span>reference_wrapper<span class="op">&lt;</span>T<span class="op">&gt;</span></code> are very strange. It’s not that this type is comparable based on <em>whether</em> <code class="sourceCode cpp">T</code> is comparable. It’s actually that this type is comparable based on <em>how</em> <code class="sourceCode cpp">T</code> is comparable. We can compare <code class="sourceCode cpp">std<span class="op">::</span>reference_wrapper<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code>s, but we cannot compare <code class="sourceCode cpp">std<span class="op">::</span>reference_wrapper<span class="op">&lt;</span>std<span class="op">::</span>string<span class="op">&gt;</span></code>s because the comparisons for <code class="sourceCode cpp">basic_string</code> are non-member function templates. That’s just weird. This change wouldn’t actually resolve that weirdness generally (it wouldn’t affect any user types whose comparisons are non-member function templates), but it would at least reduce it for the standard library. Arguably an improvement.</p>
<p>However, the more interesting case is:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="dt">bool</span> is42<span class="op">(</span>std<span class="op">::</span>variant<span class="op">&lt;</span><span class="dt">int</span>, std<span class="op">::</span>string<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="cf">return</span> v <span class="op">==</span> <span class="dv">42</span>; <span class="co">// (*)</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="op">}</span></span></code></pre></div>
<p>In C++17, the <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> for <code class="sourceCode cpp">variant</code> is a non-member function template and is thus not a viable candidate for the marked line. That check is ill-formed. With the proposed changes, the <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> for <code class="sourceCode cpp">variant</code> becomes a non-member hidden friend, <em>non-template</em>, which makes it a candidate (converting <code class="sourceCode cpp"><span class="dv">42</span></code> to a <code class="sourceCode cpp">variant<span class="op">&lt;</span><span class="dt">int</span>, string<span class="op">&gt;</span></code>). Many would argue that this a fix, since both <code class="sourceCode cpp">variant<span class="op">&lt;</span><span class="dt">int</span>, string<span class="op">&gt;</span> v <span class="op">=</span> <span class="dv">42</span>;</code> and <code class="sourceCode cpp">v <span class="op">=</span> <span class="dv">42</span>;</code> are already well-formed, so it is surely reasonable that <code class="sourceCode cpp">v <span class="op">==</span> <span class="dv">42</span></code> is as well.</p>
<p>But we already had a proposal to do precisely this: <span class="citation" data-cites="P1201R0">[<a href="#ref-P1201R0" role="doc-biblioref">P1201R0</a>]</span>, which failed to gain consensus in LEWGI in San Diego (vote was 2-6-2-3-3).</p>
<h2 id="alternatives"><span class="header-section-number">3.3</span> Alternatives<a href="#alternatives" class="self-link"></a></h2>
<p>The benefit of the hidden friend technique wasn’t the only way to achieve the ultimate goal of reducing the overload candidate set. Casey Carter suggested another:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> Traits <span class="op">=</span> char_traits<span class="op">&lt;</span>T<span class="op">&gt;</span>, <span class="kw">class</span> Alloc <span class="op">=</span> allocator<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span> <span class="kw">class</span> basic_string;</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">namespace</span> __foo <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="kw">struct</span> __tag <span class="op">{}</span>;</span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> Traits, <span class="kw">class</span> Alloc<span class="op">&gt;</span> </span>
<span id="cb4-7"><a href="#cb4-7"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> basic_string<span class="op">&lt;</span>T, Traits, Alloc<span class="op">&gt;&amp;</span>, <span class="kw">const</span> basic_string<span class="op">&lt;</span>T, Traits, Alloc<span class="op">&gt;&amp;)</span>;</span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a>  <span class="co">/* ... */</span></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> Traits, <span class="kw">class</span> Alloc<span class="op">&gt;</span> <span class="kw">class</span> basic_string <span class="op">:</span> <span class="kw">private</span> __foo<span class="op">::</span>__tag <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>  <span class="co">/* ... */</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="op">}</span>;</span></code></pre></div>
<p>That is, we keep <code class="sourceCode cpp">basic_string</code>’s comparisons as non-member function templates – but we move them into a different namespace that is <em>only</em> associated with <code class="sourceCode cpp">basic_string</code>. This is an interesting direction to take, but is novel and has some specification burden.</p>
<h2 id="proposed-direction"><span class="header-section-number">3.4</span> Proposed Direction<a href="#proposed-direction" class="self-link"></a></h2>
<p>Ultimately, the goal here is to add <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> to all the types in the standard library. While I think the goal of reducing the candidate set for comparisons with standard library types is absolutely worth pursuing, it is a completely orthogonal goal and can be addressed by a different proposal in the future.</p>
<p>Given that we’ve said that users aren’t allowed to take the address of most standard library functions, Casey’s proposed implementation might even be valid under today’s wording for those standard library class templates whose comparisons are non-member templates, so I’d encourage implementors to experiment there.</p>
<p>The direction this paper is taking is the path of least resistance: keep all the comparison operators as they are. Add <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> in the same form that <code class="sourceCode cpp"><span class="op">&lt;</span></code> appears today. With a few exceptions: those types for which adding a defaulted <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> would allow them to be used as non-type template parameters after <span class="citation" data-cites="P0732R2">[<a href="#ref-P0732R2" role="doc-biblioref">P0732R2</a>]</span> (and only those types) will have their comparisons implemented as hidden friends.</p>
<h1 id="acknowledgements" style="border-bottom:1px solid #cccccc"><span class="header-section-number">4</span> Acknowledgements<a href="#acknowledgements" class="self-link"></a></h1>
<p>Thank you to all the paper authors that have committed time to making sure all this works: Gašper Ažman, Walter Brown, Lawrence Crowl, Tomasz Kamiński, Arthur O’Dwyer, Jeff Snyder, David Stone, and Herb Sutter.</p>
<p>Thank you to Casey Carter for the tremendous wording review.</p>
<h1 id="wording" style="border-bottom:1px solid #cccccc"><span class="header-section-number">5</span> Wording<a href="#wording" class="self-link"></a></h1>
<h2 id="clause-16-library-introduction"><span class="header-section-number">5.1</span> Clause 16: Library Introduction<a href="#clause-16-library-introduction" class="self-link"></a></h2>
<p>Change 16.4.2.1/2 [expos.only.func]:</p>
<blockquote>
<p>The following <span class="rm" style="color: #bf0303"><del>function is</del></span> <span class="addu">are</span> defined for exposition only to aid in the specification of the library:</p>
</blockquote>
<p>and append:</p>
<blockquote>
<div class="add" style="color: #006e28">

<pre><code>constexpr auto @_synth-3way_@ =
  []&lt;class T, class U&gt;(const T&amp; t, const U&amp; u)
    requires requires {
      { t &lt; u } -&gt; bool;
      { u &lt; t } -&gt; bool;
    }
  {
    if constexpr (ThreeWayComparableWith&lt;T, U&gt;) {
      return t &lt;=&gt; u;
    } else {
      if (t &lt; u) return weak_ordering::less;
      if (u &lt; t) return weak_ordering::greater;
      return weak_ordering::equivalent;
    }
  };

template&lt;class T, class U=T&gt;
using @_synth-3way-result_@ = decltype(@_synth-3way_@(declval&lt;T&amp;&gt;(), declval&lt;U&amp;&gt;()));</code></pre>

</div>
</blockquote>
<p>Remove all of 16.4.2.3 [operators], which begins:</p>
<blockquote>
<p><span class="rm" style="color: #bf0303"><del>In this library, whenever a declaration is provided for an <span><code class="sourceCode cpp"><span class="kw">operator</span><span class="op">!=</span></code></span>, <span><code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&gt;</span></code></span>, <span><code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=</span></code></span>, or <span><code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&gt;=</span></code></span> for a type <span><code class="sourceCode cpp">T</code></span>, its requirements and semantics are as follows, unless explicitly specified otherwise.</del></span></p>
</blockquote>
<h2 id="clause-17-language-support-library"><span class="header-section-number">5.2</span> Clause 17: Language support library<a href="#clause-17-language-support-library" class="self-link"></a></h2>
<p>Added: <code class="sourceCode cpp">compare_three_way_result</code>, concepts <code class="sourceCode cpp">ThreeWayComparable</code> and <code class="sourceCode cpp">ThreeWayComparableWith</code>, <code class="sourceCode cpp">compare_three_way</code> and <code class="sourceCode cpp">compare_XXX_order_fallback</code></p>
<p>Changed operators for: <code class="sourceCode cpp">type_info</code></p>
<p>Respecified: <code class="sourceCode cpp">strong_order<span class="op">()</span></code>, <code class="sourceCode cpp">weak_order<span class="op">()</span></code>, and <code class="sourceCode cpp">partial_order<span class="op">()</span></code></p>
<p>Removed: <code class="sourceCode cpp">compare_3way<span class="op">()</span></code>, <code class="sourceCode cpp">strong_equal<span class="op">()</span></code>, and <code class="sourceCode cpp">weak_equal<span class="op">()</span></code></p>
<p>In 17.7.2 [type.info], remove <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">!=</span></code>:</p>
<blockquote>
<div class="sourceCode" id="cb6"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb6-1"><a href="#cb6-1"></a>namespace std {</span>
<span id="cb6-2"><a href="#cb6-2"></a>  class type_info {</span>
<span id="cb6-3"><a href="#cb6-3"></a>  public:</span>
<span id="cb6-4"><a href="#cb6-4"></a>    virtual ~type_info();</span>
<span id="cb6-5"><a href="#cb6-5"></a>    bool operator==(const type_info&amp; rhs) const noexcept;</span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="st">-   bool operator!=(const type_info&amp; rhs) const noexcept;</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>    bool before(const type_info&amp; rhs) const noexcept;</span>
<span id="cb6-8"><a href="#cb6-8"></a>    size_t hash_code() const noexcept;</span>
<span id="cb6-9"><a href="#cb6-9"></a>    const char* name() const noexcept;</span>
<span id="cb6-10"><a href="#cb6-10"></a>    type_info(const type_info&amp; rhs) = delete; // cannot be copied</span>
<span id="cb6-11"><a href="#cb6-11"></a>    type_info&amp; operator=(const type_info&amp; rhs) = delete; // cannot be copied</span>
<span id="cb6-12"><a href="#cb6-12"></a>  };</span>
<span id="cb6-13"><a href="#cb6-13"></a>}</span></code></pre></div>
</blockquote>
<p>and:</p>
<blockquote>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> type_info<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Effects</em>: Compares the current object with <code class="sourceCode cpp">rhs</code>. <span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="kw">true</span></code> if the two values describe the same type.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a>@[bool operator!=(const type_info&amp; rhs) const noexcept;]{.rm}@</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <span class="rm" style="color: #bf0303"><del><em>Returns</em>: <span><code class="sourceCode cpp"><span class="op">!(*</span><span class="kw">this</span> <span class="op">==</span> rhs<span class="op">)</span></code></span>.</del></span></p>
</blockquote>
<p>Add into 17.11.1 [compare.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb9"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb9-1"><a href="#cb9-1"></a>namespace std {</span>
<span id="cb9-2"><a href="#cb9-2"></a>  // [cmp.categories], comparison category types</span>
<span id="cb9-3"><a href="#cb9-3"></a>  class weak_equality;</span>
<span id="cb9-4"><a href="#cb9-4"></a>  class strong_equality;</span>
<span id="cb9-5"><a href="#cb9-5"></a>  class partial_ordering;</span>
<span id="cb9-6"><a href="#cb9-6"></a>  class weak_ordering;</span>
<span id="cb9-7"><a href="#cb9-7"></a>  class strong_ordering;</span>
<span id="cb9-8"><a href="#cb9-8"></a></span>
<span id="cb9-9"><a href="#cb9-9"></a>  // named comparison functions</span>
<span id="cb9-10"><a href="#cb9-10"></a>  constexpr bool is_eq  (weak_equality cmp) noexcept    { return cmp == 0; }</span>
<span id="cb9-11"><a href="#cb9-11"></a>  constexpr bool is_neq (weak_equality cmp) noexcept    { return cmp != 0; }</span>
<span id="cb9-12"><a href="#cb9-12"></a>  constexpr bool is_lt  (partial_ordering cmp) noexcept { return cmp &lt; 0; }</span>
<span id="cb9-13"><a href="#cb9-13"></a>  constexpr bool is_lteq(partial_ordering cmp) noexcept { return cmp &lt;= 0; }</span>
<span id="cb9-14"><a href="#cb9-14"></a>  constexpr bool is_gt  (partial_ordering cmp) noexcept { return cmp &gt; 0; }</span>
<span id="cb9-15"><a href="#cb9-15"></a>  constexpr bool is_gteq(partial_ordering cmp) noexcept { return cmp &gt;= 0; }</span>
<span id="cb9-16"><a href="#cb9-16"></a></span>
<span id="cb9-17"><a href="#cb9-17"></a>  // [cmp.common], common comparison category type</span>
<span id="cb9-18"><a href="#cb9-18"></a>  template&lt;class... Ts&gt;</span>
<span id="cb9-19"><a href="#cb9-19"></a>  struct common_comparison_category {</span>
<span id="cb9-20"><a href="#cb9-20"></a>    using type = @_see below_@;</span>
<span id="cb9-21"><a href="#cb9-21"></a>  };</span>
<span id="cb9-22"><a href="#cb9-22"></a>  template&lt;class... Ts&gt;</span>
<span id="cb9-23"><a href="#cb9-23"></a>    using common_comparison_category_t = typename common_comparison_category&lt;Ts...&gt;::type;</span>
<span id="cb9-24"><a href="#cb9-24"></a></span>
<span id="cb9-25"><a href="#cb9-25"></a><span class="va">+ // [cmp.concept], concept ThreeWayComparable</span></span>
<span id="cb9-26"><a href="#cb9-26"></a><span class="va">+ template&lt;class T, class Cat = partial_ordering&gt;</span></span>
<span id="cb9-27"><a href="#cb9-27"></a><span class="va">+   concept ThreeWayComparable = @_see below_@;</span></span>
<span id="cb9-28"><a href="#cb9-28"></a><span class="va">+ template&lt;class T, class U, class Cat = partial_ordering&gt;</span></span>
<span id="cb9-29"><a href="#cb9-29"></a><span class="va">+   concept ThreeWayComparableWith = @_see below_@;</span></span>
<span id="cb9-30"><a href="#cb9-30"></a><span class="va">+</span></span>
<span id="cb9-31"><a href="#cb9-31"></a><span class="va">+ // [cmp.result], spaceship invocation result</span></span>
<span id="cb9-32"><a href="#cb9-32"></a><span class="va">+ template&lt;class T, class U = T&gt; struct compare_three_way_result;</span></span>
<span id="cb9-33"><a href="#cb9-33"></a><span class="va">+</span></span>
<span id="cb9-34"><a href="#cb9-34"></a><span class="va">+ template&lt;class T, class U = T&gt;</span></span>
<span id="cb9-35"><a href="#cb9-35"></a><span class="va">+   using compare_three_way_result_t = typename compare_three_way_result&lt;T, U&gt;::type;</span></span>
<span id="cb9-36"><a href="#cb9-36"></a><span class="va">+</span></span>
<span id="cb9-37"><a href="#cb9-37"></a><span class="va">+ // [cmp.object], spaceship object</span></span>
<span id="cb9-38"><a href="#cb9-38"></a><span class="va">+ struct compare_three_way;</span></span>
<span id="cb9-39"><a href="#cb9-39"></a></span>
<span id="cb9-40"><a href="#cb9-40"></a>  // [cmp.alg], comparison algorithms</span>
<span id="cb9-41"><a href="#cb9-41"></a><span class="st">- template&lt;class T&gt; constexpr strong_ordering strong_order(const T&amp; a, const T&amp; b);</span></span>
<span id="cb9-42"><a href="#cb9-42"></a><span class="st">- template&lt;class T&gt; constexpr weak_ordering weak_order(const T&amp; a, const T&amp; b);</span></span>
<span id="cb9-43"><a href="#cb9-43"></a><span class="st">- template&lt;class T&gt; constexpr partial_ordering partial_order(const T&amp; a, const T&amp; b);</span></span>
<span id="cb9-44"><a href="#cb9-44"></a><span class="st">- template&lt;class T&gt; constexpr strong_equality strong_equal(const T&amp; a, const T&amp; b);</span></span>
<span id="cb9-45"><a href="#cb9-45"></a><span class="st">- template&lt;class T&gt; constexpr weak_equality weak_equal(const T&amp; a, const T&amp; b);</span></span>
<span id="cb9-46"><a href="#cb9-46"></a><span class="va">+ inline namespace @_unspecified_@ {</span></span>
<span id="cb9-47"><a href="#cb9-47"></a><span class="va">+   inline constexpr @_unspecified_@ strong_order = @_unspecified_@;</span></span>
<span id="cb9-48"><a href="#cb9-48"></a><span class="va">+   inline constexpr @_unspecified_@ weak_order = @_unspecified_@;</span></span>
<span id="cb9-49"><a href="#cb9-49"></a><span class="va">+   inline constexpr @_unspecified_@ partial_order = @_unspecified_@;</span></span>
<span id="cb9-50"><a href="#cb9-50"></a><span class="va">+   inline constexpr @_unspecified_@ compare_strong_order_fallback = @_unspecified_@;</span></span>
<span id="cb9-51"><a href="#cb9-51"></a><span class="va">+   inline constexpr @_unspecified_@ compare_weak_order_fallback = @_unspecified_@;</span></span>
<span id="cb9-52"><a href="#cb9-52"></a><span class="va">+   inline constexpr @_unspecified_@ compare_partial_order_fallback = @_unspecified_@;</span></span>
<span id="cb9-53"><a href="#cb9-53"></a><span class="va">+ }</span></span>
<span id="cb9-54"><a href="#cb9-54"></a>}</span></code></pre></div>
</blockquote>
<p>Change 17.11.2.2 [cmp.weakeq]:</p>
<blockquote>
<div class="sourceCode" id="cb10"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb10-1"><a href="#cb10-1"></a>namespace std {</span>
<span id="cb10-2"><a href="#cb10-2"></a>  class weak_equality {</span>
<span id="cb10-3"><a href="#cb10-3"></a>    int value;  // exposition only</span>
<span id="cb10-4"><a href="#cb10-4"></a></span>
<span id="cb10-5"><a href="#cb10-5"></a>    [...]</span>
<span id="cb10-6"><a href="#cb10-6"></a></span>
<span id="cb10-7"><a href="#cb10-7"></a>    // comparisons</span>
<span id="cb10-8"><a href="#cb10-8"></a>    friend constexpr bool operator==(weak_equality v, @_unspecified_@) noexcept;</span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="st">-   friend constexpr bool operator!=(weak_equality v, @_unspecified_@) noexcept;</span></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="st">-   friend constexpr bool operator==(@_unspecified_@, weak_equality v) noexcept;</span></span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="st">-   friend constexpr bool operator!=(@_unspecified_@, weak_equality v) noexcept;</span></span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="va">+   friend constexpr bool operator==(weak_equality v, weak_equality w) noexcept = default;</span></span>
<span id="cb10-13"><a href="#cb10-13"></a>    friend constexpr weak_equality operator&lt;=&gt;(weak_equality v, @_unspecified_@) noexcept;</span>
<span id="cb10-14"><a href="#cb10-14"></a>    friend constexpr weak_equality operator&lt;=&gt;(@_unspecified_@, weak_equality v) noexcept;</span>
<span id="cb10-15"><a href="#cb10-15"></a>  };</span>
<span id="cb10-16"><a href="#cb10-16"></a></span>
<span id="cb10-17"><a href="#cb10-17"></a>  [...]</span>
<span id="cb10-18"><a href="#cb10-18"></a>}</span></code></pre></div>
</blockquote>
<p>and remove those functions from the description:</p>
<blockquote>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>weak_equality v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb11-2"><a href="#cb11-2"></a>@[constexpr bool operator==(_unspecified_, weak_equality v) noexcept;]{.rm}@</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp">v<span class="op">.</span>value <span class="op">==</span> <span class="dv">0</span></code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a>@[constexpr bool operator!=(weak_equality v, _unspecified_) noexcept;]{.rm}@</span>
<span id="cb12-2"><a href="#cb12-2"></a>@[constexpr bool operator!=(_unspecified_, weak_equality v) noexcept;]{.rm}@</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <span class="rm" style="color: #bf0303"><del><em>Returns</em>: <span><code class="sourceCode cpp">v<span class="op">.</span>value <span class="op">!=</span> <span class="dv">0</span></code></span>.</del></span></p>
</blockquote>
<p>Change 17.11.2.3 [cmp.strongeq]:</p>
<blockquote>
<div class="sourceCode" id="cb13"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb13-1"><a href="#cb13-1"></a>namespace std {</span>
<span id="cb13-2"><a href="#cb13-2"></a>  class strong_equality {</span>
<span id="cb13-3"><a href="#cb13-3"></a>    int value;  // exposition only</span>
<span id="cb13-4"><a href="#cb13-4"></a></span>
<span id="cb13-5"><a href="#cb13-5"></a>    [...]</span>
<span id="cb13-6"><a href="#cb13-6"></a></span>
<span id="cb13-7"><a href="#cb13-7"></a>    // comparisons</span>
<span id="cb13-8"><a href="#cb13-8"></a>    friend constexpr bool operator==(strong_equality v, @_unspecified_@) noexcept;</span>
<span id="cb13-9"><a href="#cb13-9"></a><span class="st">-   friend constexpr bool operator!=(strong_equality v, @_unspecified_@) noexcept;</span></span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="st">-   friend constexpr bool operator==(@_unspecified_@, strong_equality v) noexcept;</span></span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="st">-   friend constexpr bool operator!=(@_unspecified_@, strong_equality v) noexcept;</span></span>
<span id="cb13-12"><a href="#cb13-12"></a><span class="va">+   friend constexpr bool operator==(strong_equality v, strong_equality w) noexcept = default;  </span></span>
<span id="cb13-13"><a href="#cb13-13"></a>    friend constexpr strong_equality operator&lt;=&gt;(strong_equality v, @_unspecified_@) noexcept;</span>
<span id="cb13-14"><a href="#cb13-14"></a>    friend constexpr strong_equality operator&lt;=&gt;(@_unspecified_@, strong_equality v) noexcept;</span>
<span id="cb13-15"><a href="#cb13-15"></a>  };</span>
<span id="cb13-16"><a href="#cb13-16"></a></span>
<span id="cb13-17"><a href="#cb13-17"></a>  [...]</span>
<span id="cb13-18"><a href="#cb13-18"></a>}</span></code></pre></div>
</blockquote>
<p>and remove those functions from the description:</p>
<blockquote>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>strong_equality v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb14-2"><a href="#cb14-2"></a>@[constexpr bool operator==(_unspecified_, strong_equality v) noexcept;]{.rm}@</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: <code class="sourceCode cpp">v<span class="op">.</span>value <span class="op">==</span> <span class="dv">0</span></code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a>@[constexpr bool operator!=(strong_equality v, _unspecified_) noexcept;]{.rm}@</span>
<span id="cb15-2"><a href="#cb15-2"></a>@[constexpr bool operator!=(_unspecified_, strong_equality v) noexcept;]{.rm}@</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <span class="rm" style="color: #bf0303"><del><em>Returns</em>: <span><code class="sourceCode cpp">v<span class="op">.</span>value <span class="op">!=</span> <span class="dv">0</span></code></span>.</del></span></p>
</blockquote>
<p>Change 17.11.2.4 [cmp.partialord]:</p>
<blockquote>
<div class="sourceCode" id="cb16"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb16-1"><a href="#cb16-1"></a>namespace std {</span>
<span id="cb16-2"><a href="#cb16-2"></a>  class partial_ordering {</span>
<span id="cb16-3"><a href="#cb16-3"></a>    int value;          // exposition only</span>
<span id="cb16-4"><a href="#cb16-4"></a>    bool is_ordered;    // exposition only</span>
<span id="cb16-5"><a href="#cb16-5"></a></span>
<span id="cb16-6"><a href="#cb16-6"></a>    [...]</span>
<span id="cb16-7"><a href="#cb16-7"></a></span>
<span id="cb16-8"><a href="#cb16-8"></a>    // conversion</span>
<span id="cb16-9"><a href="#cb16-9"></a>    constexpr operator weak_equality() const noexcept;</span>
<span id="cb16-10"><a href="#cb16-10"></a></span>
<span id="cb16-11"><a href="#cb16-11"></a>    // comparisons</span>
<span id="cb16-12"><a href="#cb16-12"></a>    friend constexpr bool operator==(partial_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb16-13"><a href="#cb16-13"></a><span class="st">-   friend constexpr bool operator!=(partial_ordering v, @_unspecified_@) noexcept;</span></span>
<span id="cb16-14"><a href="#cb16-14"></a><span class="va">+   friend constexpr bool operator==(partial_ordering v, partial_ordering w) noexcept = default;</span></span>
<span id="cb16-15"><a href="#cb16-15"></a>    friend constexpr bool operator&lt; (partial_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb16-16"><a href="#cb16-16"></a>    friend constexpr bool operator&gt; (partial_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb16-17"><a href="#cb16-17"></a>    friend constexpr bool operator&lt;=(partial_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb16-18"><a href="#cb16-18"></a>    friend constexpr bool operator&gt;=(partial_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb16-19"><a href="#cb16-19"></a><span class="st">-   friend constexpr bool operator==(@_unspecified_@, partial_ordering v) noexcept;</span></span>
<span id="cb16-20"><a href="#cb16-20"></a><span class="st">-   friend constexpr bool operator!=(@_unspecified_@, partial_ordering v) noexcept;</span></span>
<span id="cb16-21"><a href="#cb16-21"></a>    friend constexpr bool operator&lt; (@_unspecified_@, partial_ordering v) noexcept;</span>
<span id="cb16-22"><a href="#cb16-22"></a>    friend constexpr bool operator&gt; (@_unspecified_@, partial_ordering v) noexcept;</span>
<span id="cb16-23"><a href="#cb16-23"></a>    friend constexpr bool operator&lt;=(@_unspecified_@, partial_ordering v) noexcept;</span>
<span id="cb16-24"><a href="#cb16-24"></a>    friend constexpr bool operator&gt;=(@_unspecified_@, partial_ordering v) noexcept;</span>
<span id="cb16-25"><a href="#cb16-25"></a>    friend constexpr partial_ordering operator&lt;=&gt;(partial_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb16-26"><a href="#cb16-26"></a>    friend constexpr partial_ordering operator&lt;=&gt;(@_unspecified_@, partial_ordering v) noexcept;</span>
<span id="cb16-27"><a href="#cb16-27"></a>  };</span>
<span id="cb16-28"><a href="#cb16-28"></a></span>
<span id="cb16-29"><a href="#cb16-29"></a>  [...]</span>
<span id="cb16-30"><a href="#cb16-30"></a>}</span></code></pre></div>
</blockquote>
<p>Remove just the extra <code class="sourceCode cpp"><span class="op">==</span></code> and <code class="sourceCode cpp"><span class="op">!=</span></code> operators in 17.11.2.4 [cmp.partialord]/4-5:</p>
<blockquote>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>partial_ordering v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;</span> <span class="op">(</span>partial_ordering v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;</span> <span class="op">(</span>partial_ordering v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span>partial_ordering v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span>partial_ordering v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: For <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>, <code class="sourceCode cpp">v<span class="op">.</span>is_ordered <span class="op">&amp;&amp;</span> v<span class="op">.</span>value <span class="op">@</span> <span class="dv">0</span></code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a>@[constexpr bool operator==(_unspecified_, partial_ordering v) noexcept;]{.rm}@</span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;</span> <span class="op">(</span>@_unspecified_@, partial_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;</span> <span class="op">(</span>@_unspecified_@, partial_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span>@_unspecified_@, partial_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span>@_unspecified_@, partial_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: For <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>, <code class="sourceCode cpp">v<span class="op">.</span>is_ordered <span class="op">&amp;&amp;</span> <span class="dv">0</span> <span class="op">@</span> v<span class="op">.</span>value</code>.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a>@[constexpr bool operator!=(partial_ordering v, _unspecified_) noexcept;]{.rm}@</span>
<span id="cb19-2"><a href="#cb19-2"></a>@[constexpr bool operator!=(_unspecified_, partial_ordering v) noexcept;]{.rm}@</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <span class="rm" style="color: #bf0303"><del><em>Returns</em>: For <span><code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code></span>, <span><code class="sourceCode cpp"><span class="op">!</span>v<span class="op">.</span>is_ordered <span class="op">||</span> v<span class="op">.</span>value <span class="op">!=</span> <span class="dv">0</span></code></span>.</del></span></p>
</blockquote>
<p>Change 17.11.2.5 [cmp.weakord]:</p>
<blockquote>
<div class="sourceCode" id="cb20"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb20-1"><a href="#cb20-1"></a>namespace std {</span>
<span id="cb20-2"><a href="#cb20-2"></a>  class weak_ordering {</span>
<span id="cb20-3"><a href="#cb20-3"></a>    int value;  // exposition only</span>
<span id="cb20-4"><a href="#cb20-4"></a></span>
<span id="cb20-5"><a href="#cb20-5"></a>    [...]</span>
<span id="cb20-6"><a href="#cb20-6"></a>    // comparisons</span>
<span id="cb20-7"><a href="#cb20-7"></a>    friend constexpr bool operator==(weak_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb20-8"><a href="#cb20-8"></a><span class="va">+   friend constexpr bool operator==(weak_ordering v, weak_ordering w) noexcept = default;</span></span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="st">-   friend constexpr bool operator!=(weak_ordering v, @_unspecified_@) noexcept;</span></span>
<span id="cb20-10"><a href="#cb20-10"></a>    friend constexpr bool operator&lt; (weak_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb20-11"><a href="#cb20-11"></a>    friend constexpr bool operator&gt; (weak_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb20-12"><a href="#cb20-12"></a>    friend constexpr bool operator&lt;=(weak_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb20-13"><a href="#cb20-13"></a>    friend constexpr bool operator&gt;=(weak_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb20-14"><a href="#cb20-14"></a><span class="st">-   friend constexpr bool operator==(@_unspecified_@, weak_ordering v) noexcept;</span></span>
<span id="cb20-15"><a href="#cb20-15"></a><span class="st">-   friend constexpr bool operator!=(@_unspecified_@, weak_ordering v) noexcept;</span></span>
<span id="cb20-16"><a href="#cb20-16"></a>    friend constexpr bool operator&lt; (@_unspecified_@, weak_ordering v) noexcept;</span>
<span id="cb20-17"><a href="#cb20-17"></a>    friend constexpr bool operator&gt; (@_unspecified_@, weak_ordering v) noexcept;</span>
<span id="cb20-18"><a href="#cb20-18"></a>    friend constexpr bool operator&lt;=(@_unspecified_@, weak_ordering v) noexcept;</span>
<span id="cb20-19"><a href="#cb20-19"></a>    friend constexpr bool operator&gt;=(@_unspecified_@, weak_ordering v) noexcept;</span>
<span id="cb20-20"><a href="#cb20-20"></a>    friend constexpr weak_ordering operator&lt;=&gt;(weak_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb20-21"><a href="#cb20-21"></a>    friend constexpr weak_ordering operator&lt;=&gt;(@_unspecified_@, weak_ordering v) noexcept;</span>
<span id="cb20-22"><a href="#cb20-22"></a>  };</span>
<span id="cb20-23"><a href="#cb20-23"></a></span>
<span id="cb20-24"><a href="#cb20-24"></a>  [...]</span>
<span id="cb20-25"><a href="#cb20-25"></a>}</span></code></pre></div>
</blockquote>
<p>Remove just the extra <code class="sourceCode cpp"><span class="op">==</span></code> and <code class="sourceCode cpp"><span class="op">!=</span></code> operators from 17.11.2.5 [cmp.weakord]/4 and /5:</p>
<blockquote>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>weak_ordering v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb21-2"><a href="#cb21-2"></a>@[constexpr bool operator!=(weak_ordering v, _unspecified_) noexcept;]{.rm}@</span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;</span> <span class="op">(</span>weak_ordering v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;</span> <span class="op">(</span>weak_ordering v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span>weak_ordering v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span>weak_ordering v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: <code class="sourceCode cpp">v<span class="op">.</span>value <span class="op">@</span> <span class="dv">0</span></code> for <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a>@[constexpr bool operator==(_unspecified_, weak_ordering v) noexcept;]{.rm}@</span>
<span id="cb22-2"><a href="#cb22-2"></a>@[constexpr bool operator!=(_unspecified_, weak_ordering v) noexcept;]{.rm}@</span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;</span> <span class="op">(</span>@_unspecified_@, weak_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;</span> <span class="op">(</span>@_unspecified_@, weak_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span>@_unspecified_@, weak_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb22-6"><a href="#cb22-6"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span>@_unspecified_@, weak_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="dv">0</span> <span class="op">@</span> v<span class="op">.</span>value</code> for <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>.</p>
</blockquote>
<p>Change 17.11.2.6 [cmp.strongord]:</p>
<blockquote>
<div class="sourceCode" id="cb23"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb23-1"><a href="#cb23-1"></a>namespace std {</span>
<span id="cb23-2"><a href="#cb23-2"></a>  class strong_ordering {</span>
<span id="cb23-3"><a href="#cb23-3"></a>    int value;  // exposition only</span>
<span id="cb23-4"><a href="#cb23-4"></a></span>
<span id="cb23-5"><a href="#cb23-5"></a>    [...]</span>
<span id="cb23-6"><a href="#cb23-6"></a></span>
<span id="cb23-7"><a href="#cb23-7"></a>    // comparisons</span>
<span id="cb23-8"><a href="#cb23-8"></a>    friend constexpr bool operator==(strong_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb23-9"><a href="#cb23-9"></a><span class="va">+   friend constexpr bool operator==(strong_ordering v, strong_ordering w) noexcept = default;</span></span>
<span id="cb23-10"><a href="#cb23-10"></a><span class="st">-   friend constexpr bool operator!=(strong_ordering v, @_unspecified_@) noexcept;</span></span>
<span id="cb23-11"><a href="#cb23-11"></a>    friend constexpr bool operator&lt; (strong_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb23-12"><a href="#cb23-12"></a>    friend constexpr bool operator&gt; (strong_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb23-13"><a href="#cb23-13"></a>    friend constexpr bool operator&lt;=(strong_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb23-14"><a href="#cb23-14"></a>    friend constexpr bool operator&gt;=(strong_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb23-15"><a href="#cb23-15"></a><span class="st">-   friend constexpr bool operator==(@_unspecified_@, strong_ordering v) noexcept;</span></span>
<span id="cb23-16"><a href="#cb23-16"></a><span class="st">-   friend constexpr bool operator!=(@_unspecified_@, strong_ordering v) noexcept;</span></span>
<span id="cb23-17"><a href="#cb23-17"></a>    friend constexpr bool operator&lt; (@_unspecified_@, strong_ordering v) noexcept;</span>
<span id="cb23-18"><a href="#cb23-18"></a>    friend constexpr bool operator&gt; (@_unspecified_@, strong_ordering v) noexcept;</span>
<span id="cb23-19"><a href="#cb23-19"></a>    friend constexpr bool operator&lt;=(@_unspecified_@, strong_ordering v) noexcept;</span>
<span id="cb23-20"><a href="#cb23-20"></a>    friend constexpr bool operator&gt;=(@_unspecified_@, strong_ordering v) noexcept;</span>
<span id="cb23-21"><a href="#cb23-21"></a>    friend constexpr strong_ordering operator&lt;=&gt;(strong_ordering v, @_unspecified_@) noexcept;</span>
<span id="cb23-22"><a href="#cb23-22"></a>    friend constexpr strong_ordering operator&lt;=&gt;(@_unspecified_@, strong_ordering v) noexcept;</span>
<span id="cb23-23"><a href="#cb23-23"></a>  };</span>
<span id="cb23-24"><a href="#cb23-24"></a></span>
<span id="cb23-25"><a href="#cb23-25"></a>  [...]</span>
<span id="cb23-26"><a href="#cb23-26"></a>}</span></code></pre></div>
</blockquote>
<p>Remove just the extra <code class="sourceCode cpp"><span class="op">==</span></code> and <code class="sourceCode cpp"><span class="op">!=</span></code> operators from 17.11.2.6 [cmp.strongord]/6 and /7:</p>
<blockquote>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>strong_ordering v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb24-2"><a href="#cb24-2"></a>@[constexpr bool operator!=(strong_ordering v, _unspecified_) noexcept;]{.rm}@</span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;</span> <span class="op">(</span>strong_ordering v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;</span> <span class="op">(</span>strong_ordering v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span>strong_ordering v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span>strong_ordering v, @_unspecified_@<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Returns</em>: <code class="sourceCode cpp">v<span class="op">.</span>value <span class="op">@</span> <span class="dv">0</span></code> for <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a>@[constexpr bool operator==(_unspecified_, strong_ordering v) noexcept;]{.rm}@</span>
<span id="cb25-2"><a href="#cb25-2"></a>@[constexpr bool operator!=(_unspecified_, strong_ordering v) noexcept;]{.rm}@</span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;</span> <span class="op">(</span>@_unspecified_@, strong_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;</span> <span class="op">(</span>@_unspecified_@, strong_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb25-5"><a href="#cb25-5"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span>@_unspecified_@, strong_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span>@_unspecified_@, strong_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="dv">0</span> <span class="op">@</span> v<span class="op">.</span>value</code> for <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>.</p>
</blockquote>
<p>Add a new subclause [cmp.concept] “concept ThreeWayComparable”:</p>
<blockquote>
<div class="add" style="color: #006e28">

<pre><code>template &lt;typename T, typename Cat&gt;
  concept @_compares-as_@ = // exposition only
    Same&lt;common_comparison_category_t&lt;T, Cat&gt;, Cat&gt;;</code></pre>
<pre><code>template&lt;class T, class U&gt;
  concept @_partially-ordered-with_@ = // exposition only
    requires(const remove_reference_t&lt;T&gt;&amp; t,
             const remove_reference_t&lt;U&gt;&amp; u) {
      { t &lt; u } -&gt; Boolean;
      { t &gt; u } -&gt; Boolean;
      { t &lt;= u } -&gt; Boolean;
      { t &gt;= u } -&gt; Boolean;
      { u &lt; t } -&gt; Boolean;
      { u &gt; t } -&gt; Boolean;
      { u &lt;= t } -&gt; Boolean;
      { u &gt;= t } -&gt; Boolean;    
    };</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> Let <code class="sourceCode cpp">t</code> and <code class="sourceCode cpp">u</code> be lvalues of types <code class="sourceCode cpp"><span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp"><span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>U<span class="op">&gt;</span></code> respectively. <em><code class="sourceCode cpp">partially<span class="op">-</span>ordered<span class="op">-</span>with</code></em><code class="sourceCode cpp"><span class="op">&lt;</span>T, U<span class="op">&gt;</span></code> is satisfied only if:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(1.1)</a></span> <code class="sourceCode cpp">t <span class="op">&lt;</span> u</code>, <code class="sourceCode cpp">t <span class="op">&lt;=</span> u</code>, <code class="sourceCode cpp">t <span class="op">&gt;</span> u</code>, <code class="sourceCode cpp">t <span class="op">&gt;=</span> u</code>, <code class="sourceCode cpp">u <span class="op">&lt;</span> t</code>, <code class="sourceCode cpp">u <span class="op">&lt;=</span> t</code>, <code class="sourceCode cpp">u <span class="op">&gt;</span> t</code>, and <code class="sourceCode cpp">u <span class="op">&gt;=</span> t</code> have the same domain.</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.2)</a></span> <code class="sourceCode cpp"><span class="dt">bool</span><span class="op">(</span>t <span class="op">&lt;</span> u<span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>u <span class="op">&gt;</span> t<span class="op">)</span></code></li>
<li><span class="marginalizedparent"><a class="marginalized">(1.3)</a></span> <code class="sourceCode cpp"><span class="dt">bool</span><span class="op">(</span>u <span class="op">&lt;</span> t<span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>t <span class="op">&gt;</span> u<span class="op">)</span></code></li>
<li><span class="marginalizedparent"><a class="marginalized">(1.4)</a></span> <code class="sourceCode cpp"><span class="dt">bool</span><span class="op">(</span>t <span class="op">&lt;=</span> u<span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>u <span class="op">&gt;=</span> t<span class="op">)</span></code></li>
<li><span class="marginalizedparent"><a class="marginalized">(1.5)</a></span> <code class="sourceCode cpp"><span class="dt">bool</span><span class="op">(</span>u <span class="op">&lt;=</span> t<span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>t <span class="op">&gt;=</span> u<span class="op">)</span></code></li>
</ul>
<pre><code>template &lt;typename T, typename Cat = partial_ordering&gt;
  concept ThreeWayComparable =
    @_weakly-equality-comparable-with_@&lt;T, T&gt; &amp;&amp;
    (!ConvertibleTo&lt;Cat, partial_ordering&gt; || @_partially-ordered-with_@&lt;T, T&gt;) &amp;&amp;
    requires(const remove_reference_t&lt;T&gt;&amp; a,
             const remove_reference_t&lt;T&gt;&amp; b) {
      { a &lt;=&gt; b } -&gt; @_compares-as_@&lt;Cat&gt;;
    };</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> Let <code class="sourceCode cpp">a</code> and <code class="sourceCode cpp">b</code> be lvalues of type <code class="sourceCode cpp"><span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>T<span class="op">&gt;</span></code>. <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp">Cat</code> model <code class="sourceCode cpp">ThreeWayComparable<span class="op">&lt;</span>T, Cat<span class="op">&gt;</span></code> only if:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(2.1)</a></span> <code class="sourceCode cpp"><span class="op">(</span>a <span class="op">&lt;=&gt;</span> b <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>a <span class="op">==</span> b<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.2)</a></span> <code class="sourceCode cpp"><span class="op">(</span>a <span class="op">&lt;=&gt;</span> b <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>a <span class="op">!=</span> b<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3)</a></span> <code class="sourceCode cpp"><span class="op">((</span>a <span class="op">&lt;=&gt;</span> b<span class="op">)</span> <span class="op">&lt;=&gt;</span> <span class="dv">0</span><span class="op">)</span></code> and <code class="sourceCode cpp"><span class="op">(</span><span class="dv">0</span> <span class="op">&lt;=&gt;</span> <span class="op">(</span>b <span class="op">&lt;=&gt;</span> a<span class="op">))</span></code> are equal</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.4)</a></span> If <code class="sourceCode cpp">Cat</code> is convertible to <code class="sourceCode cpp">strong_equality</code>, <code class="sourceCode cpp">T</code> models <code class="sourceCode cpp">EqualityComparable</code> ([concept.equalitycomparable]).</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.5)</a></span> If <code class="sourceCode cpp">Cat</code> is convertible to <code class="sourceCode cpp">partial_ordering</code>:
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(2.5.1)</a></span> <code class="sourceCode cpp"><span class="op">(</span>a <span class="op">&lt;=&gt;</span> b <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>a <span class="op">&lt;</span> b<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.5.2)</a></span> <code class="sourceCode cpp"><span class="op">(</span>a <span class="op">&lt;=&gt;</span> b <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>a <span class="op">&gt;</span> b<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.5.3)</a></span> <code class="sourceCode cpp"><span class="op">(</span>a <span class="op">&lt;=&gt;</span> b <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>a <span class="op">&lt;=</span> b<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.5.4)</a></span> <code class="sourceCode cpp"><span class="op">(</span>a <span class="op">&lt;=&gt;</span> b <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>a <span class="op">&gt;=</span> b<span class="op">)</span></code>.</li>
</ul></li>
<li><span class="marginalizedparent"><a class="marginalized">(2.5.5)</a></span> If <code class="sourceCode cpp">Cat</code> is convertible to <code class="sourceCode cpp">strong_ordering</code>, <code class="sourceCode cpp">T</code> models <code class="sourceCode cpp">StrictTotallyOrdered</code> ([concept.stricttotallyordered]).</li>
</ul>
<pre><code>template &lt;typename T, typename U,
          typename Cat = partial_ordering&gt;
  concept ThreeWayComparableWith = 
    @_weakly-equality-comparable-with_@&lt;T, U&gt; &amp;&amp;
    (!ConvertibleTo&lt;Cat, partial_ordering&gt; || @_partially-ordered-with_@&lt;T, U&gt;) &amp;&amp;
    ThreeWayComparable&lt;T, Cat&gt; &amp;&amp;
    ThreeWayComparable&lt;U, Cat&gt; &amp;&amp;
    CommonReference&lt;const remove_reference_t&lt;T&gt;&amp;, const remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
    ThreeWayComparable&lt;
      common_reference_t&lt;const remove_reference_t&lt;T&gt;&amp;, const remove_reference_t&lt;U&gt;&amp;&gt;,
      Cat&gt; &amp;&amp;
    requires(const remove_reference_t&lt;T&gt;&amp; t,
             const remove_reference_t&lt;U&gt;&amp; u) {
      { t &lt;=&gt; u } -&gt; @_compares-as_@&lt;Cat&gt;;
      { u &lt;=&gt; t } -&gt; @_compares-as_@&lt;Cat&gt;;
    };</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> Let <code class="sourceCode cpp">t</code> and <code class="sourceCode cpp">u</code> be lvalues of types <code class="sourceCode cpp"><span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp"><span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>U<span class="op">&gt;</span></code>, respectively. Let <code class="sourceCode cpp">C</code> be <code class="sourceCode cpp">common_reference_t<span class="op">&lt;</span><span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span>, <span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>U<span class="op">&gt;&amp;&gt;</span></code>. <code class="sourceCode cpp">T</code>, <code class="sourceCode cpp">U</code>, and <code class="sourceCode cpp">Cat</code> model <code class="sourceCode cpp">ThreeWayComparableWith<span class="op">&lt;</span>T, U, Cat<span class="op">&gt;</span></code> only if:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(3.1)</a></span> <code class="sourceCode cpp">t <span class="op">&lt;=&gt;</span> u</code> and <code class="sourceCode cpp">u <span class="op">&lt;=&gt;</span> t</code> have the same domain.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.2)</a></span> <code class="sourceCode cpp"><span class="op">((</span>t <span class="op">&lt;=&gt;</span> u<span class="op">)</span> <span class="op">&lt;=&gt;</span> <span class="dv">0</span><span class="op">)</span></code> and <code class="sourceCode cpp"><span class="op">(</span><span class="dv">0</span> <span class="op">&lt;=&gt;</span> <span class="op">(</span>u <span class="op">&lt;=&gt;</span> t<span class="op">))</span></code> are equal</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.3)</a></span> <code class="sourceCode cpp"><span class="op">(</span>t <span class="op">&lt;=&gt;</span> u <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>t <span class="op">==</span> u<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.4)</a></span> <code class="sourceCode cpp"><span class="op">(</span>t <span class="op">&lt;=&gt;</span> u <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>t <span class="op">!=</span> u<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.5)</a></span> <code class="sourceCode cpp">Cat<span class="op">(</span>t <span class="op">&lt;=&gt;</span> u<span class="op">)</span> <span class="op">==</span> Cat<span class="op">(</span>C<span class="op">(</span>t<span class="op">)</span> <span class="op">&lt;=&gt;</span> C<span class="op">(</span>u<span class="op">))</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.6)</a></span> If <code class="sourceCode cpp">Cat</code> is convertible to <code class="sourceCode cpp">strong_equality</code>, <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp">U</code> model <code class="sourceCode cpp">EqualityComparableWith<span class="op">&lt;</span>T, U<span class="op">&gt;</span></code> ([concepts.equalitycomparable]).</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.7)</a></span> If <code class="sourceCode cpp">Cat</code> is convertible to <code class="sourceCode cpp">partial_ordering</code>:
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(3.7.1)</a></span> <code class="sourceCode cpp"><span class="op">(</span>t <span class="op">&lt;=&gt;</span> u <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>t <span class="op">&lt;</span> u<span class="op">)</span></code></li>
<li><span class="marginalizedparent"><a class="marginalized">(3.7.2)</a></span> <code class="sourceCode cpp"><span class="op">(</span>t <span class="op">&lt;=&gt;</span> u <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>t <span class="op">&gt;</span> u<span class="op">)</span></code></li>
<li><span class="marginalizedparent"><a class="marginalized">(3.7.3)</a></span> <code class="sourceCode cpp"><span class="op">(</span>t <span class="op">&lt;=&gt;</span> u <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>t <span class="op">&lt;=</span> u<span class="op">)</span></code></li>
<li><span class="marginalizedparent"><a class="marginalized">(3.7.4)</a></span> <code class="sourceCode cpp"><span class="op">(</span>t <span class="op">&lt;=&gt;</span> u <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>t <span class="op">&gt;=</span> u<span class="op">)</span></code></li>
</ul></li>
<li><span class="marginalizedparent"><a class="marginalized">(3.8)</a></span> If <code class="sourceCode cpp">Cat</code> is convertible to <code class="sourceCode cpp">strong_ordering</code>, <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp">U</code> model <code class="sourceCode cpp">StrictTotallyOrderedWith<span class="op">&lt;</span>T, U<span class="op">&gt;</span></code> ([concepts.stricttotallyordered]).</li>
</ul>

</div>
</blockquote>
<p>Add a new subclause [cmp.result] “spaceship invocation result”:</p>
<div class="add" style="color: #006e28">

<blockquote>
<p>The behavior of a program that adds specializations for the <code class="sourceCode cpp">compare_three_way_result</code> template defined in this subclause is undefined.</p>
</blockquote>
<blockquote>
<p>For the <code class="sourceCode cpp">compare_three_way_result</code> type trait applied to the types <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp">U</code>, let <code class="sourceCode cpp">t</code> and <code class="sourceCode cpp">u</code> denote lvalues of types <code class="sourceCode cpp"><span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp"><span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>U<span class="op">&gt;</span></code>, respectively. If the expression <code class="sourceCode cpp">t <span class="op">&lt;=&gt;</span> u</code> is well-formed when treated as an unevaluted operand ([expr.context]), the member <em>typedef-name</em> <code class="sourceCode cpp">type</code> denotes the type <code class="sourceCode cpp"><span class="kw">decltype</span><span class="op">(</span>t <span class="op">&lt;=&gt;</span> u<span class="op">)</span></code>. Otherwise, there is no member <code class="sourceCode cpp">type</code>.</p>
</blockquote>

</div>
<p>Add a new subclause [cmp.object] “spaceship object”:</p>
<div class="add" style="color: #006e28">

<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> In this subclause, <code class="sourceCode cpp">BUILTIN_PTR_3WAY<span class="op">(</span>T, U<span class="op">)</span></code> for types <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp">U</code> is a boolean constant expression. <code class="sourceCode cpp">BUILTIN_PTR_3WAY<span class="op">(</span>T, U<span class="op">)</span></code> is <code class="sourceCode cpp"><span class="kw">true</span></code> if and only if <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> in the expression <code class="sourceCode cpp">declval<span class="op">&lt;</span>T<span class="op">&gt;()</span> <span class="op">&lt;=&gt;</span> declval<span class="op">&lt;</span>U<span class="op">&gt;()</span></code> resolves to a built-in operator comparing pointers.</p>
<pre><code>struct compare_three_way {
  template&lt;class T, class U&gt;
    requires ThreeWayComparableWith&lt;T,U&gt; || BUILTIN_PTR_3WAY(T, U)
  constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const;
  
  using is_transparent = @_unspecified_@;
};</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Expects</em>: If the expression <code class="sourceCode cpp">std<span class="op">::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>t<span class="op">)</span> <span class="op">&lt;=&gt;</span> std<span class="op">::</span>forward<span class="op">&lt;</span>U<span class="op">&gt;(</span>u<span class="op">)</span></code> results in a call to a built-in operator <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> comparing pointers of type <code class="sourceCode cpp">P</code>, the conversion sequences from both <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp">U</code> to <code class="sourceCode cpp">P</code> are equality-preserving ([concepts.equality]).</p>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Effects</em>:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(3.1)</a></span> If the expression <code class="sourceCode cpp">std<span class="op">::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>t<span class="op">)</span> <span class="op">&lt;=&gt;</span> std<span class="op">::</span>forward<span class="op">&lt;</span>U<span class="op">&gt;(</span>u<span class="op">)</span></code> results in a call to a built-in operator <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> comparing pointers of type <code class="sourceCode cpp">P</code>: returns <code class="sourceCode cpp">strong_ordering<span class="op">::</span>less</code> if (the converted value of) <code class="sourceCode cpp">t</code> precedes <code class="sourceCode cpp">u</code> in the implementation-defined strict total order ([range.cmp]) over pointers of type <code class="sourceCode cpp">P</code>, <code class="sourceCode cpp">strong_ordering<span class="op">::</span>greater</code> if <code class="sourceCode cpp">u</code> precedes <code class="sourceCode cpp">t</code>, and otherwise <code class="sourceCode cpp">strong_ordering<span class="op">::</span>equal</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.2)</a></span> Otherwise, equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> std<span class="op">::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>t<span class="op">)</span> <span class="op">&lt;=&gt;</span> std<span class="op">::</span>forward<span class="op">&lt;</span>U<span class="op">&gt;(</span>u<span class="op">)</span>;</code></li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> In addition to being available via inclusion of the <code class="sourceCode cpp"><span class="op">&lt;</span>compare<span class="op">&gt;</span></code> header, the class <code class="sourceCode cpp">compare_three_way</code> is available when the header <code class="sourceCode cpp"><span class="op">&lt;</span>functional<span class="op">&gt;</span></code> is included.</p>
</blockquote>

</div>
<p>Replace the entirety of 17.11.4 [cmp.alg]. This section had the original design for <code class="sourceCode cpp">strong_order<span class="op">()</span></code>, <code class="sourceCode cpp">weak_order<span class="op">()</span></code>, <code class="sourceCode cpp">partial_order<span class="op">()</span></code>, <code class="sourceCode cpp">strong_equal<span class="op">()</span></code>, and <code class="sourceCode cpp">weak_equal<span class="op">()</span></code>. The new wording makes them CPOs.</p>
<blockquote>
<div class="add" style="color: #006e28">
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> The name <code class="sourceCode cpp">strong_order</code> denotes a customization point object ([customization.point.object]). The expression <code class="sourceCode cpp">strong_order<span class="op">(</span>E, F<span class="op">)</span></code> for some subexpressions <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> is expression-equivalent ([defns.expression-equivalent]) to the following:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(1.1)</a></span> If the decayed types of <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> differ, <code class="sourceCode cpp">strong_order<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.2)</a></span> Otherwise, <code class="sourceCode cpp">strong_ordering<span class="op">(</span>strong_order<span class="op">(</span>E, F<span class="op">))</span></code> if it is a well-formed expression with overload resolution performed in a context that does not include a declaration of <code class="sourceCode cpp">std<span class="op">::</span>strong_order</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.3)</a></span> Otherwise, if the decayed type <code class="sourceCode cpp">T</code> of <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> is a floating point type, yields a value of type <code class="sourceCode cpp">strong_ordering</code> that is consistent with the ordering observed by <code class="sourceCode cpp">T</code>’s comparison operators, and if <code class="sourceCode cpp">numeric_limits<span class="op">&lt;</span>T<span class="op">&gt;::</span>is_iec559</code> is <code class="sourceCode cpp"><span class="kw">true</span></code> is additionally consistent with the totalOrder operation as specified in ISO/IEC/IEEE 60599.</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.4)</a></span> Otherwise, <code class="sourceCode cpp">strong_ordering<span class="op">(</span>E <span class="op">&lt;=&gt;</span> F<span class="op">)</span></code> if it is a well-formed expression.</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.5)</a></span> Otherwise, <code class="sourceCode cpp">strong_order<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed. [<em>Note</em>: This case can result in substitution failure when <code class="sourceCode cpp">strong_order<span class="op">(</span>E, F<span class="op">)</span></code> appears in the immediate context of a template instantiation. —<em>end note</em>]</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> The name <code class="sourceCode cpp">weak_order</code> denotes a customization point object ([customization.point.object]). The expression <code class="sourceCode cpp">weak_order<span class="op">(</span>E, F<span class="op">)</span></code> for some subexpressions <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> is expression-equivalent ([defns.expression-equivalent]) to the following:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(2.1)</a></span> If the decayed types of <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> differ, <code class="sourceCode cpp">weak_order<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.2)</a></span> Otherwise, <code class="sourceCode cpp">weak_ordering<span class="op">(</span>weak_order<span class="op">(</span>E, F<span class="op">))</span></code> if it is a well-formed expression with overload resolution performed in a context that does not include a declaration of <code class="sourceCode cpp">std<span class="op">::</span>weak_order</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3)</a></span> Otherwise, if the decayed type <code class="sourceCode cpp">T</code> of <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> is a floating point type, yields a value of type <code class="sourceCode cpp">weak_ordering</code> that is consistent with the ordering observed by <code class="sourceCode cpp">T</code>’s comparison operators and <code class="sourceCode cpp">strong_order</code>, and if <code class="sourceCode cpp">numeric_liits<span class="op">&lt;</span>T<span class="op">&gt;::</span>is_iec559</code> is <code class="sourceCode cpp"><span class="kw">true</span></code> is additionally consistent with the following equivalence classes, ordered from lesser to greater:
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.1)</a></span> Together, all negative NaN values</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.2)</a></span> Negative infinity</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.3)</a></span> Each normal negative value</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.4)</a></span> Each subnormal negative value</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.5)</a></span> Together, both zero values</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.6)</a></span> Each subnormal positive value</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.7)</a></span> Each normal positive value</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.8)</a></span> Positive infinity</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.9)</a></span> Together, all positive NaN values</li>
</ul></li>
<li><span class="marginalizedparent"><a class="marginalized">(2.4)</a></span> Otherwise, <code class="sourceCode cpp">weak_ordering<span class="op">(</span>strong_order<span class="op">(</span>E, F<span class="op">))</span></code> if it is a well-formed expression.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.5)</a></span> Otherwise, <code class="sourceCode cpp">weak_ordering<span class="op">(</span>E <span class="op">&lt;=&gt;</span> F<span class="op">)</span></code> if it is a well-formed expression.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.6)</a></span> Otherwise, <code class="sourceCode cpp">weak_order<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed. [<em>Note</em>: This case can result in substitution failure when <code class="sourceCode cpp">std<span class="op">::</span>weak_order<span class="op">(</span>E, F<span class="op">)</span></code> appears in the immediate context of a template instantiation. —<em>end note</em>]</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> The name <code class="sourceCode cpp">partial_order</code> denotes a customization point object ([customization.point.object]). The expression <code class="sourceCode cpp">partial_order<span class="op">(</span>E, F<span class="op">)</span></code> for some subexpressions <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> is expression-equivalent ([defns.expression-equivalent]) to the following:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(3.1)</a></span> If the decayed types of <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> differ, <code class="sourceCode cpp">partial_order<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.2)</a></span> Otherwise, <code class="sourceCode cpp">partial_ordering<span class="op">(</span>partial_order<span class="op">(</span>E, F<span class="op">))</span></code> if it is a well-formed expression with overload resolution performed in a context that does not include a declaration of <code class="sourceCode cpp">std<span class="op">::</span>partial_order</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.3)</a></span> Otherwise, <code class="sourceCode cpp">partial_ordering<span class="op">(</span>weak_order<span class="op">(</span>E, F<span class="op">))</span></code> if it is a well-formed expression.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.4)</a></span> Otherwise, <code class="sourceCode cpp">partial_ordering<span class="op">(</span>E <span class="op">&lt;=&gt;</span> F<span class="op">)</span></code> if it is a well-formed expression.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.5)</a></span> Otherwise, <code class="sourceCode cpp">partial_order<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed. [<em>Note</em>: This case can result in substitution failure when <code class="sourceCode cpp">std<span class="op">::</span>partial_order<span class="op">(</span>E, F<span class="op">)</span></code> appears in the immediate context of a template instantiation. —<em>end note</em>]</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> The name <code class="sourceCode cpp">compare_strong_order_fallback</code> denotes a comparison customization point ([customization.point.object]) object. The expression <code class="sourceCode cpp">compare_strong_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> for some subexpressions <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> is expression-equivalent ([defns.expression-equivalent]) to:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(4.1)</a></span> If the decayed types of <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> differ, <code class="sourceCode cpp">compare_strong_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized">(4.2)</a></span> Otherwise, <code class="sourceCode cpp">strong_order<span class="op">(</span>E, F<span class="op">)</span></code> if it is a well-formed expression.</li>
<li><span class="marginalizedparent"><a class="marginalized">(4.3)</a></span> Otherwise, if the expressions <code class="sourceCode cpp">E <span class="op">==</span> F</code> and <code class="sourceCode cpp">E <span class="op">&lt;</span> F</code> are each well-formed and convertible to bool, <code class="sourceCode cpp"><span class="op">(</span>E <span class="op">==</span> F<span class="op">)</span> <span class="op">?</span> strong_ordering<span class="op">::</span>equal <span class="op">:</span> <span class="op">((</span>E <span class="op">&lt;</span> F<span class="op">)</span> <span class="op">?</span> strong_ordering<span class="op">::</span>less <span class="op">:</span> strong_ordering<span class="op">::</span>greater</code> except that <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> are only evaluated once.</li>
<li><span class="marginalizedparent"><a class="marginalized">(4.4)</a></span> Otherwise, <code class="sourceCode cpp">compare_strong_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> The name <code class="sourceCode cpp">compare_weak_order_fallback</code> denotes a customization point object ([customization.point.object]). The expression <code class="sourceCode cpp">compare_weak_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> for some subexpressions <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> is expression-equivalent ([defns.expression-equivalent]) to:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(5.1)</a></span> If the decayed types of <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> differ, <code class="sourceCode cpp">compare_weak_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized">(5.2)</a></span> Otherwise, <code class="sourceCode cpp">weak_order<span class="op">(</span>E, F<span class="op">)</span></code> if it is a well-formed expression.</li>
<li><span class="marginalizedparent"><a class="marginalized">(5.3)</a></span> Otherwise, if the expressions <code class="sourceCode cpp">E <span class="op">==</span> F</code> and <code class="sourceCode cpp">E <span class="op">&lt;</span> F</code> are each well-formed and convertible to bool, <code class="sourceCode cpp"><span class="op">(</span>E <span class="op">==</span> F<span class="op">)</span> <span class="op">?</span> weak_ordering<span class="op">::</span>equal <span class="op">:</span> <span class="op">((</span>E <span class="op">&lt;</span> F<span class="op">)</span> <span class="op">?</span> weak_ordering<span class="op">::</span>less <span class="op">:</span> weak_ordering<span class="op">::</span>greater</code> except that <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> are only evaluated once.</li>
<li><span class="marginalizedparent"><a class="marginalized">(5.4)</a></span> Otherwise, <code class="sourceCode cpp">compare_weak_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> The name <code class="sourceCode cpp">compare_partial_order_fallback</code> denotes a customization point object ([customization.point.object]). The expression <code class="sourceCode cpp">compare_partial_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> for some subexpressions <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> is expression-equivalent ([defns.expression-equivalent]) to:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(6.1)</a></span> If the decayed types of <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> differ, <code class="sourceCode cpp">compare_partial_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized">(6.2)</a></span> Otherwise, <code class="sourceCode cpp">partial_order<span class="op">(</span>E, F<span class="op">)</span></code> if it is a well-formed expression.</li>
<li><span class="marginalizedparent"><a class="marginalized">(6.3)</a></span> Otherwise, if the expressions <code class="sourceCode cpp">E <span class="op">==</span> F</code> and <code class="sourceCode cpp">E <span class="op">&lt;</span> F</code> are each well-formed and convertible to bool, <code class="sourceCode cpp"><span class="op">(</span>E <span class="op">==</span> F<span class="op">)</span> <span class="op">?</span> partial_ordering<span class="op">::</span>equivalent <span class="op">:</span> <span class="op">((</span>E <span class="op">&lt;</span> F<span class="op">)</span> <span class="op">?</span> partial_ordering<span class="op">::</span>less <span class="op">:</span> <span class="op">((</span>F <span class="op">&lt;</span> E<span class="op">)</span> <span class="op">?</span> weak_ordering<span class="op">::</span>greater <span class="op">:</span> weak_ordering<span class="op">::</span>unordered<span class="op">))</span></code> except that <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> are only evaluated once.</li>
<li><span class="marginalizedparent"><a class="marginalized">(6.4)</a></span> Otherwise, <code class="sourceCode cpp">compare_partial_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
</ul>

</div>
</blockquote>
<p>Change 17.13.1 [coroutine.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb31"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb31-1"><a href="#cb31-1"></a>namespace std {</span>
<span id="cb31-2"><a href="#cb31-2"></a>  [...]</span>
<span id="cb31-3"><a href="#cb31-3"></a>  // 17.13.5 noop coroutine</span>
<span id="cb31-4"><a href="#cb31-4"></a>  noop_coroutine_handle noop_coroutine() noexcept;</span>
<span id="cb31-5"><a href="#cb31-5"></a></span>
<span id="cb31-6"><a href="#cb31-6"></a>  // 17.13.3.6 comparison operators:</span>
<span id="cb31-7"><a href="#cb31-7"></a>  constexpr bool operator==(coroutine_handle&lt;&gt; x, coroutine_handle&lt;&gt; y) noexcept;</span>
<span id="cb31-8"><a href="#cb31-8"></a><span class="st">- constexpr bool operator!=(coroutine_handle&lt;&gt; x, coroutine_handle&lt;&gt; y) noexcept;</span></span>
<span id="cb31-9"><a href="#cb31-9"></a><span class="st">- constexpr bool operator&lt;(coroutine_handle&lt;&gt; x, coroutine_handle&lt;&gt; y) noexcept;</span></span>
<span id="cb31-10"><a href="#cb31-10"></a><span class="st">- constexpr bool operator&gt;(coroutine_handle&lt;&gt; x, coroutine_handle&lt;&gt; y) noexcept;</span></span>
<span id="cb31-11"><a href="#cb31-11"></a><span class="st">- constexpr bool operator&lt;=(coroutine_handle&lt;&gt; x, coroutine_handle&lt;&gt; y) noexcept;</span></span>
<span id="cb31-12"><a href="#cb31-12"></a><span class="st">- constexpr bool operator&gt;=(coroutine_handle&lt;&gt; x, coroutine_handle&lt;&gt; y) noexcept;</span></span>
<span id="cb31-13"><a href="#cb31-13"></a><span class="va">+ constexpr strong_ordering operator&lt;=&gt;(coroutine_handle x, coroutine_handle y) noexcept;</span></span>
<span id="cb31-14"><a href="#cb31-14"></a></span>
<span id="cb31-15"><a href="#cb31-15"></a>  // 17.13.6 trivial awaitables</span>
<span id="cb31-16"><a href="#cb31-16"></a>  [...]</span>
<span id="cb31-17"><a href="#cb31-17"></a>}</span></code></pre></div>
</blockquote>
<p>Replace the <code class="sourceCode cpp"><span class="op">&lt;</span></code> in 17.13.3.6 [coroutine.handle.compare] with the new <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code>:</p>
<blockquote>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>coroutine_handle<span class="op">&lt;&gt;</span> x, coroutine_handle<span class="op">&lt;&gt;</span> y<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Returns</em>: <code class="sourceCode cpp">x<span class="op">.</span>address<span class="op">()</span> <span class="op">==</span> y<span class="op">.</span>address<span class="op">()</span></code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>constexpr bool operator&lt;(coroutine_handle&lt;&gt; x, coroutine_handle&lt;&gt; y) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp">less<span class="op">&lt;&gt;()(</span>x<span class="op">.</span>address<span class="op">()</span>, y<span class="op">.</span>address<span class="op">())</span></code>.</p>
</div>
<div class="addu">
<pre><code>constexpr strong_ordering operator&lt;=&gt;(coroutine_handle x, coroutine_handle y) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: <code class="sourceCode cpp">compare_three_way<span class="op">()(</span>x<span class="op">.</span>address<span class="op">()</span>, y<span class="op">.</span>address<span class="op">())</span></code>.</p>
</div>
</blockquote>
<h2 id="clause-18-concepts-library"><span class="header-section-number">5.3</span> Clause 18: Concepts Library<a href="#clause-18-concepts-library" class="self-link"></a></h2>
<p>No changes.</p>
<h2 id="clause-19-diagnostics-library"><span class="header-section-number">5.4</span> Clause 19: Diagnostics Library<a href="#clause-19-diagnostics-library" class="self-link"></a></h2>
<p>Changed operators for: <code class="sourceCode cpp">error_category</code>, <code class="sourceCode cpp">error_code</code>, and <code class="sourceCode cpp">error_condition</code></p>
<p>Change 19.5.1 [system.error.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb35"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb35-1"><a href="#cb35-1"></a>namespace std {</span>
<span id="cb35-2"><a href="#cb35-2"></a>  [...]</span>
<span id="cb35-3"><a href="#cb35-3"></a>  // [syserr.compare], comparison functions</span>
<span id="cb35-4"><a href="#cb35-4"></a>  bool operator==(const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</span>
<span id="cb35-5"><a href="#cb35-5"></a>  bool operator==(const error_code&amp; lhs, const error_condition&amp; rhs) noexcept;</span>
<span id="cb35-6"><a href="#cb35-6"></a><span class="st">- bool operator==(const error_condition&amp; lhs, const error_code&amp; rhs) noexcept;</span></span>
<span id="cb35-7"><a href="#cb35-7"></a>  bool operator==(const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</span>
<span id="cb35-8"><a href="#cb35-8"></a><span class="st">- bool operator!=(const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</span></span>
<span id="cb35-9"><a href="#cb35-9"></a><span class="st">- bool operator!=(const error_code&amp; lhs, const error_condition&amp; rhs) noexcept;</span></span>
<span id="cb35-10"><a href="#cb35-10"></a><span class="st">- bool operator!=(const error_condition&amp; lhs, const error_code&amp; rhs) noexcept;</span></span>
<span id="cb35-11"><a href="#cb35-11"></a><span class="st">- bool operator!=(const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</span></span>
<span id="cb35-12"><a href="#cb35-12"></a><span class="st">- bool operator&lt; (const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</span></span>
<span id="cb35-13"><a href="#cb35-13"></a><span class="st">- bool operator&lt; (const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</span></span>
<span id="cb35-14"><a href="#cb35-14"></a><span class="va">+ strong_ordering operator&lt;=&gt;(const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</span></span>
<span id="cb35-15"><a href="#cb35-15"></a><span class="va">+ strong_ordering operator&lt;=&gt;(const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</span></span>
<span id="cb35-16"><a href="#cb35-16"></a>  [...]  </span>
<span id="cb35-17"><a href="#cb35-17"></a>}</span></code></pre></div>
</blockquote>
<p>Change 19.5.2.1 [syserr.errcat.overview]:</p>
<blockquote>
<div class="sourceCode" id="cb36"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb36-1"><a href="#cb36-1"></a>namespace std {</span>
<span id="cb36-2"><a href="#cb36-2"></a>  class error_category {</span>
<span id="cb36-3"><a href="#cb36-3"></a>  public:</span>
<span id="cb36-4"><a href="#cb36-4"></a>    [...]</span>
<span id="cb36-5"><a href="#cb36-5"></a></span>
<span id="cb36-6"><a href="#cb36-6"></a>    bool operator==(const error_category&amp; rhs) const noexcept;</span>
<span id="cb36-7"><a href="#cb36-7"></a><span class="st">-   bool operator!=(const error_category&amp; rhs) const noexcept;</span></span>
<span id="cb36-8"><a href="#cb36-8"></a><span class="st">-   bool operator&lt; (const error_category&amp; rhs) const noexcept;</span></span>
<span id="cb36-9"><a href="#cb36-9"></a><span class="va">+   strong_ordering operator&lt;=&gt;(const error_category&amp; rhs) const noexcept;</span></span>
<span id="cb36-10"><a href="#cb36-10"></a>  };</span>
<span id="cb36-11"><a href="#cb36-11"></a></span>
<span id="cb36-12"><a href="#cb36-12"></a>  const error_category&amp; generic_category() noexcept;</span>
<span id="cb36-13"><a href="#cb36-13"></a>  const error_category&amp; system_category() noexcept;</span>
<span id="cb36-14"><a href="#cb36-14"></a>}</span></code></pre></div>
</blockquote>
<p>Change 19.5.2.3 [syserr.errcat.nonvirtuals]:</p>
<blockquote>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> error_category<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="kw">this</span> <span class="op">==</span> <span class="op">&amp;</span>rhs</code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>bool operator!=(const error_category&amp; rhs) const noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(*</span><span class="kw">this</span> <span class="op">==</span> rhs<span class="op">)</span></code>.</p>
<pre><code>bool operator&lt;(const error_category&amp; rhs) const noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: <code class="sourceCode cpp">less<span class="op">&lt;</span><span class="kw">const</span> error_category<span class="op">*&gt;()(</span><span class="kw">this</span>, <span class="op">&amp;</span>rhs<span class="op">)</span></code>.</p>
</div>
<div class="addu">
<pre><code>strong_ordering operator&lt;=&gt;(const error_category&amp; rhs) const noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: <code class="sourceCode cpp">compare_three_way<span class="op">()(</span><span class="kw">this</span>, <span class="op">&amp;</span>rhs<span class="op">)</span></code>.</p>
</div>
<p>[<em>Note</em>: <span class="rm" style="color: #bf0303"><del><span><code class="sourceCode cpp">less</code></span></del></span> <span class="addu"><code class="sourceCode cpp">compare_three_way</code> ([cmp.object])</span> provides a total ordering for pointers. —<em>end note</em>]</p>
</blockquote>
<p>Change 19.5.5 [syserr.compare]:</p>
<blockquote>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> error_code<span class="op">&amp;</span> lhs, <span class="kw">const</span> error_code<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>category<span class="op">()</span> <span class="op">==</span> rhs<span class="op">.</span>category<span class="op">()</span> <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>value<span class="op">()</span> <span class="op">==</span> rhs<span class="op">.</span>value<span class="op">()</span></code></p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> error_code<span class="op">&amp;</span> lhs, <span class="kw">const</span> error_condition<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>category<span class="op">().</span>equivalent<span class="op">(</span>lhs<span class="op">.</span>value<span class="op">()</span>, rhs<span class="op">)</span> <span class="op">||</span> rhs<span class="op">.</span>category<span class="op">().</span>equivalent<span class="op">(</span>lhs, rhs<span class="op">.</span>value<span class="op">())</span></code></p>
<div class="rm" style="color: #bf0303">

<pre><code>bool operator==(const error_condition&amp; lhs, const error_code&amp; rhs) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: <code class="sourceCode cpp">rhs<span class="op">.</span>category<span class="op">().</span>equivalent<span class="op">(</span>rhs<span class="op">.</span>value<span class="op">()</span>, lhs<span class="op">)</span> <span class="op">||</span> lhs<span class="op">.</span>category<span class="op">().</span>equivalent<span class="op">(</span>rhs, lhs<span class="op">.</span>value<span class="op">())</span></code></p>
</div>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> error_condition<span class="op">&amp;</span> lhs, <span class="kw">const</span> error_condition<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>category<span class="op">()</span> <span class="op">==</span> rhs<span class="op">.</span>category<span class="op">()</span> <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>value<span class="op">()</span> <span class="op">==</span> rhs<span class="op">.</span>value<span class="op">()</span></code></p>
<div class="rm" style="color: #bf0303">

<pre><code>bool operator!=(const error_code&amp; lhs, const error_code&amp; rhs) noexcept;
bool operator!=(const error_code&amp; lhs, const error_condition&amp; rhs) noexcept;
bool operator!=(const error_condition&amp; lhs, const error_code&amp; rhs) noexcept;
bool operator!=(const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">)</span></code>.</p>
<pre><code>bool operator&lt;(const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>category<span class="op">()</span> <span class="op">&lt;</span> rhs<span class="op">.</span>category<span class="op">()</span> <span class="op">||</span> <span class="op">(</span>lhs<span class="op">.</span>category<span class="op">()</span> <span class="op">==</span> rhs<span class="op">.</span>category<span class="op">()</span> <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>value<span class="op">()</span> <span class="op">&lt;</span> rhs<span class="op">.</span>value<span class="op">())</span></code></p>
<pre><code>bool operator&lt;(const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>category<span class="op">()</span> <span class="op">&lt;</span> rhs<span class="op">.</span>category<span class="op">()</span> <span class="op">||</span> <span class="op">(</span>lhs<span class="op">.</span>category<span class="op">()</span> <span class="op">==</span> rhs<span class="op">.</span>category<span class="op">()</span> <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>value<span class="op">()</span> <span class="op">&lt;</span> rhs<span class="op">.</span>value<span class="op">())</span></code></p>
</div>
<div class="addu">
<pre><code>strong_ordering operator&lt;=&gt;(const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">8</a></span> <em>Effects</em>: Equivalent to:</p>
<blockquote>
<pre><code>if (auto c = lhs.category() &lt;=&gt; rhs.category(); c != 0) return c;
return lhs.value() &lt;=&gt; rhs.value();</code></pre>
</blockquote>
<pre><code>strong_ordering operator&lt;=&gt;(const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">9</a></span> <em>Effects</em>: Equivalent to:</p>
<blockquote>
<pre><code>if (auto c = lhs.category() &lt;=&gt; rhs.category(); c != 0) return c;
return lhs.value() &lt;=&gt; rhs.value();</code></pre>
</blockquote>
</div>
</blockquote>
<h2 id="clause-20-general-utilities-library"><span class="header-section-number">5.5</span> Clause 20: General utilities library<a href="#clause-20-general-utilities-library" class="self-link"></a></h2>
<p>Changed operators for: <code class="sourceCode cpp">pair</code>, <code class="sourceCode cpp">tuple</code>, <code class="sourceCode cpp">optional</code>, <code class="sourceCode cpp">variant</code>, <code class="sourceCode cpp">monostate</code>, <code class="sourceCode cpp">bitset</code>, <code class="sourceCode cpp">allocator</code>, <code class="sourceCode cpp">unique_ptr</code>, <code class="sourceCode cpp">shared_ptr</code>, <code class="sourceCode cpp">memory_resource</code> <code class="sourceCode cpp">polymorphic_allocator</code>, <code class="sourceCode cpp">scoped_allocator_adaptor</code>, <code class="sourceCode cpp">function</code>, <code class="sourceCode cpp">type_index</code>.</p>
<p>Change 20.2.1 [utility.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb52"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb52-1"><a href="#cb52-1"></a>#include &lt;initializer_list&gt;     // see [initializer.list.syn]</span>
<span id="cb52-2"><a href="#cb52-2"></a></span>
<span id="cb52-3"><a href="#cb52-3"></a>namespace std {</span>
<span id="cb52-4"><a href="#cb52-4"></a>  [...]</span>
<span id="cb52-5"><a href="#cb52-5"></a></span>
<span id="cb52-6"><a href="#cb52-6"></a>  // [pairs], class template pair</span>
<span id="cb52-7"><a href="#cb52-7"></a>  template&lt;class T1, class T2&gt;</span>
<span id="cb52-8"><a href="#cb52-8"></a>    struct pair;</span>
<span id="cb52-9"><a href="#cb52-9"></a>  </span>
<span id="cb52-10"><a href="#cb52-10"></a><span class="st">- // [pairs.spec], pair specialized algorithms</span></span>
<span id="cb52-11"><a href="#cb52-11"></a><span class="st">- template&lt;class T1, class T2&gt;</span></span>
<span id="cb52-12"><a href="#cb52-12"></a><span class="st">-   constexpr bool operator==(const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);</span></span>
<span id="cb52-13"><a href="#cb52-13"></a><span class="st">- template&lt;class T1, class T2&gt;</span></span>
<span id="cb52-14"><a href="#cb52-14"></a><span class="st">-   constexpr bool operator!=(const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);</span></span>
<span id="cb52-15"><a href="#cb52-15"></a><span class="st">- template&lt;class T1, class T2&gt;</span></span>
<span id="cb52-16"><a href="#cb52-16"></a><span class="st">-   constexpr bool operator&lt; (const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);</span></span>
<span id="cb52-17"><a href="#cb52-17"></a><span class="st">- template&lt;class T1, class T2&gt;</span></span>
<span id="cb52-18"><a href="#cb52-18"></a><span class="st">-   constexpr bool operator&gt; (const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);</span></span>
<span id="cb52-19"><a href="#cb52-19"></a><span class="st">- template&lt;class T1, class T2&gt;</span></span>
<span id="cb52-20"><a href="#cb52-20"></a><span class="st">-   constexpr bool operator&lt;=(const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);</span></span>
<span id="cb52-21"><a href="#cb52-21"></a><span class="st">- template&lt;class T1, class T2&gt;</span></span>
<span id="cb52-22"><a href="#cb52-22"></a><span class="st">-   constexpr bool operator&gt;=(const pair&lt;T1, T2&gt;&amp;, const pair&lt;T1, T2&gt;&amp;);  </span></span>
<span id="cb52-23"><a href="#cb52-23"></a></span>
<span id="cb52-24"><a href="#cb52-24"></a>  template&lt;class T1, class T2&gt;</span>
<span id="cb52-25"><a href="#cb52-25"></a>    constexpr void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp; y) noexcept(noexcept(x.swap(y)));</span>
<span id="cb52-26"><a href="#cb52-26"></a></span>
<span id="cb52-27"><a href="#cb52-27"></a>  template&lt;class T1, class T2&gt;</span>
<span id="cb52-28"><a href="#cb52-28"></a>    constexpr @_see below_@ make_pair(T1&amp;&amp;, T2&amp;&amp;);</span>
<span id="cb52-29"><a href="#cb52-29"></a>}</span></code></pre></div>
</blockquote>
<p>Change 20.4.2 [pairs.pair]:</p>
<blockquote>
<div class="sourceCode" id="cb53"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb53-1"><a href="#cb53-1"></a>namespace std {</span>
<span id="cb53-2"><a href="#cb53-2"></a>  template&lt;class T1, class T2&gt;</span>
<span id="cb53-3"><a href="#cb53-3"></a>  struct pair {</span>
<span id="cb53-4"><a href="#cb53-4"></a>    using first_type  = T1;</span>
<span id="cb53-5"><a href="#cb53-5"></a>    using second_type = T2;</span>
<span id="cb53-6"><a href="#cb53-6"></a></span>
<span id="cb53-7"><a href="#cb53-7"></a>    T1 first;</span>
<span id="cb53-8"><a href="#cb53-8"></a>    T2 second;</span>
<span id="cb53-9"><a href="#cb53-9"></a></span>
<span id="cb53-10"><a href="#cb53-10"></a>    [...]</span>
<span id="cb53-11"><a href="#cb53-11"></a></span>
<span id="cb53-12"><a href="#cb53-12"></a>    constexpr void swap(pair&amp; p) noexcept(@_see below_@);</span>
<span id="cb53-13"><a href="#cb53-13"></a>    </span>
<span id="cb53-14"><a href="#cb53-14"></a><span class="va">+   // 20.4.3, pair specialized algorithms</span></span>
<span id="cb53-15"><a href="#cb53-15"></a><span class="va">+   friend constexpr bool operator==(const pair&amp;, const pair&amp;) = default;</span></span>
<span id="cb53-16"><a href="#cb53-16"></a><span class="va">+   friend constexpr common_comparison_category_t&lt;@_synth-3way-result_@&lt;T1&gt;, @_synth-3way-result_@&lt;T2&gt;&gt;</span></span>
<span id="cb53-17"><a href="#cb53-17"></a><span class="va">+     operator&lt;=&gt;(const pair&amp;, const pair&amp;)</span></span>
<span id="cb53-18"><a href="#cb53-18"></a><span class="va">+     { @_see below_@ }</span></span>
<span id="cb53-19"><a href="#cb53-19"></a>  };</span>
<span id="cb53-20"><a href="#cb53-20"></a></span>
<span id="cb53-21"><a href="#cb53-21"></a>  template&lt;class T1, class T2&gt;</span>
<span id="cb53-22"><a href="#cb53-22"></a>    pair(T1, T2) -&gt; pair&lt;T1, T2&gt;;</span>
<span id="cb53-23"><a href="#cb53-23"></a>}</span></code></pre></div>
</blockquote>
<p>Change 20.4.3 [pairs.spec]:</p>
<blockquote>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class T1, class T2&gt;
  constexpr bool operator==(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Returns</em>: <code class="sourceCode cpp">x<span class="op">.</span>first <span class="op">==</span> y<span class="op">.</span>first <span class="op">&amp;&amp;</span> x<span class="op">.</span>second <span class="op">==</span> y<span class="op">.</span>second</code>.</p>
<pre><code>template&lt;class T1, class T2&gt;
  constexpr bool operator!=(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span></code>.</p>
<pre><code>template&lt;class T1, class T2&gt;
  constexpr bool operator&lt;(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: <code class="sourceCode cpp">x<span class="op">.</span>first <span class="op">&lt;</span> y<span class="op">.</span>first <span class="op">||</span> <span class="op">(!(</span>y<span class="op">.</span>first <span class="op">&lt;</span> x<span class="op">.</span>first<span class="op">)</span> <span class="op">&amp;&amp;</span> x<span class="op">.</span>second <span class="op">&lt;</span> y<span class="op">.</span>second<span class="op">)</span></code>.</p>
<pre><code>template&lt;class T1, class T2&gt;
  constexpr bool operator&gt;(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: <code class="sourceCode cpp">y <span class="op">&lt;</span> x</code>.</p>
<pre><code>template&lt;class T1, class T2&gt;
  constexpr bool operator&lt;=(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(</span>y <span class="op">&lt;</span> x<span class="op">)</span></code>.</p>
<pre><code>template&lt;class T1, class T2&gt;
  constexpr bool operator&gt;=(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(</span>x <span class="op">&lt;</span> y<span class="op">)</span></code>.</p>
</div>
<div class="addu">
<pre><code>friend constexpr common_comparison_category_t&lt;@_synth-3way-result_@&lt;T1&gt;, @_synth-3way-result_@&lt;T2&gt;&gt;
  operator&lt;=&gt;(const pair&amp;, const pair&amp;);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Effects</em>: Equivalent to:</p>
<blockquote>
<pre><code>if (auto c = @_synth-3way_@(lhs.first, rhs.first); c != 0) return c;
return @_synth-3way_@(lhs.second, rhs.second);</code></pre>
</blockquote>
</div>
</blockquote>
<p>Change 20.5.3 [tuple.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb62"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb62-1"><a href="#cb62-1"></a>namespace std {</span>
<span id="cb62-2"><a href="#cb62-2"></a>  // [tuple.tuple], class template tuple</span>
<span id="cb62-3"><a href="#cb62-3"></a>  template&lt;class... Types&gt;</span>
<span id="cb62-4"><a href="#cb62-4"></a>    class tuple;</span>
<span id="cb62-5"><a href="#cb62-5"></a></span>
<span id="cb62-6"><a href="#cb62-6"></a>  [...]</span>
<span id="cb62-7"><a href="#cb62-7"></a>  </span>
<span id="cb62-8"><a href="#cb62-8"></a>  // [tuple.rel], relational operators</span>
<span id="cb62-9"><a href="#cb62-9"></a>  template&lt;class... TTypes, class... UTypes&gt;</span>
<span id="cb62-10"><a href="#cb62-10"></a>    constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);</span>
<span id="cb62-11"><a href="#cb62-11"></a><span class="st">- template&lt;class... TTypes, class... UTypes&gt;</span></span>
<span id="cb62-12"><a href="#cb62-12"></a><span class="st">-   constexpr bool operator!=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);</span></span>
<span id="cb62-13"><a href="#cb62-13"></a><span class="st">- template&lt;class... TTypes, class... UTypes&gt;</span></span>
<span id="cb62-14"><a href="#cb62-14"></a><span class="st">-   constexpr bool operator&lt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);</span></span>
<span id="cb62-15"><a href="#cb62-15"></a><span class="st">- template&lt;class... TTypes, class... UTypes&gt;</span></span>
<span id="cb62-16"><a href="#cb62-16"></a><span class="st">-   constexpr bool operator&gt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);</span></span>
<span id="cb62-17"><a href="#cb62-17"></a><span class="st">- template&lt;class... TTypes, class... UTypes&gt;</span></span>
<span id="cb62-18"><a href="#cb62-18"></a><span class="st">-   constexpr bool operator&lt;=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);</span></span>
<span id="cb62-19"><a href="#cb62-19"></a><span class="st">- template&lt;class... TTypes, class... UTypes&gt;</span></span>
<span id="cb62-20"><a href="#cb62-20"></a><span class="st">-   constexpr bool operator&gt;=(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);</span></span>
<span id="cb62-21"><a href="#cb62-21"></a><span class="va">+ template&lt;class... TTypes, class... UTypes&gt;</span></span>
<span id="cb62-22"><a href="#cb62-22"></a><span class="va">+   constexpr common_comparison_category_t&lt;@_synth-3way-result_@&lt;TTypes, UTypes&gt;...&gt;</span></span>
<span id="cb62-23"><a href="#cb62-23"></a><span class="va">+     operator&lt;=&gt;(const tuple&lt;TTypes...&gt;&amp;, const tuple&lt;UTypes...&gt;&amp;);</span></span>
<span id="cb62-24"><a href="#cb62-24"></a></span>
<span id="cb62-25"><a href="#cb62-25"></a>  [...]</span>
<span id="cb62-26"><a href="#cb62-26"></a>}  </span></code></pre></div>
</blockquote>
<p>Change 20.5.3.8 [tuple.rel]:</p>
<blockquote>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> TTypes, <span class="kw">class</span><span class="op">...</span> UTypes<span class="op">&gt;</span></span>
<span id="cb63-2"><a href="#cb63-2"></a>  <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> tuple<span class="op">&lt;</span>TTypes<span class="op">...&gt;&amp;</span> t, <span class="kw">const</span> tuple<span class="op">&lt;</span>UTypes<span class="op">...&gt;&amp;</span> u<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Requires</em>: For all <code class="sourceCode cpp">i</code>, where <code class="sourceCode cpp"><span class="dv">0</span> <span class="op">&lt;=</span> i</code> and <code class="sourceCode cpp">i <span class="op">&lt;</span> <span class="kw">sizeof</span><span class="op">...(</span>TTypes<span class="op">)</span></code>, <code class="sourceCode cpp">get<span class="op">&lt;</span>i<span class="op">&gt;(</span>t<span class="op">)</span> <span class="op">==</span> get<span class="op">&lt;</span>i<span class="op">&gt;(</span>u<span class="op">)</span></code> is a valid expression returning a type that is convertible to <code class="sourceCode cpp"><span class="dt">bool</span></code>. <code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">...(</span>TTypes<span class="op">)</span> <span class="op">==</span> <span class="kw">sizeof</span><span class="op">...(</span>UTypes<span class="op">)</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="kw">true</span></code> if <code class="sourceCode cpp">get<span class="op">&lt;</span>i<span class="op">&gt;(</span>t<span class="op">)</span> <span class="op">==</span> get<span class="op">&lt;</span>i<span class="op">&gt;(</span>u<span class="op">)</span></code> for all <code class="sourceCode cpp">i</code>, otherwise <code class="sourceCode cpp"><span class="kw">false</span></code>. For any two zero-length tuples <code class="sourceCode cpp">e</code> and <code class="sourceCode cpp">f</code>, <code class="sourceCode cpp">e <span class="op">==</span> f</code> returns <code class="sourceCode cpp"><span class="kw">true</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Effects</em>: The elementary comparisons are performed in order from the zeroth index upwards. No comparisons or element accesses are performed after the first equality comparison that evaluates to <code class="sourceCode cpp"><span class="kw">false</span></code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class... TTypes, class... UTypes&gt;
  constexpr bool operator!=(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(</span>t <span class="op">==</span> u<span class="op">)</span></code>.</p>
<pre><code>template&lt;class... TTypes, class... UTypes&gt;
  constexpr bool operator&lt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Requires</em>: For all <code class="sourceCode cpp">i</code>, where <code class="sourceCode cpp"><span class="dv">0</span> <span class="op">&lt;=</span> i</code> and <code class="sourceCode cpp">i <span class="op">&lt;</span> <span class="kw">sizeof</span><span class="op">...(</span>TTypes<span class="op">)</span></code>, both <code class="sourceCode cpp">get<span class="op">&lt;</span>i<span class="op">&gt;(</span>t<span class="op">)</span> <span class="op">&lt;</span> get<span class="op">&lt;</span>i<span class="op">&gt;(</span>u<span class="op">)</span></code> and <code class="sourceCode cpp">get<span class="op">&lt;</span>i<span class="op">&gt;(</span>u<span class="op">)</span> <span class="op">&lt;</span> get<span class="op">&lt;</span>i<span class="op">&gt;(</span>t<span class="op">)</span></code> are valid expressions returning types that are convertible to <code class="sourceCode cpp"><span class="dt">bool</span></code>. <code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">...(</span>TTypes<span class="op">)</span> <span class="op">==</span> <span class="kw">sizeof</span><span class="op">...(</span>UTypes<span class="op">)</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Returns</em>: The result of a lexicographical comparison between <code class="sourceCode cpp">t</code> and <code class="sourceCode cpp">u</code>. The result is defined as: <code class="sourceCode cpp"><span class="op">(</span><span class="dt">bool</span><span class="op">)(</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>t<span class="op">)</span> <span class="op">&lt;</span> get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>u<span class="op">))</span> <span class="op">||</span> <span class="op">(!(</span><span class="dt">bool</span><span class="op">)(</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>u<span class="op">)</span> <span class="op">&lt;</span> get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>t<span class="op">))</span> <span class="op">&amp;&amp;</span></code><code>t<sub>tail</sub> &lt; u<sub>tail</sub></code><code class="sourceCode cpp"><span class="op">)</span></code>, where <code>r<sub>tail</sub></code> for some tuple <code class="sourceCode cpp">r</code> is a tuple containing all but the first element of <code class="sourceCode cpp">r</code>. For any two zero-length tuples <code class="sourceCode cpp">e</code> and <code class="sourceCode cpp">f</code>, <code class="sourceCode cpp">e <span class="op">&lt;</span> f</code> returns <code class="sourceCode cpp"><span class="kw">false</span></code>.</p>
<pre><code>template&lt;class... TTypes, class... UTypes&gt;
  constexpr bool operator&gt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Returns</em>: <code class="sourceCode cpp">u <span class="op">&lt;</span> t</code>.</p>
<pre><code>template&lt;class... TTypes, class... UTypes&gt;
  constexpr bool operator&lt;=(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">8</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(</span>u <span class="op">&lt;</span> t<span class="op">)</span></code>.</p>
<pre><code>template&lt;class... TTypes, class... UTypes&gt;
  constexpr bool operator&gt;=(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">9</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(</span>t <span class="op">&lt;</span> u<span class="op">)</span></code>.</p>
</div>
<div class="addu">
<pre><code>template&lt;class... TTypes, class... UTypes&gt;
  constexpr common_comparison_category_t&lt;@_synth-3way-result_@&lt;TTypes, UTypes&gt;...&gt;
    operator&lt;=&gt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">10</a></span> <em>Requires</em>: For all <code class="sourceCode cpp">i</code>, where <code class="sourceCode cpp"><span class="dv">0</span> <span class="op">&lt;=</span> i</code> and <code class="sourceCode cpp">i <span class="op">&lt;</span> <span class="kw">sizeof</span><span class="op">...(</span>TTypes<span class="op">)</span></code>, both <code><em>synth-3way</em></code><code class="sourceCode cpp"><span class="op">(</span>get<span class="op">&lt;</span>i<span class="op">&gt;(</span>t<span class="op">)</span>, get<span class="op">&lt;</span>i<span class="op">&gt;(</span>u<span class="op">))</span></code> is a valid expression. <code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">...(</span>TTypes<span class="op">)</span> <span class="op">==</span> <span class="kw">sizeof</span><span class="op">...(</span>UTypes<span class="op">)</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">11</a></span> <em>Effects</em>: Performs a lexicographical comparison between <code class="sourceCode cpp">t</code> and <code class="sourceCode cpp">u</code>. For any two zero-length tuples <code class="sourceCode cpp">t</code> and <code class="sourceCode cpp">u</code>, <code class="sourceCode cpp">t <span class="op">&lt;=&gt;</span> u</code> returns <code class="sourceCode cpp">strong_ordering<span class="op">::</span>equal</code>. Otherwise, equivalent to:</p>
<blockquote>
<pre><code>auto c = @_synth-3way_@(get&lt;0&gt;(t), get&lt;0&gt;(u));
return (c != 0) ? c : (t@~tail~@ &lt;=&gt; u@~tail~@);</code></pre>
</blockquote>
<p>where <code>r<sub>tail</sub></code> for some tuple <code class="sourceCode cpp">r</code> is a tuple containing all but the first element of <code class="sourceCode cpp">r</code>.</p>
</div>
<p><span class="marginalizedparent"><a class="marginalized">12</a></span> [<em>Note</em>: The above <span class="rm" style="color: #bf0303"><del>definitions for comparison functions do not require</del></span> <span class="addu">definition does not require</span> <code>t<sub>tail</sub></code> (or <code>u<sub>tail</sub></code>) to be constructed. It may not even be possible, as <code class="sourceCode cpp">t</code> and <code class="sourceCode cpp">u</code> are not required to be copy constructible. Also, all comparison functions are short circuited; they do not perform element accesses beyond what is required to determine the result of the comparison. —<em>end note</em>]</p>
</blockquote>
<p>Change 20.6.2 [optional.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb71"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb71-1"><a href="#cb71-1"></a>namespace std {</span>
<span id="cb71-2"><a href="#cb71-2"></a>  // [optional.optional], class template optional</span>
<span id="cb71-3"><a href="#cb71-3"></a>  template&lt;class T&gt;</span>
<span id="cb71-4"><a href="#cb71-4"></a>    class optional;</span>
<span id="cb71-5"><a href="#cb71-5"></a></span>
<span id="cb71-6"><a href="#cb71-6"></a>  // [optional.nullopt], no-value state indicator</span>
<span id="cb71-7"><a href="#cb71-7"></a>  struct nullopt_t{see below};</span>
<span id="cb71-8"><a href="#cb71-8"></a>  inline constexpr nullopt_t nullopt(unspecified);</span>
<span id="cb71-9"><a href="#cb71-9"></a></span>
<span id="cb71-10"><a href="#cb71-10"></a>  // [optional.bad.access], class bad_optional_access</span>
<span id="cb71-11"><a href="#cb71-11"></a>  class bad_optional_access;</span>
<span id="cb71-12"><a href="#cb71-12"></a></span>
<span id="cb71-13"><a href="#cb71-13"></a>  // [optional.relops], relational operators</span>
<span id="cb71-14"><a href="#cb71-14"></a>  template&lt;class T, class U&gt;</span>
<span id="cb71-15"><a href="#cb71-15"></a>    constexpr bool operator==(const optional&lt;T&gt;&amp;, const optional&lt;U&gt;&amp;);</span>
<span id="cb71-16"><a href="#cb71-16"></a>  template&lt;class T, class U&gt;</span>
<span id="cb71-17"><a href="#cb71-17"></a>    constexpr bool operator!=(const optional&lt;T&gt;&amp;, const optional&lt;U&gt;&amp;);</span>
<span id="cb71-18"><a href="#cb71-18"></a>  template&lt;class T, class U&gt;</span>
<span id="cb71-19"><a href="#cb71-19"></a>    constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, const optional&lt;U&gt;&amp;);</span>
<span id="cb71-20"><a href="#cb71-20"></a>  template&lt;class T, class U&gt;</span>
<span id="cb71-21"><a href="#cb71-21"></a>    constexpr bool operator&gt;(const optional&lt;T&gt;&amp;, const optional&lt;U&gt;&amp;);</span>
<span id="cb71-22"><a href="#cb71-22"></a>  template&lt;class T, class U&gt;</span>
<span id="cb71-23"><a href="#cb71-23"></a>    constexpr bool operator&lt;=(const optional&lt;T&gt;&amp;, const optional&lt;U&gt;&amp;);</span>
<span id="cb71-24"><a href="#cb71-24"></a>  template&lt;class T, class U&gt;</span>
<span id="cb71-25"><a href="#cb71-25"></a>    constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, const optional&lt;U&gt;&amp;);</span>
<span id="cb71-26"><a href="#cb71-26"></a><span class="va">+ template&lt;class T, ThreeWayComparableWith&lt;T&gt; U&gt;</span></span>
<span id="cb71-27"><a href="#cb71-27"></a><span class="va">+   constexpr compare_three_way_result_t&lt;T,U&gt;</span></span>
<span id="cb71-28"><a href="#cb71-28"></a><span class="va">+     operator&lt;=&gt;(const optional&lt;T&gt;&amp;, const optional&lt;U&gt;&amp;);</span></span>
<span id="cb71-29"><a href="#cb71-29"></a></span>
<span id="cb71-30"><a href="#cb71-30"></a>  // [optional.nullops], comparison with nullopt</span>
<span id="cb71-31"><a href="#cb71-31"></a>  template&lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;</span>
<span id="cb71-32"><a href="#cb71-32"></a><span class="st">- template&lt;class T&gt; constexpr bool operator==(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;</span></span>
<span id="cb71-33"><a href="#cb71-33"></a><span class="st">- template&lt;class T&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;</span></span>
<span id="cb71-34"><a href="#cb71-34"></a><span class="st">- template&lt;class T&gt; constexpr bool operator!=(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;</span></span>
<span id="cb71-35"><a href="#cb71-35"></a><span class="st">- template&lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;</span></span>
<span id="cb71-36"><a href="#cb71-36"></a><span class="st">- template&lt;class T&gt; constexpr bool operator&lt;(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;</span></span>
<span id="cb71-37"><a href="#cb71-37"></a><span class="st">- template&lt;class T&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;</span></span>
<span id="cb71-38"><a href="#cb71-38"></a><span class="st">- template&lt;class T&gt; constexpr bool operator&gt;(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;</span></span>
<span id="cb71-39"><a href="#cb71-39"></a><span class="st">- template&lt;class T&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;</span></span>
<span id="cb71-40"><a href="#cb71-40"></a><span class="st">- template&lt;class T&gt; constexpr bool operator&lt;=(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;</span></span>
<span id="cb71-41"><a href="#cb71-41"></a><span class="st">- template&lt;class T&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;</span></span>
<span id="cb71-42"><a href="#cb71-42"></a><span class="st">- template&lt;class T&gt; constexpr bool operator&gt;=(nullopt_t, const optional&lt;T&gt;&amp;) noexcept;</span></span>
<span id="cb71-43"><a href="#cb71-43"></a><span class="va">+ template&lt;class T&gt; constexpr strong_ordering operator&lt;=&gt;(const optional&lt;T&gt;&amp;, nullopt_t) noexcept;</span></span>
<span id="cb71-44"><a href="#cb71-44"></a></span>
<span id="cb71-45"><a href="#cb71-45"></a>  // [optional.comp.with.t], comparison with T</span>
<span id="cb71-46"><a href="#cb71-46"></a>  template&lt;class T, class U&gt; constexpr bool operator==(const optional&lt;T&gt;&amp;, const U&amp;);</span>
<span id="cb71-47"><a href="#cb71-47"></a>  template&lt;class T, class U&gt; constexpr bool operator==(const T&amp;, const optional&lt;U&gt;&amp;);</span>
<span id="cb71-48"><a href="#cb71-48"></a>  template&lt;class T, class U&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp;, const U&amp;);</span>
<span id="cb71-49"><a href="#cb71-49"></a>  template&lt;class T, class U&gt; constexpr bool operator!=(const T&amp;, const optional&lt;U&gt;&amp;);</span>
<span id="cb71-50"><a href="#cb71-50"></a>  template&lt;class T, class U&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp;, const U&amp;);</span>
<span id="cb71-51"><a href="#cb71-51"></a>  template&lt;class T, class U&gt; constexpr bool operator&lt;(const T&amp;, const optional&lt;U&gt;&amp;);</span>
<span id="cb71-52"><a href="#cb71-52"></a>  template&lt;class T, class U&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp;, const U&amp;);</span>
<span id="cb71-53"><a href="#cb71-53"></a>  template&lt;class T, class U&gt; constexpr bool operator&gt;(const T&amp;, const optional&lt;U&gt;&amp;);</span>
<span id="cb71-54"><a href="#cb71-54"></a>  template&lt;class T, class U&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp;, const U&amp;);</span>
<span id="cb71-55"><a href="#cb71-55"></a>  template&lt;class T, class U&gt; constexpr bool operator&lt;=(const T&amp;, const optional&lt;U&gt;&amp;);</span>
<span id="cb71-56"><a href="#cb71-56"></a>  template&lt;class T, class U&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp;, const U&amp;);</span>
<span id="cb71-57"><a href="#cb71-57"></a>  template&lt;class T, class U&gt; constexpr bool operator&gt;=(const T&amp;, const optional&lt;U&gt;&amp;);</span>
<span id="cb71-58"><a href="#cb71-58"></a><span class="va">+ template&lt;class T, ThreeWayComparableWith&lt;T&gt; U&gt;</span></span>
<span id="cb71-59"><a href="#cb71-59"></a><span class="va">+   constexpr compare_three_way_result_t&lt;T,U&gt;</span></span>
<span id="cb71-60"><a href="#cb71-60"></a><span class="va">+     operator&lt;=&gt;(const optional&lt;T&gt;&amp;, const U&amp;);</span></span>
<span id="cb71-61"><a href="#cb71-61"></a></span>
<span id="cb71-62"><a href="#cb71-62"></a>  // [optional.specalg], specialized algorithms</span>
<span id="cb71-63"><a href="#cb71-63"></a>  template&lt;class T&gt;</span>
<span id="cb71-64"><a href="#cb71-64"></a>    void swap(optional&lt;T&gt;&amp;, optional&lt;T&gt;&amp;) noexcept(@_see below_@);</span>
<span id="cb71-65"><a href="#cb71-65"></a>    </span>
<span id="cb71-66"><a href="#cb71-66"></a>  [...]</span>
<span id="cb71-67"><a href="#cb71-67"></a>}</span></code></pre></div>
</blockquote>
<p>Add to 20.6.6 [optional.relops]:</p>
<blockquote>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> U<span class="op">&gt;</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><span class="kw">const</span> optional<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> x, <span class="kw">const</span> optional<span class="op">&lt;</span>U<span class="op">&gt;&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">16</a></span> <em>Requires</em>: The expression <code class="sourceCode cpp"><span class="op">*</span>x <span class="op">&gt;=</span> <span class="op">*</span>y</code> shall be well-formed and its result shall be convertible to <code class="sourceCode cpp"><span class="dt">bool</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">17</a></span> <em>Returns</em>: If <code class="sourceCode cpp"><span class="op">!</span>y</code>, <code class="sourceCode cpp"><span class="kw">true</span></code>; otherwise, if <code class="sourceCode cpp"><span class="op">!</span>x</code>, <code class="sourceCode cpp"><span class="kw">false</span></code>; otherwise <code class="sourceCode cpp"><span class="op">*</span>x <span class="op">&gt;=</span> <span class="op">*</span>y</code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">18</a></span> <em>Remarks</em>: Specializations of this function template for which <code class="sourceCode cpp"><span class="op">*</span>x <span class="op">&gt;=</span> <span class="op">*</span>y</code> is a core constant expression shall be constexpr functions.</p>
<div class="addu">
<pre><code>template&lt;class T, ThreeWayComparableWith&lt;T&gt; U&gt;
  constexpr compare_three_way_result_t&lt;T,U&gt;
    operator&lt;=&gt;(const optional&lt;T&gt;&amp; x, const optional&lt;U&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">19</a></span> <em>Returns</em>: If <code class="sourceCode cpp">x <span class="op">&amp;&amp;</span> y</code>, <code class="sourceCode cpp"><span class="op">*</span>x <span class="op">&lt;=&gt;</span> <span class="op">*</span>y</code>; otherwise <code class="sourceCode cpp"><span class="dt">bool</span><span class="op">(</span>x<span class="op">)</span> <span class="op">&lt;=&gt;</span> <span class="dt">bool</span><span class="op">(</span>y<span class="op">)</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">20</a></span> <em>Remarks</em>: Specializations of this function template for which <code class="sourceCode cpp"><span class="op">*</span>x <span class="op">&lt;=&gt;</span> <span class="op">*</span>y</code> is a core constant expression shall be constexpr functions.</p>
</div>
</blockquote>
<p>Change 20.6.7 [optional.nullops], removing most of the comparisons:</p>
<blockquote>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> optional<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> x, nullopt_t<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb74-2"><a href="#cb74-2"></a>@[template&lt;class T&gt; constexpr bool operator==(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept;]{.rm}@</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!</span>x</code>.</p>
<div class="addu">
<pre><code>template&lt;class T&gt; constexpr strong_ordering operator&lt;=&gt;(const optional&lt;T&gt;&amp; x, nullopt_t) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="dt">bool</span><span class="op">(</span>x<span class="op">)</span> <span class="op">&lt;=&gt;</span> <span class="kw">false</span></code>.</p>
</div>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class T&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp; x, nullopt_t) noexcept;
template&lt;class T&gt; constexpr bool operator!=(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="dt">bool</span><span class="op">(</span>x<span class="op">)</span></code>.</p>
<pre><code>template&lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; x, nullopt_t) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="kw">false</span></code>.</p>
<pre><code>template&lt;class T&gt; constexpr bool operator&lt;(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="dt">bool</span><span class="op">(</span>x<span class="op">)</span></code>.</p>
<pre><code>template&lt;class T&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp; x, nullopt_t) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="dt">bool</span><span class="op">(</span>x<span class="op">)</span></code>.</p>
<pre><code>template&lt;class T&gt; constexpr bool operator&gt;(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="kw">false</span></code>.</p>
<pre><code>template&lt;class T&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; x, nullopt_t) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!</span>x</code>.</p>
<pre><code>template&lt;class T&gt; constexpr bool operator&lt;=(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">8</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="kw">true</span></code>.</p>
<pre><code>template&lt;class T&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; x, nullopt_t) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">9</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="kw">true</span></code>.</p>
<pre><code>template&lt;class T&gt; constexpr bool operator&gt;=(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">10</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!</span>x</code>.</p>
</div>
</blockquote>
<p>Add to 20.6.8 [optional.comp.with.t]:</p>
<blockquote>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> U<span class="op">&gt;</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><span class="kw">const</span> T<span class="op">&amp;</span> v, <span class="kw">const</span> optional<span class="op">&lt;</span>U<span class="op">&gt;&amp;</span> x<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">23</a></span> <em>Requires</em>: The expression <code class="sourceCode cpp">v <span class="op">&gt;=</span> <span class="op">*</span>x</code> shall be well-formed and its result shall be convertible to <code class="sourceCode cpp"><span class="dt">bool</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">24</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="dt">bool</span><span class="op">(</span>x<span class="op">)</span> <span class="op">?</span> v <span class="op">&gt;=</span> <span class="op">*</span>x <span class="op">:</span> <span class="kw">true</span>;</code></p>
<div class="addu">
<pre><code>template&lt;class T, ThreeWayComparableWith&lt;T&gt; U&gt;
  constexpr compare_three_way_result_t&lt;T,U&gt;
    operator&lt;=&gt;(const optional&lt;T&gt;&amp; x, const U&amp; v);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">25</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="dt">bool</span><span class="op">(</span>x<span class="op">)</span> <span class="op">?</span> <span class="op">*</span>x <span class="op">&lt;=&gt;</span> v <span class="op">:</span> strong_ordering<span class="op">::</span>less;</code></p>
</div>
</blockquote>
<p>Change 20.7.2 [variant.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb87"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb87-1"><a href="#cb87-1"></a>namespace std {</span>
<span id="cb87-2"><a href="#cb87-2"></a>  // [variant.variant], class template variant</span>
<span id="cb87-3"><a href="#cb87-3"></a>  template&lt;class... Types&gt;</span>
<span id="cb87-4"><a href="#cb87-4"></a>    class variant;</span>
<span id="cb87-5"><a href="#cb87-5"></a></span>
<span id="cb87-6"><a href="#cb87-6"></a>  [...]</span>
<span id="cb87-7"><a href="#cb87-7"></a>  </span>
<span id="cb87-8"><a href="#cb87-8"></a>  // [variant.relops], relational operators</span>
<span id="cb87-9"><a href="#cb87-9"></a>  template&lt;class... Types&gt;</span>
<span id="cb87-10"><a href="#cb87-10"></a>    constexpr bool operator==(const variant&lt;Types...&gt;&amp;, const variant&lt;Types...&gt;&amp;);</span>
<span id="cb87-11"><a href="#cb87-11"></a>  template&lt;class... Types&gt;</span>
<span id="cb87-12"><a href="#cb87-12"></a>    constexpr bool operator!=(const variant&lt;Types...&gt;&amp;, const variant&lt;Types...&gt;&amp;);</span>
<span id="cb87-13"><a href="#cb87-13"></a>  template&lt;class... Types&gt;</span>
<span id="cb87-14"><a href="#cb87-14"></a>    constexpr bool operator&lt;(const variant&lt;Types...&gt;&amp;, const variant&lt;Types...&gt;&amp;);</span>
<span id="cb87-15"><a href="#cb87-15"></a>  template&lt;class... Types&gt;</span>
<span id="cb87-16"><a href="#cb87-16"></a>    constexpr bool operator&gt;(const variant&lt;Types...&gt;&amp;, const variant&lt;Types...&gt;&amp;);</span>
<span id="cb87-17"><a href="#cb87-17"></a>  template&lt;class... Types&gt;</span>
<span id="cb87-18"><a href="#cb87-18"></a>    constexpr bool operator&lt;=(const variant&lt;Types...&gt;&amp;, const variant&lt;Types...&gt;&amp;);</span>
<span id="cb87-19"><a href="#cb87-19"></a>  template&lt;class... Types&gt;</span>
<span id="cb87-20"><a href="#cb87-20"></a>    constexpr bool operator&gt;=(const variant&lt;Types...&gt;&amp;, const variant&lt;Types...&gt;&amp;);</span>
<span id="cb87-21"><a href="#cb87-21"></a><span class="va">+ template&lt;class... Types&gt; requires (ThreeWayComparable&lt;Types&gt; &amp;&amp; ...)  </span></span>
<span id="cb87-22"><a href="#cb87-22"></a><span class="va">+   constexpr common_comparison_category_t&lt;compare_three_way_result_t&lt;Types&gt;...&gt;</span></span>
<span id="cb87-23"><a href="#cb87-23"></a><span class="va">+     operator&lt;=&gt;(const variant&lt;Types...&gt;&amp;, const variant&lt;Types...&gt;&amp;);</span></span>
<span id="cb87-24"><a href="#cb87-24"></a>  </span>
<span id="cb87-25"><a href="#cb87-25"></a>  // [variant.visit], visitation</span>
<span id="cb87-26"><a href="#cb87-26"></a>  template&lt;class Visitor, class... Variants&gt;</span>
<span id="cb87-27"><a href="#cb87-27"></a>    constexpr see below visit(Visitor&amp;&amp;, Variants&amp;&amp;...);</span>
<span id="cb87-28"><a href="#cb87-28"></a>  template&lt;class R, class Visitor, class... Variants&gt;</span>
<span id="cb87-29"><a href="#cb87-29"></a>    constexpr R visit(Visitor&amp;&amp;, Variants&amp;&amp;...);</span>
<span id="cb87-30"><a href="#cb87-30"></a></span>
<span id="cb87-31"><a href="#cb87-31"></a>  // [variant.monostate], class monostate</span>
<span id="cb87-32"><a href="#cb87-32"></a>  struct monostate;</span>
<span id="cb87-33"><a href="#cb87-33"></a></span>
<span id="cb87-34"><a href="#cb87-34"></a>  // [variant.monostate.relops], monostate relational operators</span>
<span id="cb87-35"><a href="#cb87-35"></a>  constexpr bool operator==(monostate, monostate) noexcept;</span>
<span id="cb87-36"><a href="#cb87-36"></a><span class="st">- constexpr bool operator!=(monostate, monostate) noexcept;</span></span>
<span id="cb87-37"><a href="#cb87-37"></a><span class="st">- constexpr bool operator&lt;(monostate, monostate) noexcept;</span></span>
<span id="cb87-38"><a href="#cb87-38"></a><span class="st">- constexpr bool operator&gt;(monostate, monostate) noexcept;</span></span>
<span id="cb87-39"><a href="#cb87-39"></a><span class="st">- constexpr bool operator&lt;=(monostate, monostate) noexcept;</span></span>
<span id="cb87-40"><a href="#cb87-40"></a><span class="st">- constexpr bool operator&gt;=(monostate, monostate) noexcept;</span></span>
<span id="cb87-41"><a href="#cb87-41"></a><span class="va">+ constexpr strong_ordering operator&lt;=&gt;(monostate, monostate) noexcept;</span></span>
<span id="cb87-42"><a href="#cb87-42"></a>    </span>
<span id="cb87-43"><a href="#cb87-43"></a>  [...]</span>
<span id="cb87-44"><a href="#cb87-44"></a>}</span></code></pre></div>
</blockquote>
<p>Add to 20.7.6 [variant.relops]:</p>
<blockquote>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Types<span class="op">&gt;</span></span>
<span id="cb88-2"><a href="#cb88-2"></a>  <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><span class="kw">const</span> variant<span class="op">&lt;</span>Types<span class="op">...&gt;&amp;</span> v, <span class="kw">const</span> variant<span class="op">&lt;</span>Types<span class="op">...&gt;&amp;</span> w<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">11</a></span> <em>Requires</em>: <code class="sourceCode cpp">get<span class="op">&lt;</span>i<span class="op">&gt;(</span>v<span class="op">)</span> <span class="op">&gt;=</span> get<span class="op">&lt;</span>i<span class="op">&gt;(</span>w<span class="op">)</span></code> is a valid expression returning a type that is convertible to <code class="sourceCode cpp"><span class="dt">bool</span></code>, for all <code class="sourceCode cpp">i</code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">12</a></span> <em>Returns</em>: If <code class="sourceCode cpp">w<span class="op">.</span>valueless_by_exception<span class="op">()</span></code>, <code class="sourceCode cpp"><span class="kw">true</span></code>; otherwise if <code class="sourceCode cpp">v<span class="op">.</span>valueless_by_exception<span class="op">()</span></code>, <code class="sourceCode cpp"><span class="kw">false</span></code>; otherwise, if <code class="sourceCode cpp">v<span class="op">.</span>index<span class="op">()</span> <span class="op">&gt;</span> w<span class="op">.</span>index<span class="op">()</span></code>, <code class="sourceCode cpp"><span class="kw">true</span></code>; otherwise if <code class="sourceCode cpp">v<span class="op">.</span>index<span class="op">()</span> <span class="op">&lt;</span> w<span class="op">.</span>index<span class="op">()</span></code>, <code class="sourceCode cpp"><span class="kw">false</span></code>; otherwise <code class="sourceCode cpp">get<span class="op">&lt;</span>i<span class="op">&gt;(</span>v<span class="op">)</span> <span class="op">&gt;=</span> get<span class="op">&lt;</span>i<span class="op">&gt;(</span>w<span class="op">)</span></code> with <code class="sourceCode cpp">i</code> being <code class="sourceCode cpp">v<span class="op">.</span>index<span class="op">()</span></code>.</p>
<div class="addu">
<pre><code>template&lt;class... Types&gt; requires (ThreeWayComparable&lt;Types&gt; &amp;&amp; ...)  
  constexpr common_comparison_category_t&lt;compare_three_way_result_t&lt;Types&gt;...&gt;
    operator&lt;=&gt;(const variant&lt;Types...&gt;&amp; v, const variant&lt;Types...&gt;&amp; w);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">13</a></span> <em>Returns</em>: Let <code class="sourceCode cpp">c</code> be <code class="sourceCode cpp"><span class="op">(</span>v<span class="op">.</span>index<span class="op">()</span> <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">&lt;=&gt;</span> <span class="op">(</span>w<span class="op">.</span>index<span class="op">()</span> <span class="op">+</span> <span class="dv">1</span><span class="op">)</span></code>. If <code class="sourceCode cpp">c <span class="op">!=</span> <span class="dv">0</span></code>, <code class="sourceCode cpp">c</code>. Otherwise, <code class="sourceCode cpp">get<span class="op">&lt;</span>i<span class="op">&gt;(</span>v<span class="op">)</span> <span class="op">&lt;=&gt;</span> get<span class="op">&lt;</span>i<span class="op">&gt;(</span>w<span class="op">)</span></code> with <code class="sourceCode cpp">i</code> being <code class="sourceCode cpp">v<span class="op">.</span>index<span class="op">()</span></code>.</p>
</div>
</blockquote>
<p>Simplify 20.7.9 [variant.monostate.relops]:</p>
<blockquote>
<div class="sourceCode" id="cb90"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>monostate, monostate<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span> <span class="cf">return</span> <span class="kw">true</span>; <span class="op">}</span></span></code></pre></div>
<div class="rm" style="color: #bf0303">

<pre><code>constexpr bool operator!=(monostate, monostate) noexcept { return false; }
constexpr bool operator&lt;(monostate, monostate) noexcept { return false; }
constexpr bool operator&gt;(monostate, monostate) noexcept { return false; }
constexpr bool operator&lt;=(monostate, monostate) noexcept { return true; }
constexpr bool operator&gt;=(monostate, monostate) noexcept { return true; }</code></pre>

</div>
<div class="addu">
<pre><code>constexpr strong_ordering operator&lt;=&gt;(monostate, monostate) noexcept { return strong_ordering::equal; }</code></pre>
</div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> [<em>Note</em>: monostate objects have only a single state; they thus always compare equal. —<em>end note</em>]</p>
</blockquote>
<p>Change 20.9.2 [template.bitset]:</p>
<blockquote>
<div class="sourceCode" id="cb93"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb93-1"><a href="#cb93-1"></a>namespace std {</span>
<span id="cb93-2"><a href="#cb93-2"></a>  template&lt;size_t N&gt; class bitset {</span>
<span id="cb93-3"><a href="#cb93-3"></a>  public:</span>
<span id="cb93-4"><a href="#cb93-4"></a>    [...]</span>
<span id="cb93-5"><a href="#cb93-5"></a>    size_t count() const noexcept;</span>
<span id="cb93-6"><a href="#cb93-6"></a>    constexpr size_t size() const noexcept;</span>
<span id="cb93-7"><a href="#cb93-7"></a>    bool operator==(const bitset&lt;N&gt;&amp; rhs) const noexcept;</span>
<span id="cb93-8"><a href="#cb93-8"></a><span class="st">-   bool operator!=(const bitset&lt;N&gt;&amp; rhs) const noexcept;</span></span>
<span id="cb93-9"><a href="#cb93-9"></a>    bool test(size_t pos) const;</span>
<span id="cb93-10"><a href="#cb93-10"></a>    [...]   </span>
<span id="cb93-11"><a href="#cb93-11"></a>  };</span>
<span id="cb93-12"><a href="#cb93-12"></a>}</span></code></pre></div>
</blockquote>
<p>Change 20.9.2.2 [bitset.members]:</p>
<blockquote>
<div class="sourceCode" id="cb94"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> bitset<span class="op">&lt;</span>N<span class="op">&gt;&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">36</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="kw">true</span></code> if the value of each bit in <code class="sourceCode cpp"><span class="op">*</span><span class="kw">this</span></code> equals the value of the corresponding bit in <code class="sourceCode cpp">rhs</code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>bool operator!=(const bitset&lt;N&gt;&amp; rhs) const noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">37</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="kw">true</span></code> if <code class="sourceCode cpp"><span class="op">!(*</span><span class="kw">this</span> <span class="op">==</span> rhs<span class="op">)</span></code>.</p>
</div>
</blockquote>
<p>Change 20.10.2 [memory.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb96"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb96-1"><a href="#cb96-1"></a>namespace std{</span>
<span id="cb96-2"><a href="#cb96-2"></a>  [...]</span>
<span id="cb96-3"><a href="#cb96-3"></a></span>
<span id="cb96-4"><a href="#cb96-4"></a>  // [default.allocator], the default allocator</span>
<span id="cb96-5"><a href="#cb96-5"></a>  template&lt;class T&gt; class allocator;</span>
<span id="cb96-6"><a href="#cb96-6"></a>  template&lt;class T, class U&gt;</span>
<span id="cb96-7"><a href="#cb96-7"></a>    bool operator==(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;</span>
<span id="cb96-8"><a href="#cb96-8"></a><span class="st">- template&lt;class T, class U&gt;</span></span>
<span id="cb96-9"><a href="#cb96-9"></a><span class="st">-   bool operator!=(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;  </span></span>
<span id="cb96-10"><a href="#cb96-10"></a></span>
<span id="cb96-11"><a href="#cb96-11"></a>  [...]</span>
<span id="cb96-12"><a href="#cb96-12"></a>  </span>
<span id="cb96-13"><a href="#cb96-13"></a>  // [unique.ptr], class template unique_ptr</span>
<span id="cb96-14"><a href="#cb96-14"></a>  [...]</span>
<span id="cb96-15"><a href="#cb96-15"></a>  template&lt;class T, class D&gt;</span>
<span id="cb96-16"><a href="#cb96-16"></a>    void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y) noexcept;</span>
<span id="cb96-17"><a href="#cb96-17"></a></span>
<span id="cb96-18"><a href="#cb96-18"></a>  template&lt;class T1, class D1, class T2, class D2&gt;</span>
<span id="cb96-19"><a href="#cb96-19"></a>    bool operator==(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</span>
<span id="cb96-20"><a href="#cb96-20"></a><span class="st">- template&lt;class T1, class D1, class T2, class D2&gt;</span></span>
<span id="cb96-21"><a href="#cb96-21"></a><span class="st">-   bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</span></span>
<span id="cb96-22"><a href="#cb96-22"></a>  template&lt;class T1, class D1, class T2, class D2&gt;</span>
<span id="cb96-23"><a href="#cb96-23"></a>    bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</span>
<span id="cb96-24"><a href="#cb96-24"></a>  template&lt;class T1, class D1, class T2, class D2&gt;</span>
<span id="cb96-25"><a href="#cb96-25"></a>    bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</span>
<span id="cb96-26"><a href="#cb96-26"></a>  template&lt;class T1, class D1, class T2, class D2&gt;</span>
<span id="cb96-27"><a href="#cb96-27"></a>    bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</span>
<span id="cb96-28"><a href="#cb96-28"></a>  template&lt;class T1, class D1, class T2, class D2&gt;</span>
<span id="cb96-29"><a href="#cb96-29"></a>    bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</span>
<span id="cb96-30"><a href="#cb96-30"></a><span class="va">+ template&lt;class T1, class D1, class T2, class D2&gt;</span></span>
<span id="cb96-31"><a href="#cb96-31"></a><span class="va">+     requires ThreeWayComparableWith&lt;typename unique_ptr&lt;T1, D1&gt;::pointer,</span></span>
<span id="cb96-32"><a href="#cb96-32"></a><span class="va">+                                     typename unique_ptr&lt;T2, D2&gt;::pointer&gt;</span></span>
<span id="cb96-33"><a href="#cb96-33"></a><span class="va">+   compare_three_way_result_t&lt;typename unique_ptr&lt;T1, D1&gt;::pointer, typename unique_ptr&lt;T2, D2&gt;::pointer&gt;</span></span>
<span id="cb96-34"><a href="#cb96-34"></a><span class="va">+     operator&lt;=&gt;(const unique_ptr&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</span></span>
<span id="cb96-35"><a href="#cb96-35"></a></span>
<span id="cb96-36"><a href="#cb96-36"></a>  template&lt;class T, class D&gt;</span>
<span id="cb96-37"><a href="#cb96-37"></a>    bool operator==(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;</span>
<span id="cb96-38"><a href="#cb96-38"></a><span class="st">- template&lt;class T, class D&gt;</span></span>
<span id="cb96-39"><a href="#cb96-39"></a><span class="st">-   bool operator==(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y) noexcept;</span></span>
<span id="cb96-40"><a href="#cb96-40"></a><span class="st">- template&lt;class T, class D&gt;</span></span>
<span id="cb96-41"><a href="#cb96-41"></a><span class="st">-   bool operator!=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;</span></span>
<span id="cb96-42"><a href="#cb96-42"></a><span class="st">- template&lt;class T, class D&gt;</span></span>
<span id="cb96-43"><a href="#cb96-43"></a><span class="st">-   bool operator!=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y) noexcept;</span></span>
<span id="cb96-44"><a href="#cb96-44"></a>  template&lt;class T, class D&gt;</span>
<span id="cb96-45"><a href="#cb96-45"></a>    bool operator&lt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</span>
<span id="cb96-46"><a href="#cb96-46"></a>  template&lt;class T, class D&gt;</span>
<span id="cb96-47"><a href="#cb96-47"></a>    bool operator&lt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);</span>
<span id="cb96-48"><a href="#cb96-48"></a>  template&lt;class T, class D&gt;</span>
<span id="cb96-49"><a href="#cb96-49"></a>    bool operator&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</span>
<span id="cb96-50"><a href="#cb96-50"></a>  template&lt;class T, class D&gt;</span>
<span id="cb96-51"><a href="#cb96-51"></a>    bool operator&gt;(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);</span>
<span id="cb96-52"><a href="#cb96-52"></a>  template&lt;class T, class D&gt;</span>
<span id="cb96-53"><a href="#cb96-53"></a>    bool operator&lt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</span>
<span id="cb96-54"><a href="#cb96-54"></a>  template&lt;class T, class D&gt;</span>
<span id="cb96-55"><a href="#cb96-55"></a>    bool operator&lt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);</span>
<span id="cb96-56"><a href="#cb96-56"></a>  template&lt;class T, class D&gt;</span>
<span id="cb96-57"><a href="#cb96-57"></a>    bool operator&gt;=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</span>
<span id="cb96-58"><a href="#cb96-58"></a>  template&lt;class T, class D&gt;</span>
<span id="cb96-59"><a href="#cb96-59"></a>    bool operator&gt;=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; y);</span>
<span id="cb96-60"><a href="#cb96-60"></a><span class="va">+ template&lt;class T, class D&gt;</span></span>
<span id="cb96-61"><a href="#cb96-61"></a><span class="va">+     requires ThreeWayComparableWith&lt;typename unique_ptr&lt;T, D&gt;::pointer, nullptr_t&gt;</span></span>
<span id="cb96-62"><a href="#cb96-62"></a><span class="va">+   compare_three_way_result_t&lt;typename unique_ptr&lt;T, D&gt;::pointer, nullptr_t&gt;</span></span>
<span id="cb96-63"><a href="#cb96-63"></a><span class="va">+     operator&lt;=&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</span></span>
<span id="cb96-64"><a href="#cb96-64"></a></span>
<span id="cb96-65"><a href="#cb96-65"></a>  template&lt;class E, class T, class Y, class D&gt;</span>
<span id="cb96-66"><a href="#cb96-66"></a>    basic_ostream&lt;E, T&gt;&amp; operator&lt;&lt;(basic_ostream&lt;E, T&gt;&amp; os, const unique_ptr&lt;Y, D&gt;&amp; p);  </span>
<span id="cb96-67"><a href="#cb96-67"></a>    </span>
<span id="cb96-68"><a href="#cb96-68"></a>  [...]</span>
<span id="cb96-69"><a href="#cb96-69"></a></span>
<span id="cb96-70"><a href="#cb96-70"></a></span>
<span id="cb96-71"><a href="#cb96-71"></a>  // [util.smartptr.shared.cmp], shared_ptr comparisons</span>
<span id="cb96-72"><a href="#cb96-72"></a>  template&lt;class T, class U&gt;</span>
<span id="cb96-73"><a href="#cb96-73"></a>    bool operator==(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;</span>
<span id="cb96-74"><a href="#cb96-74"></a><span class="st">- template&lt;class T, class U&gt;</span></span>
<span id="cb96-75"><a href="#cb96-75"></a><span class="st">-   bool operator!=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;</span></span>
<span id="cb96-76"><a href="#cb96-76"></a><span class="st">- template&lt;class T, class U&gt;</span></span>
<span id="cb96-77"><a href="#cb96-77"></a><span class="st">-   bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;</span></span>
<span id="cb96-78"><a href="#cb96-78"></a><span class="st">- template&lt;class T, class U&gt;</span></span>
<span id="cb96-79"><a href="#cb96-79"></a><span class="st">-   bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;</span></span>
<span id="cb96-80"><a href="#cb96-80"></a><span class="st">- template&lt;class T, class U&gt;</span></span>
<span id="cb96-81"><a href="#cb96-81"></a><span class="st">-   bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;</span></span>
<span id="cb96-82"><a href="#cb96-82"></a><span class="st">- template&lt;class T, class U&gt;</span></span>
<span id="cb96-83"><a href="#cb96-83"></a><span class="st">-   bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;</span></span>
<span id="cb96-84"><a href="#cb96-84"></a><span class="va">+ template&lt;class T, class U&gt;</span></span>
<span id="cb96-85"><a href="#cb96-85"></a><span class="va">+   strong_ordering operator&lt;=&gt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;</span></span>
<span id="cb96-86"><a href="#cb96-86"></a></span>
<span id="cb96-87"><a href="#cb96-87"></a>  template&lt;class T&gt;</span>
<span id="cb96-88"><a href="#cb96-88"></a>    bool operator==(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;</span>
<span id="cb96-89"><a href="#cb96-89"></a><span class="st">- template&lt;class T&gt;</span></span>
<span id="cb96-90"><a href="#cb96-90"></a><span class="st">-   bool operator==(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;</span></span>
<span id="cb96-91"><a href="#cb96-91"></a><span class="st">- template&lt;class T&gt;</span></span>
<span id="cb96-92"><a href="#cb96-92"></a><span class="st">-   bool operator!=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;</span></span>
<span id="cb96-93"><a href="#cb96-93"></a><span class="st">- template&lt;class T&gt;</span></span>
<span id="cb96-94"><a href="#cb96-94"></a><span class="st">-   bool operator!=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;</span></span>
<span id="cb96-95"><a href="#cb96-95"></a><span class="st">- template&lt;class T&gt;</span></span>
<span id="cb96-96"><a href="#cb96-96"></a><span class="st">-   bool operator&lt;(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;</span></span>
<span id="cb96-97"><a href="#cb96-97"></a><span class="st">- template&lt;class T&gt;</span></span>
<span id="cb96-98"><a href="#cb96-98"></a><span class="st">-   bool operator&lt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;</span></span>
<span id="cb96-99"><a href="#cb96-99"></a><span class="st">- template&lt;class T&gt;</span></span>
<span id="cb96-100"><a href="#cb96-100"></a><span class="st">-   bool operator&gt;(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;</span></span>
<span id="cb96-101"><a href="#cb96-101"></a><span class="st">- template&lt;class T&gt;</span></span>
<span id="cb96-102"><a href="#cb96-102"></a><span class="st">-   bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;</span></span>
<span id="cb96-103"><a href="#cb96-103"></a><span class="st">- template&lt;class T&gt;</span></span>
<span id="cb96-104"><a href="#cb96-104"></a><span class="st">-   bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;</span></span>
<span id="cb96-105"><a href="#cb96-105"></a><span class="st">- template&lt;class T&gt;</span></span>
<span id="cb96-106"><a href="#cb96-106"></a><span class="st">-   bool operator&lt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;</span></span>
<span id="cb96-107"><a href="#cb96-107"></a><span class="st">- template&lt;class T&gt;</span></span>
<span id="cb96-108"><a href="#cb96-108"></a><span class="st">-   bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;</span></span>
<span id="cb96-109"><a href="#cb96-109"></a><span class="st">- template&lt;class T&gt;</span></span>
<span id="cb96-110"><a href="#cb96-110"></a><span class="st">-   bool operator&gt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; y) noexcept;  </span></span>
<span id="cb96-111"><a href="#cb96-111"></a><span class="va">+ template&lt;class T&gt;</span></span>
<span id="cb96-112"><a href="#cb96-112"></a><span class="va">+   strong_ordering operator&lt;=&gt;(const shared_ptr&lt;T&gt;&amp; x, nullptr_t) noexcept;</span></span>
<span id="cb96-113"><a href="#cb96-113"></a></span>
<span id="cb96-114"><a href="#cb96-114"></a>  [...]</span>
<span id="cb96-115"><a href="#cb96-115"></a>}</span></code></pre></div>
</blockquote>
<p>Remove from 20.10.10.2 [allocator.globals]:</p>
<blockquote>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> U<span class="op">&gt;</span></span>
<span id="cb97-2"><a href="#cb97-2"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> allocator<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span>, <span class="kw">const</span> allocator<span class="op">&lt;</span>U<span class="op">&gt;&amp;)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="kw">true</span></code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class T, class U&gt;
  bool operator!=(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="kw">false</span></code>.</p>
</div>
</blockquote>
<p>Change 20.11.1.5 [unique.ptr.special]:</p>
<blockquote>
<div class="sourceCode" id="cb99"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> D1, <span class="kw">class</span> T2, <span class="kw">class</span> D2<span class="op">&gt;</span></span>
<span id="cb99-2"><a href="#cb99-2"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> unique_ptr<span class="op">&lt;</span>T1, D1<span class="op">&gt;&amp;</span> x, <span class="kw">const</span> unique_ptr<span class="op">&lt;</span>T2, D2<span class="op">&gt;&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: <code class="sourceCode cpp">x<span class="op">.</span>get<span class="op">()</span> <span class="op">==</span> y<span class="op">.</span>get<span class="op">()</span></code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class T1, class D1, class T2, class D2&gt;
  bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: <code class="sourceCode cpp">x<span class="op">.</span>get<span class="op">()</span> <span class="op">!=</span> y<span class="op">.</span>get<span class="op">()</span></code>.</p>
</div>
<p>[…]</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> D1, <span class="kw">class</span> T2, <span class="kw">class</span> D2<span class="op">&gt;</span></span>
<span id="cb101-2"><a href="#cb101-2"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><span class="kw">const</span> unique_ptr<span class="op">&lt;</span>T1, D1<span class="op">&gt;&amp;</span> x, <span class="kw">const</span> unique_ptr<span class="op">&lt;</span>T2, D2<span class="op">&gt;&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">10</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(</span>x <span class="op">&lt;</span> y<span class="op">)</span></code>.</p>
<div class="addu">
<pre><code>template&lt;class T1, class D1, class T2, class D2&gt;
    requires ThreeWayComparableWith&lt;typename unique_ptr&lt;T1, D1&gt;::pointer,
                                    typename unique_ptr&lt;T2, D2&gt;::pointer&gt;
  compare_three_way_result_t&lt;typename unique_ptr&lt;T1, D1&gt;::pointer, typename unique_ptr&lt;T2, D2&gt;::pointer&gt;
    operator&lt;=&gt;(const unique_ptr&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">10*</a></span> <em>Returns</em>: <code class="sourceCode cpp">compare_three_way<span class="op">()(</span>x<span class="op">.</span>get<span class="op">()</span>, y<span class="op">.</span>get<span class="op">())</span></code>.</p>
</div>
<div class="sourceCode" id="cb103"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> D<span class="op">&gt;</span></span>
<span id="cb103-2"><a href="#cb103-2"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> unique_ptr<span class="op">&lt;</span>T, D<span class="op">&gt;&amp;</span> x, nullptr_t<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb103-3"><a href="#cb103-3"></a>@[template&lt;class T, class D&gt;]{.rm}@</span>
<span id="cb103-4"><a href="#cb103-4"></a>@[  bool operator==(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x) noexcept;]{.rm}@</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">11</a></span> Returns: <code class="sourceCode cpp"><span class="op">!</span>x</code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class T, class D&gt;
  bool operator!=(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t) noexcept;
template&lt;class T, class D&gt;
  bool operator!=(nullptr_t, const unique_ptr&lt;T, D&gt;&amp; x) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">12</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">(</span><span class="dt">bool</span><span class="op">)</span>x</code>.</p>
</div>
<p>[…]</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> D<span class="op">&gt;</span></span>
<span id="cb105-2"><a href="#cb105-2"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><span class="kw">const</span> unique_ptr<span class="op">&lt;</span>T, D<span class="op">&gt;&amp;</span> x, nullptr_t<span class="op">)</span>;</span>
<span id="cb105-3"><a href="#cb105-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> D<span class="op">&gt;</span></span>
<span id="cb105-4"><a href="#cb105-4"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span>nullptr_t, <span class="kw">const</span> unique_ptr<span class="op">&lt;</span>T, D<span class="op">&gt;&amp;</span> x<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">17</a></span> <em>Returns</em>: The first function template returns <code class="sourceCode cpp"><span class="op">!(</span>x <span class="op">&lt;</span> <span class="kw">nullptr</span><span class="op">)</span></code>. The second function template returns <code class="sourceCode cpp"><span class="op">!(</span><span class="kw">nullptr</span> <span class="op">&lt;</span> x<span class="op">)</span></code>.</p>
<div class="addu">
<pre><code>template&lt;class T, class D&gt;
    requires ThreeWayComparableWith&lt;typename unique_ptr&lt;T, D&gt;::pointer, nullptr_t&gt;
  compare_three_way_result_t&lt;typename unique_ptr&lt;T, D&gt;::pointer, nullptr_t&gt;
    operator&lt;=&gt;(const unique_ptr&lt;T, D&gt;&amp; x, nullptr_t);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">18</a></span> <em>Returns</em>: <code class="sourceCode cpp">compare_three_way<span class="op">()(</span>x<span class="op">.</span>get<span class="op">()</span>, <span class="kw">nullptr</span><span class="op">)</span></code>.</p>
</div>
</blockquote>
<p>Change 20.11.3.7 [util.smartptr.shared.cmp]:</p>
<blockquote>
<div class="sourceCode" id="cb107"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> U<span class="op">&gt;</span></span>
<span id="cb107-2"><a href="#cb107-2"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> shared_ptr<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> a, <span class="kw">const</span> shared_ptr<span class="op">&lt;</span>U<span class="op">&gt;&amp;</span> b<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Returns</em>: <code class="sourceCode cpp">a<span class="op">.</span>get<span class="op">()</span> <span class="op">==</span> b<span class="op">.</span>get<span class="op">()</span></code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class T, class U&gt;
  bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp">less<span class="op">&lt;&gt;()(</span>a<span class="op">.</span>get<span class="op">()</span>, b<span class="op">.</span>get<span class="op">())</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> [<em>Note</em>: Defining a comparison function allows <code class="sourceCode cpp">shared_ptr</code> objects to be used as keys in associative containers. —<em>end note</em>]</p>
</div>
<div class="sourceCode" id="cb109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb109-2"><a href="#cb109-2"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> shared_ptr<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> a, nullptr_t<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb109-3"><a href="#cb109-3"></a>@[template&lt;class T&gt;]{.rm}@</span>
<span id="cb109-4"><a href="#cb109-4"></a>@[  bool operator==(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;]{.rm}@</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!</span>a</code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class T&gt;
  bool operator!=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template&lt;class T&gt;
  bool operator!=(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">(</span><span class="dt">bool</span><span class="op">)</span>a</code>.</p>
<pre><code>template&lt;class T&gt;
  bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template&lt;class T&gt;
  bool operator&lt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Returns</em>: The first function template returns <code class="sourceCode cpp">less<span class="op">&lt;</span><span class="kw">typename</span> shared_ptr<span class="op">&lt;</span>T<span class="op">&gt;::</span>element_type<span class="op">*&gt;()(</span>a<span class="op">.</span>get<span class="op">()</span>, <span class="kw">nullptr</span><span class="op">)</span></code> The second function template returns <code class="sourceCode cpp">less<span class="op">&lt;</span><span class="kw">typename</span> shared_ptr<span class="op">&lt;</span>T<span class="op">&gt;::</span>element_type<span class="op">*&gt;()(</span><span class="kw">nullptr</span>, a<span class="op">.</span>get<span class="op">())</span></code></p>
<pre><code>template&lt;class T&gt;
  bool operator&gt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template&lt;class T&gt;
  bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Returns</em>: The first function template returns <code class="sourceCode cpp"><span class="kw">nullptr</span> <span class="op">&lt;</span> a</code>. The second function template returns <code class="sourceCode cpp">a <span class="op">&lt;</span> <span class="kw">nullptr</span></code>.</p>
<pre><code>template&lt;class T&gt;
  bool operator&lt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template&lt;class T&gt;
  bool operator&lt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">8</a></span> <em>Returns</em>: The first function template returns <code class="sourceCode cpp"><span class="op">!(</span><span class="kw">nullptr</span> <span class="op">&lt;</span> a<span class="op">)</span></code>. The second function template returns <code class="sourceCode cpp"><span class="op">!(</span>a <span class="op">&lt;</span> <span class="kw">nullptr</span><span class="op">)</span></code>.</p>
<pre><code>template&lt;class T&gt;
  bool operator&gt;=(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;
template&lt;class T&gt;
  bool operator&gt;=(nullptr_t, const shared_ptr&lt;T&gt;&amp; a) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">9</a></span> <em>Returns</em>: The first function template returns <code class="sourceCode cpp"><span class="op">!(</span>a <span class="op">&lt;</span> <span class="kw">nullptr</span><span class="op">)</span></code>. The second function template returns <code class="sourceCode cpp"><span class="op">!(</span><span class="kw">nullptr</span> <span class="op">&lt;</span> a<span class="op">)</span></code>.</p>
</div>
<div class="addu">
<pre><code>template&lt;class T, class U&gt;
  strong_ordering operator&lt;=&gt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">10</a></span> <em>Returns</em>: <code class="sourceCode cpp">compare_three_way<span class="op">()(</span>a<span class="op">.</span>get<span class="op">()</span>, b<span class="op">.</span>get<span class="op">())</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">11</a></span> [<em>Note</em>: Defining a comparison function allows <code class="sourceCode cpp">shared_ptr</code> objects to be used as keys in associative containers. —<em>end note</em>]</p>
<pre><code>template&lt;class T&gt;
  strong_ordering operator&lt;=&gt;(const shared_ptr&lt;T&gt;&amp; a, nullptr_t) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">12</a></span> <em>Returns</em>: <code class="sourceCode cpp">compare_three_way<span class="op">()(</span>a<span class="op">.</span>get<span class="op">()</span>, <span class="kw">nullptr</span><span class="op">)</span></code>.</p>
</div>
</blockquote>
<p>Change 20.12.1 [mem.res.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb117"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb117-1"><a href="#cb117-1"></a>namespace std::pmr {</span>
<span id="cb117-2"><a href="#cb117-2"></a>  // [mem.res.class], class memory_resource</span>
<span id="cb117-3"><a href="#cb117-3"></a>  class memory_resource;</span>
<span id="cb117-4"><a href="#cb117-4"></a></span>
<span id="cb117-5"><a href="#cb117-5"></a>  bool operator==(const memory_resource&amp; a, const memory_resource&amp; b) noexcept;</span>
<span id="cb117-6"><a href="#cb117-6"></a><span class="st">- bool operator!=(const memory_resource&amp; a, const memory_resource&amp; b) noexcept;</span></span>
<span id="cb117-7"><a href="#cb117-7"></a></span>
<span id="cb117-8"><a href="#cb117-8"></a>  // [mem.poly.allocator.class], class template polymorphic_allocator</span>
<span id="cb117-9"><a href="#cb117-9"></a>  template&lt;class Tp&gt; class polymorphic_allocator;</span>
<span id="cb117-10"><a href="#cb117-10"></a></span>
<span id="cb117-11"><a href="#cb117-11"></a>  template&lt;class T1, class T2&gt;</span>
<span id="cb117-12"><a href="#cb117-12"></a>    bool operator==(const polymorphic_allocator&lt;T1&gt;&amp; a,</span>
<span id="cb117-13"><a href="#cb117-13"></a>                    const polymorphic_allocator&lt;T2&gt;&amp; b) noexcept;</span>
<span id="cb117-14"><a href="#cb117-14"></a><span class="st">- template&lt;class T1, class T2&gt;</span></span>
<span id="cb117-15"><a href="#cb117-15"></a><span class="st">-   bool operator!=(const polymorphic_allocator&lt;T1&gt;&amp; a,</span></span>
<span id="cb117-16"><a href="#cb117-16"></a><span class="st">-                   const polymorphic_allocator&lt;T2&gt;&amp; b) noexcept;</span></span>
<span id="cb117-17"><a href="#cb117-17"></a></span>
<span id="cb117-18"><a href="#cb117-18"></a>  [...]</span>
<span id="cb117-19"><a href="#cb117-19"></a>}</span></code></pre></div>
</blockquote>
<p>Change 20.12.2.3 [mem.res.eq]:</p>
<blockquote>
<div class="sourceCode" id="cb118"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> memory_resource<span class="op">&amp;</span> a, <span class="kw">const</span> memory_resource<span class="op">&amp;</span> b<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">&amp;</span>a <span class="op">==</span> <span class="op">&amp;</span>b <span class="op">||</span> a<span class="op">.</span>is_equal<span class="op">(</span>b<span class="op">)</span></code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>bool operator!=(const memory_resource&amp; a, const memory_resource&amp; b) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(</span>a <span class="op">==</span> b<span class="op">)</span></code>.</p>
</div>
</blockquote>
<p>Change 20.12.3.3 [mem.poly.allocator.eq]:</p>
<blockquote>
<div class="sourceCode" id="cb120"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T1, <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb120-2"><a href="#cb120-2"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> polymorphic_allocator<span class="op">&lt;</span>T1<span class="op">&gt;&amp;</span> a,</span>
<span id="cb120-3"><a href="#cb120-3"></a>                  <span class="kw">const</span> polymorphic_allocator<span class="op">&lt;</span>T2<span class="op">&gt;&amp;</span> b<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">*</span>a<span class="op">.</span>resource<span class="op">()</span> <span class="op">==</span> <span class="op">*</span>b<span class="op">.</span>resource<span class="op">()</span></code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class T1, class T2&gt;
  bool operator!=(const polymorphic_allocator&lt;T1&gt;&amp; a,
                  const polymorphic_allocator&lt;T2&gt;&amp; b) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(</span>a <span class="op">==</span> b<span class="op">)</span></code>.</p>
</div>
</blockquote>
<p>Change 20.13.1 [allocator.adaptor.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb122"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb122-1"><a href="#cb122-1"></a>namespace std {</span>
<span id="cb122-2"><a href="#cb122-2"></a>  // class template scoped allocator adaptor</span>
<span id="cb122-3"><a href="#cb122-3"></a>  template&lt;class OuterAlloc, class... InnerAlloc&gt;</span>
<span id="cb122-4"><a href="#cb122-4"></a>    class scoped_allocator_adaptor;</span>
<span id="cb122-5"><a href="#cb122-5"></a></span>
<span id="cb122-6"><a href="#cb122-6"></a>  // [scoped.adaptor.operators], scoped allocator operators</span>
<span id="cb122-7"><a href="#cb122-7"></a>  template&lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;</span>
<span id="cb122-8"><a href="#cb122-8"></a>    bool operator==(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,</span>
<span id="cb122-9"><a href="#cb122-9"></a>                    const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;</span>
<span id="cb122-10"><a href="#cb122-10"></a><span class="st">- template&lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;</span></span>
<span id="cb122-11"><a href="#cb122-11"></a><span class="st">-   bool operator!=(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,</span></span>
<span id="cb122-12"><a href="#cb122-12"></a><span class="st">-                   const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;</span></span>
<span id="cb122-13"><a href="#cb122-13"></a>}</span></code></pre></div>
</blockquote>
<p>Change 20.13.5 [scoped.adaptor.operators]:</p>
<blockquote>
<div class="sourceCode" id="cb123"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> OuterA1, <span class="kw">class</span> OuterA2, <span class="kw">class</span><span class="op">...</span> InnerAllocs<span class="op">&gt;</span></span>
<span id="cb123-2"><a href="#cb123-2"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> scoped_allocator_adaptor<span class="op">&lt;</span>OuterA1, InnerAllocs<span class="op">...&gt;&amp;</span> a,</span>
<span id="cb123-3"><a href="#cb123-3"></a>                  <span class="kw">const</span> scoped_allocator_adaptor<span class="op">&lt;</span>OuterA2, InnerAllocs<span class="op">...&gt;&amp;</span> b<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Returns</em>: If <code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">...(</span>InnerAllocs<span class="op">)</span></code> is zero, <code class="sourceCode cpp">a<span class="op">.</span>outer_allocator<span class="op">()</span> <span class="op">==</span> b<span class="op">.</span>outer_allocator<span class="op">()</span></code> otherwise <code class="sourceCode cpp">a<span class="op">.</span>outer_allocator<span class="op">()</span> <span class="op">==</span> b<span class="op">.</span>outer_allocator<span class="op">()</span> <span class="op">&amp;&amp;</span> a<span class="op">.</span>inner_allocator<span class="op">()</span> <span class="op">==</span> b<span class="op">.</span>inner_allocator<span class="op">()</span></code></p>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
  bool operator!=(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                  const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(</span>a <span class="op">==</span> b<span class="op">)</span></code>.</p>
</div>
</blockquote>
<p>Change 20.14.1 [functional.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb125"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb125-1"><a href="#cb125-1"></a>namespace std {</span>
<span id="cb125-2"><a href="#cb125-2"></a>  [...]</span>
<span id="cb125-3"><a href="#cb125-3"></a>  template&lt;class R, class... ArgTypes&gt;</span>
<span id="cb125-4"><a href="#cb125-4"></a>    void swap(function&lt;R(ArgTypes...)&gt;&amp;, function&lt;R(ArgTypes...)&gt;&amp;) noexcept;</span>
<span id="cb125-5"><a href="#cb125-5"></a></span>
<span id="cb125-6"><a href="#cb125-6"></a>  template&lt;class R, class... ArgTypes&gt;</span>
<span id="cb125-7"><a href="#cb125-7"></a>    bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t) noexcept;</span>
<span id="cb125-8"><a href="#cb125-8"></a><span class="st">- template&lt;class R, class... ArgTypes&gt;</span></span>
<span id="cb125-9"><a href="#cb125-9"></a><span class="st">-   bool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;) noexcept;</span></span>
<span id="cb125-10"><a href="#cb125-10"></a><span class="st">- template&lt;class R, class... ArgTypes&gt;</span></span>
<span id="cb125-11"><a href="#cb125-11"></a><span class="st">-   bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t) noexcept;</span></span>
<span id="cb125-12"><a href="#cb125-12"></a><span class="st">- template&lt;class R, class... ArgTypes&gt;</span></span>
<span id="cb125-13"><a href="#cb125-13"></a><span class="st">-   bool operator!=(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;) noexcept;</span></span>
<span id="cb125-14"><a href="#cb125-14"></a></span>
<span id="cb125-15"><a href="#cb125-15"></a>  // [func.search], searchers</span>
<span id="cb125-16"><a href="#cb125-16"></a>  template&lt;class ForwardIterator, class BinaryPredicate = equal_to&lt;&gt;&gt;</span>
<span id="cb125-17"><a href="#cb125-17"></a>    class default_searcher;</span>
<span id="cb125-18"><a href="#cb125-18"></a>  [...] </span>
<span id="cb125-19"><a href="#cb125-19"></a>}</span></code></pre></div>
</blockquote>
<p>Change 20.14.8 [range.cmp]/2 to add <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code>:</p>
<blockquote>
<p>There is an implementation-defined strict total ordering over all pointer values of a given type. This total ordering is consistent with the partial order imposed by the builtin operators <code class="sourceCode cpp"><span class="op">&lt;</span></code>, <code class="sourceCode cpp"><span class="op">&gt;</span></code>, <code class="sourceCode cpp"><span class="op">&lt;=</span></code>, <span class="rm" style="color: #bf0303"><del>and</del></span> <code class="sourceCode cpp"><span class="op">&gt;=</span></code> <span class="addu">, and <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code></span>.</p>
</blockquote>
<p>Change 20.14.16.2 [func.wrap.func]:</p>
<blockquote>
<div class="sourceCode" id="cb126"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb126-1"><a href="#cb126-1"></a>namespace std {</span>
<span id="cb126-2"><a href="#cb126-2"></a>  template&lt;class&gt; class function; // not defined</span>
<span id="cb126-3"><a href="#cb126-3"></a>  </span>
<span id="cb126-4"><a href="#cb126-4"></a>  [...]</span>
<span id="cb126-5"><a href="#cb126-5"></a>  </span>
<span id="cb126-6"><a href="#cb126-6"></a>  // [func.wrap.func.nullptr], Null pointer comparisons</span>
<span id="cb126-7"><a href="#cb126-7"></a>  template&lt;class R, class... ArgTypes&gt;</span>
<span id="cb126-8"><a href="#cb126-8"></a>    bool operator==(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t) noexcept;</span>
<span id="cb126-9"><a href="#cb126-9"></a></span>
<span id="cb126-10"><a href="#cb126-10"></a><span class="st">- template&lt;class R, class... ArgTypes&gt;</span></span>
<span id="cb126-11"><a href="#cb126-11"></a><span class="st">-   bool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;) noexcept;</span></span>
<span id="cb126-12"><a href="#cb126-12"></a><span class="st">-</span></span>
<span id="cb126-13"><a href="#cb126-13"></a><span class="st">- template&lt;class R, class... ArgTypes&gt;</span></span>
<span id="cb126-14"><a href="#cb126-14"></a><span class="st">-   bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp;, nullptr_t) noexcept;</span></span>
<span id="cb126-15"><a href="#cb126-15"></a><span class="st">-</span></span>
<span id="cb126-16"><a href="#cb126-16"></a><span class="st">- template&lt;class R, class... ArgTypes&gt;</span></span>
<span id="cb126-17"><a href="#cb126-17"></a><span class="st">-   bool operator!=(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp;) noexcept;</span></span>
<span id="cb126-18"><a href="#cb126-18"></a></span>
<span id="cb126-19"><a href="#cb126-19"></a>  [...]</span>
<span id="cb126-20"><a href="#cb126-20"></a>}  </span></code></pre></div>
</blockquote>
<p>Change 20.14.16.2.6 [func.wrap.func.nullptr]:</p>
<blockquote>
<div class="sourceCode" id="cb127"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb127-1"><a href="#cb127-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> R, <span class="kw">class</span><span class="op">...</span> ArgTypes<span class="op">&gt;</span></span>
<span id="cb127-2"><a href="#cb127-2"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> function<span class="op">&lt;</span>R<span class="op">(</span>ArgTypes<span class="op">...)&gt;&amp;</span> f, nullptr_t<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb127-3"><a href="#cb127-3"></a>@[template&lt;class R, class... ArgTypes&gt;]{.rm}@</span>
<span id="cb127-4"><a href="#cb127-4"></a>@[  bool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp; f) noexcept;]{.rm}@</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!</span>f</code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class R, class... ArgTypes&gt;
  bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp; f, nullptr_t) noexcept;
template&lt;class R, class... ArgTypes&gt;
  bool operator!=(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp; f) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">(</span><span class="dt">bool</span><span class="op">)</span>f</code>.</p>
</div>
</blockquote>
<p>Add a new row to 20.15.4.3 [meta.unary.prop], the “Type property predicates” table:</p>
<blockquote>
<table>
<tr>
<th>
Template
</th>
<th>
Condition
</th>
<th>
Preconditions&gt;
</th>
</tr>
<tr>
<td>
<div class="addu">
<pre><code>template&lt;class T&gt;
struct has_strong_structural_equality;</code></pre>
</div>
</td>
<td>
<span class="addu">The type <code class="sourceCode cpp">T</code> has strong structural equality ([class.compare.default]).</span>
</td>
<td>
<span class="addu"><code class="sourceCode cpp">T</code> shall be a complete type, <em>cv</em> <code class="sourceCode cpp"><span class="dt">void</span></code>, or an array of unknown bound.</span>
</td>
</tr>
</table>
</blockquote>
<p>Change 20.15.7.6 [meta.trans.other] to add special rule for comparison categories:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> Note A: For the <code class="sourceCode cpp">common_type</code> trait applied to a template parameter pack <code class="sourceCode cpp">T</code> of types, the member <code class="sourceCode cpp">type</code> shall be either defined or not present as follows:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(3.1)</a></span> If <code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">...(</span>T<span class="op">)</span></code> is zero, there shall be no member <code class="sourceCode cpp">type</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.2)</a></span> If <code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">...(</span>T<span class="op">)</span></code> is one, let <code class="sourceCode cpp">T0</code> denote the sole type constituting the pack <code class="sourceCode cpp">T</code>. The member typedef-name <code class="sourceCode cpp">type</code> shall denote the same type, if any, as <code class="sourceCode cpp">common_type_t<span class="op">&lt;</span>T0, T0<span class="op">&gt;</span></code>; otherwise there shall be no member <code class="sourceCode cpp">type</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.3)</a></span> If <code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">...(</span>T<span class="op">)</span></code> is two, let the first and second types constituting <code class="sourceCode cpp">T</code> be denoted by <code class="sourceCode cpp">T1</code> and <code class="sourceCode cpp">T2</code>, respectively, and let <code class="sourceCode cpp">D1</code> and <code class="sourceCode cpp">D2</code> denote the same types as <code class="sourceCode cpp">decay_t<span class="op">&lt;</span>T1<span class="op">&gt;</span></code> and <code class="sourceCode cpp">decay_t<span class="op">&lt;</span>T2<span class="op">&gt;</span></code>, respectively.
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(3.3.1)</a></span> If <code class="sourceCode cpp">is_same_v<span class="op">&lt;</span>T1, D1<span class="op">&gt;</span></code> is <code class="sourceCode cpp"><span class="kw">false</span></code> or <code class="sourceCode cpp">is_same_v<span class="op">&lt;</span>T2, D2<span class="op">&gt;</span></code> is <code class="sourceCode cpp"><span class="kw">false</span></code>, let <code class="sourceCode cpp">C</code> denote the same type, if any, as <code class="sourceCode cpp">common_type_t<span class="op">&lt;</span>D1, D2<span class="op">&gt;</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.3.2)</a></span> [<em>Note</em>: None of the following will apply if there is a specialization <code class="sourceCode cpp">common_type<span class="op">&lt;</span>D1, D2<span class="op">&gt;</span></code>. —<em>end note</em>]</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.3.*)</a></span> <span class="addu">Otherwise, if both <code class="sourceCode cpp">D1</code> and <code class="sourceCode cpp">D2</code> denote comparison category type ([cmp.categories.pre]), let <code class="sourceCode cpp">C</code> denote common comparison type ([class.spaceship]) of <code class="sourceCode cpp">D1</code> and <code class="sourceCode cpp">D2</code>.</span></li>
<li><span class="marginalizedparent"><a class="marginalized">(3.3.3)</a></span> Otherwise, if <code class="sourceCode cpp">decay_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="kw">false</span> <span class="op">?</span> declval<span class="op">&lt;</span>D1<span class="op">&gt;()</span> <span class="op">:</span> declval<span class="op">&lt;</span>D2<span class="op">&gt;())&gt;</span></code> denotes a valid type, let <code class="sourceCode cpp">C</code> denote that type.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.3.4)</a></span> Otherwise, if <code class="sourceCode cpp">COND_RES<span class="op">(</span>CREF<span class="op">(</span>D1<span class="op">)</span>, CREF<span class="op">(</span>D2<span class="op">))</span></code> denotes a type, let <code class="sourceCode cpp">C</code> denote the type <code class="sourceCode cpp">decay_t<span class="op">&lt;</span>COND_RES<span class="op">(</span>CREF<span class="op">(</span>D1<span class="op">)</span>, CREF<span class="op">(</span>D2<span class="op">))&gt;</span></code>. In either case, the member typedef-name type shall denote the same type, if any, as <code class="sourceCode cpp">C</code>. Otherwise, there shall be no member <code class="sourceCode cpp">type</code>.</li>
</ul></li>
<li><span class="marginalizedparent"><a class="marginalized">(3.4)</a></span> If <code class="sourceCode cpp"><span class="kw">sizeof</span><span class="op">...(</span>T<span class="op">)</span></code> is greater than two, let <code class="sourceCode cpp">T1</code>, <code class="sourceCode cpp">T2</code>, and <code class="sourceCode cpp">R</code>, respectively, denote the first, second, and (pack of) remaining types constituting <code class="sourceCode cpp">T</code>. Let <code class="sourceCode cpp">C</code> denote the same type, if any, as <code class="sourceCode cpp">common_type_t<span class="op">&lt;</span>T1, T2<span class="op">&gt;</span></code>. If there is such a type <code class="sourceCode cpp">C</code>, the member typedef-name <code class="sourceCode cpp">type</code> shall denote the same type, if any, as <code class="sourceCode cpp">common_type_t<span class="op">&lt;</span>C, R<span class="op">...&gt;</span></code>. Otherwise, there shall be no member <code class="sourceCode cpp">type</code>.</li>
</ul>
</blockquote>
<p>Change 20.17.2 [type.index.overview]. Note that the relational operators on <code class="sourceCode cpp">type_index</code> are based on <code class="sourceCode cpp">type_info<span class="op">::</span>before</code> (effectively <code class="sourceCode cpp"><span class="op">&lt;</span></code>). <code class="sourceCode cpp">type_info</code> <em>could</em> provide a three-way ordering function, but does not. Since an important motivation for the existence of <code class="sourceCode cpp">type_index</code> is to be used as a key in an associative container, we do not want to pessimize <code class="sourceCode cpp"><span class="op">&lt;</span></code> - but do want to provide <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code>.</p>
<blockquote>
<div class="sourceCode" id="cb130"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb130-1"><a href="#cb130-1"></a>namespace std {</span>
<span id="cb130-2"><a href="#cb130-2"></a>  class type_index {</span>
<span id="cb130-3"><a href="#cb130-3"></a>  public:</span>
<span id="cb130-4"><a href="#cb130-4"></a>    type_index(const type_info&amp; rhs) noexcept;</span>
<span id="cb130-5"><a href="#cb130-5"></a>    bool operator==(const type_index&amp; rhs) const noexcept;</span>
<span id="cb130-6"><a href="#cb130-6"></a><span class="st">-   bool operator!=(const type_index&amp; rhs) const noexcept;</span></span>
<span id="cb130-7"><a href="#cb130-7"></a>    bool operator&lt; (const type_index&amp; rhs) const noexcept;</span>
<span id="cb130-8"><a href="#cb130-8"></a>    bool operator&gt; (const type_index&amp; rhs) const noexcept;</span>
<span id="cb130-9"><a href="#cb130-9"></a>    bool operator&lt;=(const type_index&amp; rhs) const noexcept;</span>
<span id="cb130-10"><a href="#cb130-10"></a>    bool operator&gt;=(const type_index&amp; rhs) const noexcept;</span>
<span id="cb130-11"><a href="#cb130-11"></a><span class="va">+   strong_ordering operator&lt;=&gt;(const type_index&amp; rhs) const noexcept;</span></span>
<span id="cb130-12"><a href="#cb130-12"></a>    size_t hash_code() const noexcept;</span>
<span id="cb130-13"><a href="#cb130-13"></a>    const char* name() const noexcept;</span>
<span id="cb130-14"><a href="#cb130-14"></a></span>
<span id="cb130-15"><a href="#cb130-15"></a>  private:</span>
<span id="cb130-16"><a href="#cb130-16"></a>    const type_info* target;    // exposition only</span>
<span id="cb130-17"><a href="#cb130-17"></a>    // Note that the use of a pointer here, rather than a reference,</span>
<span id="cb130-18"><a href="#cb130-18"></a>    // means that the default copy/move constructor and assignment</span>
<span id="cb130-19"><a href="#cb130-19"></a>    // operators will be provided and work as expected.</span>
<span id="cb130-20"><a href="#cb130-20"></a>  };</span>
<span id="cb130-21"><a href="#cb130-21"></a>}</span></code></pre></div>
</blockquote>
<p>Change 20.17.3 [type.index.members]:</p>
<blockquote>
<div class="sourceCode" id="cb131"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb131-1"><a href="#cb131-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> type_index<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">*</span>target <span class="op">==</span> <span class="op">*</span>rhs<span class="op">.</span>target</code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>bool operator!=(const type_index&amp; rhs) const noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">*</span>target <span class="op">!=</span> <span class="op">*</span>rhs<span class="op">.</span>target</code>.</p>
</div>
<div class="sourceCode" id="cb133"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb133-1"><a href="#cb133-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span><span class="kw">const</span> type_index<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: <code class="sourceCode cpp">target<span class="op">-&gt;</span>before<span class="op">(*</span>rhs<span class="op">.</span>target<span class="op">)</span></code>.</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb134-1"><a href="#cb134-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;(</span><span class="kw">const</span> type_index<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Returns</em>: <code class="sourceCode cpp">rhs<span class="op">.</span>target<span class="op">-&gt;</span>before<span class="op">(*</span>target<span class="op">)</span></code>.</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span><span class="kw">const</span> type_index<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!</span>rhs<span class="op">.</span>target<span class="op">-&gt;</span>before<span class="op">(*</span>target<span class="op">)</span></code>.</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb136-1"><a href="#cb136-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><span class="kw">const</span> type_index<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!</span>target<span class="op">-&gt;</span>before<span class="op">(*</span>rhs<span class="op">.</span>target<span class="op">)</span></code>.</p>
<div class="addu">
<pre><code>strong_ordering operator&lt;=&gt;(const type_index&amp; rhs) const noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">8</a></span> <em>Effects</em>: Equivalent to:</p>
<blockquote>
<pre><code>if (*target == *rhs.target) return strong_ordering::equal;
if (target-&gt;before(*rhs.target)) return strong_ordering::less;
return strong_ordering::greater;</code></pre>
</blockquote>
</div>
</blockquote>
<p>Change 20.19.1 [charconv.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb139"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb139-1"><a href="#cb139-1"></a>namespace std {</span>
<span id="cb139-2"><a href="#cb139-2"></a>  [...]</span>
<span id="cb139-3"><a href="#cb139-3"></a></span>
<span id="cb139-4"><a href="#cb139-4"></a>  // [charconv.to.chars], primitive numerical output conversion</span>
<span id="cb139-5"><a href="#cb139-5"></a>  struct to_chars_result {</span>
<span id="cb139-6"><a href="#cb139-6"></a>    char* ptr;</span>
<span id="cb139-7"><a href="#cb139-7"></a>    errc ec;</span>
<span id="cb139-8"><a href="#cb139-8"></a></span>
<span id="cb139-9"><a href="#cb139-9"></a><span class="va">+   friend bool operator==(const to_chars_result&amp;, const to_chars_result&amp;) = default;</span></span>
<span id="cb139-10"><a href="#cb139-10"></a>  };</span>
<span id="cb139-11"><a href="#cb139-11"></a></span>
<span id="cb139-12"><a href="#cb139-12"></a>  [...]</span>
<span id="cb139-13"><a href="#cb139-13"></a></span>
<span id="cb139-14"><a href="#cb139-14"></a>  // [charconv.from.chars], primitive numerical input conversion</span>
<span id="cb139-15"><a href="#cb139-15"></a>  struct from_chars_result {</span>
<span id="cb139-16"><a href="#cb139-16"></a>    const char* ptr;</span>
<span id="cb139-17"><a href="#cb139-17"></a>    errc ec;</span>
<span id="cb139-18"><a href="#cb139-18"></a></span>
<span id="cb139-19"><a href="#cb139-19"></a><span class="va">+   friend bool operator==(const from_chars_result&amp;, const from_chars_result&amp;) = default;</span></span>
<span id="cb139-20"><a href="#cb139-20"></a>  };</span>
<span id="cb139-21"><a href="#cb139-21"></a></span>
<span id="cb139-22"><a href="#cb139-22"></a>  [...]</span>
<span id="cb139-23"><a href="#cb139-23"></a>}</span></code></pre></div>
</blockquote>
<h2 id="clause-21-strings-library"><span class="header-section-number">5.6</span> Clause 21: Strings library<a href="#clause-21-strings-library" class="self-link"></a></h2>
<p>Changing the operators for <code class="sourceCode cpp">basic_string</code> and <code class="sourceCode cpp">basic_string_view</code> and adding extra type alises to the <code class="sourceCode cpp">char_traits</code> specializations provided by the standard.</p>
<p>Change 21.2.3.1 [char.traits.specializations.char]:</p>
<blockquote>
<div class="sourceCode" id="cb140"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb140-1"><a href="#cb140-1"></a>namespace std {</span>
<span id="cb140-2"><a href="#cb140-2"></a>  template&lt;&gt; struct char_traits&lt;char&gt; {</span>
<span id="cb140-3"><a href="#cb140-3"></a>    using char_type  = char;</span>
<span id="cb140-4"><a href="#cb140-4"></a>    using int_type   = int;</span>
<span id="cb140-5"><a href="#cb140-5"></a>    using off_type   = streamoff;</span>
<span id="cb140-6"><a href="#cb140-6"></a>    using pos_type   = streampos;</span>
<span id="cb140-7"><a href="#cb140-7"></a>    using state_type = mbstate_t;</span>
<span id="cb140-8"><a href="#cb140-8"></a><span class="va">+   using comparison_category = strong_ordering;</span></span>
<span id="cb140-9"><a href="#cb140-9"></a>    [...]</span>
<span id="cb140-10"><a href="#cb140-10"></a>  };</span>
<span id="cb140-11"><a href="#cb140-11"></a>}</span></code></pre></div>
</blockquote>
<p>Change 21.2.3.2 [char.traits.specializations.char8.t]</p>
<blockquote>
<div class="sourceCode" id="cb141"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb141-1"><a href="#cb141-1"></a>namespace std {</span>
<span id="cb141-2"><a href="#cb141-2"></a>  template&lt;&gt; struct char_traits&lt;char8_t&gt; {</span>
<span id="cb141-3"><a href="#cb141-3"></a>    using char_type = char8_t;</span>
<span id="cb141-4"><a href="#cb141-4"></a>    using int_type = unsigned int;</span>
<span id="cb141-5"><a href="#cb141-5"></a>    using off_type = streamoff;</span>
<span id="cb141-6"><a href="#cb141-6"></a>    using pos_type = u8streampos;</span>
<span id="cb141-7"><a href="#cb141-7"></a>    using state_type = mbstate_t;</span>
<span id="cb141-8"><a href="#cb141-8"></a><span class="va">+   using comparison_category = strong_ordering;    </span></span>
<span id="cb141-9"><a href="#cb141-9"></a>    [...]</span>
<span id="cb141-10"><a href="#cb141-10"></a>  };</span>
<span id="cb141-11"><a href="#cb141-11"></a>}</span></code></pre></div>
</blockquote>
<p>Change 21.2.3.3 [char.traits.specializations.char16.t]:</p>
<blockquote>
<div class="sourceCode" id="cb142"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb142-1"><a href="#cb142-1"></a>namespace std {</span>
<span id="cb142-2"><a href="#cb142-2"></a>  template&lt;&gt; struct char_traits&lt;char16_t&gt; {</span>
<span id="cb142-3"><a href="#cb142-3"></a>    using char_type  = char16_t;</span>
<span id="cb142-4"><a href="#cb142-4"></a>    using int_type   = uint_least16_t;</span>
<span id="cb142-5"><a href="#cb142-5"></a>    using off_type   = streamoff;</span>
<span id="cb142-6"><a href="#cb142-6"></a>    using pos_type   = u16streampos;</span>
<span id="cb142-7"><a href="#cb142-7"></a>    using state_type = mbstate_t;</span>
<span id="cb142-8"><a href="#cb142-8"></a><span class="va">+   using comparison_category = strong_ordering;    </span></span>
<span id="cb142-9"><a href="#cb142-9"></a>    [...]</span>
<span id="cb142-10"><a href="#cb142-10"></a>  };</span>
<span id="cb142-11"><a href="#cb142-11"></a>}</span></code></pre></div>
</blockquote>
<p>Change 21.2.3.4 [char.traits.specializations.char32.t]:</p>
<blockquote>
<div class="sourceCode" id="cb143"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb143-1"><a href="#cb143-1"></a>namespace std {</span>
<span id="cb143-2"><a href="#cb143-2"></a>  template&lt;&gt; struct char_traits&lt;char32_t&gt; {</span>
<span id="cb143-3"><a href="#cb143-3"></a>    using char_type  = char32_t;</span>
<span id="cb143-4"><a href="#cb143-4"></a>    using int_type   = uint_least32_t;</span>
<span id="cb143-5"><a href="#cb143-5"></a>    using off_type   = streamoff;</span>
<span id="cb143-6"><a href="#cb143-6"></a>    using pos_type   = u32streampos;</span>
<span id="cb143-7"><a href="#cb143-7"></a>    using state_type = mbstate_t;</span>
<span id="cb143-8"><a href="#cb143-8"></a><span class="va">+   using comparison_category = strong_ordering;    </span></span>
<span id="cb143-9"><a href="#cb143-9"></a>    [...]</span>
<span id="cb143-10"><a href="#cb143-10"></a>  };</span>
<span id="cb143-11"><a href="#cb143-11"></a>}</span></code></pre></div>
</blockquote>
<p>Change 21.2.3.5 [char.traits.specializations.wchar.t]:</p>
<blockquote>
<div class="sourceCode" id="cb144"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb144-1"><a href="#cb144-1"></a>namespace std {</span>
<span id="cb144-2"><a href="#cb144-2"></a>  template&lt;&gt; struct char_traits&lt;wchar_t&gt; {</span>
<span id="cb144-3"><a href="#cb144-3"></a>    using char_type  = wchar_t;</span>
<span id="cb144-4"><a href="#cb144-4"></a>    using int_type   = wint_t;</span>
<span id="cb144-5"><a href="#cb144-5"></a>    using off_type   = streamoff;</span>
<span id="cb144-6"><a href="#cb144-6"></a>    using pos_type   = wstreampos;</span>
<span id="cb144-7"><a href="#cb144-7"></a>    using state_type = mbstate_t;</span>
<span id="cb144-8"><a href="#cb144-8"></a><span class="va">+   using comparison_category = strong_ordering;    </span></span>
<span id="cb144-9"><a href="#cb144-9"></a>    [...]</span>
<span id="cb144-10"><a href="#cb144-10"></a>  };</span>
<span id="cb144-11"><a href="#cb144-11"></a>}</span></code></pre></div>
</blockquote>
<p>Change 21.3.1 [string.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb145"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb145-1"><a href="#cb145-1"></a>namespace std {</span>
<span id="cb145-2"><a href="#cb145-2"></a>  // [char.traits], character traits</span>
<span id="cb145-3"><a href="#cb145-3"></a>  template&lt;class charT&gt; struct char_traits;</span>
<span id="cb145-4"><a href="#cb145-4"></a>  template&lt;&gt; struct char_traits&lt;char&gt;;</span>
<span id="cb145-5"><a href="#cb145-5"></a>  template&lt;&gt; struct char_traits&lt;char8_t&gt;;</span>
<span id="cb145-6"><a href="#cb145-6"></a>  template&lt;&gt; struct char_traits&lt;char16_t&gt;;</span>
<span id="cb145-7"><a href="#cb145-7"></a>  template&lt;&gt; struct char_traits&lt;char32_t&gt;;</span>
<span id="cb145-8"><a href="#cb145-8"></a>  template&lt;&gt; struct char_traits&lt;wchar_t&gt;;</span>
<span id="cb145-9"><a href="#cb145-9"></a></span>
<span id="cb145-10"><a href="#cb145-10"></a>  // [basic.string], basic_string</span>
<span id="cb145-11"><a href="#cb145-11"></a>  template&lt;class charT, class traits = char_traits&lt;charT&gt;, class Allocator = allocator&lt;charT&gt;&gt;</span>
<span id="cb145-12"><a href="#cb145-12"></a>    class basic_string;</span>
<span id="cb145-13"><a href="#cb145-13"></a>    </span>
<span id="cb145-14"><a href="#cb145-14"></a>  [...]</span>
<span id="cb145-15"><a href="#cb145-15"></a>  </span>
<span id="cb145-16"><a href="#cb145-16"></a>  template&lt;class charT, class traits, class Allocator&gt;</span>
<span id="cb145-17"><a href="#cb145-17"></a>    bool operator==(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span>
<span id="cb145-18"><a href="#cb145-18"></a>                    const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;</span>
<span id="cb145-19"><a href="#cb145-19"></a><span class="st">- template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-20"><a href="#cb145-20"></a><span class="st">-   bool operator==(const charT* lhs,</span></span>
<span id="cb145-21"><a href="#cb145-21"></a><span class="st">-                   const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);</span></span>
<span id="cb145-22"><a href="#cb145-22"></a>  template&lt;class charT, class traits, class Allocator&gt;</span>
<span id="cb145-23"><a href="#cb145-23"></a>    bool operator==(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span>
<span id="cb145-24"><a href="#cb145-24"></a>                    const charT* rhs);</span>
<span id="cb145-25"><a href="#cb145-25"></a><span class="st">- template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-26"><a href="#cb145-26"></a><span class="st">-   bool operator!=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb145-27"><a href="#cb145-27"></a><span class="st">-                   const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;</span></span>
<span id="cb145-28"><a href="#cb145-28"></a><span class="st">- template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-29"><a href="#cb145-29"></a><span class="st">-   bool operator!=(const charT* lhs,</span></span>
<span id="cb145-30"><a href="#cb145-30"></a><span class="st">-                   const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);</span></span>
<span id="cb145-31"><a href="#cb145-31"></a><span class="st">- template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-32"><a href="#cb145-32"></a><span class="st">-   bool operator!=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb145-33"><a href="#cb145-33"></a><span class="st">-                   const charT* rhs);</span></span>
<span id="cb145-34"><a href="#cb145-34"></a></span>
<span id="cb145-35"><a href="#cb145-35"></a><span class="st">- template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-36"><a href="#cb145-36"></a><span class="st">-   bool operator&lt; (const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb145-37"><a href="#cb145-37"></a><span class="st">-                   const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;</span></span>
<span id="cb145-38"><a href="#cb145-38"></a><span class="st">- template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-39"><a href="#cb145-39"></a><span class="st">-   bool operator&lt; (const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb145-40"><a href="#cb145-40"></a><span class="st">-                   const charT* rhs);</span></span>
<span id="cb145-41"><a href="#cb145-41"></a><span class="st">- template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-42"><a href="#cb145-42"></a><span class="st">-   bool operator&lt; (const charT* lhs,</span></span>
<span id="cb145-43"><a href="#cb145-43"></a><span class="st">-                   const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);</span></span>
<span id="cb145-44"><a href="#cb145-44"></a><span class="st">- template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-45"><a href="#cb145-45"></a><span class="st">-   bool operator&gt; (const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb145-46"><a href="#cb145-46"></a><span class="st">-                   const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;</span></span>
<span id="cb145-47"><a href="#cb145-47"></a><span class="st">- template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-48"><a href="#cb145-48"></a><span class="st">-   bool operator&gt; (const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb145-49"><a href="#cb145-49"></a><span class="st">-                   const charT* rhs);</span></span>
<span id="cb145-50"><a href="#cb145-50"></a><span class="st">- template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-51"><a href="#cb145-51"></a><span class="st">-   bool operator&gt; (const charT* lhs,</span></span>
<span id="cb145-52"><a href="#cb145-52"></a><span class="st">-                   const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);</span></span>
<span id="cb145-53"><a href="#cb145-53"></a></span>
<span id="cb145-54"><a href="#cb145-54"></a><span class="st">- template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-55"><a href="#cb145-55"></a><span class="st">-   bool operator&lt;=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb145-56"><a href="#cb145-56"></a><span class="st">-                   const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;</span></span>
<span id="cb145-57"><a href="#cb145-57"></a><span class="st">- template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-58"><a href="#cb145-58"></a><span class="st">-   bool operator&lt;=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb145-59"><a href="#cb145-59"></a><span class="st">-                   const charT* rhs);</span></span>
<span id="cb145-60"><a href="#cb145-60"></a><span class="st">- template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-61"><a href="#cb145-61"></a><span class="st">-   bool operator&lt;=(const charT* lhs,</span></span>
<span id="cb145-62"><a href="#cb145-62"></a><span class="st">-                   const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);</span></span>
<span id="cb145-63"><a href="#cb145-63"></a><span class="st">- template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-64"><a href="#cb145-64"></a><span class="st">-   bool operator&gt;=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb145-65"><a href="#cb145-65"></a><span class="st">-                   const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;</span></span>
<span id="cb145-66"><a href="#cb145-66"></a><span class="st">- template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-67"><a href="#cb145-67"></a><span class="st">-   bool operator&gt;=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb145-68"><a href="#cb145-68"></a><span class="st">-                   const charT* rhs);</span></span>
<span id="cb145-69"><a href="#cb145-69"></a><span class="st">- template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-70"><a href="#cb145-70"></a><span class="st">-   bool operator&gt;=(const charT* lhs,</span></span>
<span id="cb145-71"><a href="#cb145-71"></a><span class="st">-                   const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);</span></span>
<span id="cb145-72"><a href="#cb145-72"></a></span>
<span id="cb145-73"><a href="#cb145-73"></a><span class="va">+ template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-74"><a href="#cb145-74"></a><span class="va">+   @_see below_@ operator&lt;=&gt;(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb145-75"><a href="#cb145-75"></a><span class="va">+                         const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;</span></span>
<span id="cb145-76"><a href="#cb145-76"></a><span class="va">+ template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb145-77"><a href="#cb145-77"></a><span class="va">+   @_see below_@ operator&lt;=&gt;(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb145-78"><a href="#cb145-78"></a><span class="va">+                         const charT* rhs) noexcept;</span></span>
<span id="cb145-79"><a href="#cb145-79"></a></span>
<span id="cb145-80"><a href="#cb145-80"></a></span>
<span id="cb145-81"><a href="#cb145-81"></a>  [...]</span>
<span id="cb145-82"><a href="#cb145-82"></a>}  </span></code></pre></div>
</blockquote>
<p>Change 21.3.3.2 [string.cmp]:</p>
<blockquote>
<div class="sourceCode" id="cb146"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb146-1"><a href="#cb146-1"></a>   template&lt;class charT, class traits, class Allocator&gt;</span>
<span id="cb146-2"><a href="#cb146-2"></a>     bool operator==(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span>
<span id="cb146-3"><a href="#cb146-3"></a>                     const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;</span>
<span id="cb146-4"><a href="#cb146-4"></a><span class="st">-  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-5"><a href="#cb146-5"></a><span class="st">-    bool operator==(const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);</span></span>
<span id="cb146-6"><a href="#cb146-6"></a>   template&lt;class charT, class traits, class Allocator&gt;</span>
<span id="cb146-7"><a href="#cb146-7"></a>     bool operator==(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const charT* rhs);</span>
<span id="cb146-8"><a href="#cb146-8"></a>   </span>
<span id="cb146-9"><a href="#cb146-9"></a><span class="st">-  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-10"><a href="#cb146-10"></a><span class="st">-    bool operator!=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb146-11"><a href="#cb146-11"></a><span class="st">-                    const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;</span></span>
<span id="cb146-12"><a href="#cb146-12"></a><span class="st">-  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-13"><a href="#cb146-13"></a><span class="st">-    bool operator!=(const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);</span></span>
<span id="cb146-14"><a href="#cb146-14"></a><span class="st">-  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-15"><a href="#cb146-15"></a><span class="st">-    bool operator!=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const charT* rhs);</span></span>
<span id="cb146-16"><a href="#cb146-16"></a>   </span>
<span id="cb146-17"><a href="#cb146-17"></a><span class="st">-  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-18"><a href="#cb146-18"></a><span class="st">-    bool operator&lt; (const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb146-19"><a href="#cb146-19"></a><span class="st">-                    const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;</span></span>
<span id="cb146-20"><a href="#cb146-20"></a><span class="st">-  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-21"><a href="#cb146-21"></a><span class="st">-    bool operator&lt; (const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);</span></span>
<span id="cb146-22"><a href="#cb146-22"></a><span class="st">-  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-23"><a href="#cb146-23"></a><span class="st">-    bool operator&lt; (const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const charT* rhs);</span></span>
<span id="cb146-24"><a href="#cb146-24"></a>   </span>
<span id="cb146-25"><a href="#cb146-25"></a><span class="st">-  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-26"><a href="#cb146-26"></a><span class="st">-    bool operator&gt; (const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb146-27"><a href="#cb146-27"></a><span class="st">-                    const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;</span></span>
<span id="cb146-28"><a href="#cb146-28"></a><span class="st">-  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-29"><a href="#cb146-29"></a><span class="st">-    bool operator&gt; (const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);</span></span>
<span id="cb146-30"><a href="#cb146-30"></a><span class="st">-  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-31"><a href="#cb146-31"></a><span class="st">-    bool operator&gt; (const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const charT* rhs);</span></span>
<span id="cb146-32"><a href="#cb146-32"></a>   </span>
<span id="cb146-33"><a href="#cb146-33"></a><span class="st">-  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-34"><a href="#cb146-34"></a><span class="st">-    bool operator&lt;=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb146-35"><a href="#cb146-35"></a>                     const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;</span>
<span id="cb146-36"><a href="#cb146-36"></a><span class="st">-  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-37"><a href="#cb146-37"></a><span class="st">-    bool operator&lt;=(const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);</span></span>
<span id="cb146-38"><a href="#cb146-38"></a><span class="st">-  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-39"><a href="#cb146-39"></a><span class="st">-    bool operator&lt;=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const charT* rhs);</span></span>
<span id="cb146-40"><a href="#cb146-40"></a>   </span>
<span id="cb146-41"><a href="#cb146-41"></a><span class="st">-  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-42"><a href="#cb146-42"></a><span class="st">-    bool operator&gt;=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb146-43"><a href="#cb146-43"></a><span class="st">-                    const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;</span></span>
<span id="cb146-44"><a href="#cb146-44"></a><span class="st">-  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-45"><a href="#cb146-45"></a><span class="st">-    bool operator&gt;=(const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs);</span></span>
<span id="cb146-46"><a href="#cb146-46"></a><span class="st">-  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-47"><a href="#cb146-47"></a><span class="st">-    bool operator&gt;=(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs, const charT* rhs);</span></span>
<span id="cb146-48"><a href="#cb146-48"></a></span>
<span id="cb146-49"><a href="#cb146-49"></a><span class="va">+  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-50"><a href="#cb146-50"></a><span class="va">+    @_see below_@ operator&lt;=&gt;(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb146-51"><a href="#cb146-51"></a><span class="va">+                          const basic_string&lt;charT, traits, Allocator&gt;&amp; rhs) noexcept;</span></span>
<span id="cb146-52"><a href="#cb146-52"></a><span class="va">+  template&lt;class charT, class traits, class Allocator&gt;</span></span>
<span id="cb146-53"><a href="#cb146-53"></a><span class="va">+    @_see below_@ operator&lt;=&gt;(const basic_string&lt;charT, traits, Allocator&gt;&amp; lhs,</span></span>
<span id="cb146-54"><a href="#cb146-54"></a><span class="va">+                          const charT* rhs) noexcept;</span></span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Effects</em>: Let <code class="sourceCode cpp">op</code> be the operator. Equivalent to:</p>
<blockquote>
<div class="sourceCode" id="cb147"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb147-1"><a href="#cb147-1"></a><span class="cf">return</span> basic_string_view<span class="op">&lt;</span>charT, traits<span class="op">&gt;(</span>lhs<span class="op">)</span> @_op_@ basic_string_view<span class="op">&lt;</span>charT, traits<span class="op">&gt;(</span>rhs<span class="op">)</span>;</span></code></pre></div>
</blockquote>
</blockquote>
<p>Change 21.4.1 [string.view.synop]:</p>
<blockquote>
<div class="sourceCode" id="cb148"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb148-1"><a href="#cb148-1"></a>namespace std {</span>
<span id="cb148-2"><a href="#cb148-2"></a>  // [string.view.template], class template basic_string_view</span>
<span id="cb148-3"><a href="#cb148-3"></a>  template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;</span>
<span id="cb148-4"><a href="#cb148-4"></a>  class basic_string_view;</span>
<span id="cb148-5"><a href="#cb148-5"></a></span>
<span id="cb148-6"><a href="#cb148-6"></a>  // [string.view.comparison], non-member comparison functions</span>
<span id="cb148-7"><a href="#cb148-7"></a>  template&lt;class charT, class traits&gt;</span>
<span id="cb148-8"><a href="#cb148-8"></a>    constexpr bool operator==(basic_string_view&lt;charT, traits&gt; x,</span>
<span id="cb148-9"><a href="#cb148-9"></a>                              basic_string_view&lt;charT, traits&gt; y) noexcept;</span>
<span id="cb148-10"><a href="#cb148-10"></a><span class="st">- template&lt;class charT, class traits&gt;</span></span>
<span id="cb148-11"><a href="#cb148-11"></a><span class="st">-   constexpr bool operator!=(basic_string_view&lt;charT, traits&gt; x,</span></span>
<span id="cb148-12"><a href="#cb148-12"></a><span class="st">-                             basic_string_view&lt;charT, traits&gt; y) noexcept;</span></span>
<span id="cb148-13"><a href="#cb148-13"></a><span class="st">- template&lt;class charT, class traits&gt;</span></span>
<span id="cb148-14"><a href="#cb148-14"></a><span class="st">-   constexpr bool operator&lt; (basic_string_view&lt;charT, traits&gt; x,</span></span>
<span id="cb148-15"><a href="#cb148-15"></a><span class="st">-                             basic_string_view&lt;charT, traits&gt; y) noexcept;</span></span>
<span id="cb148-16"><a href="#cb148-16"></a><span class="st">- template&lt;class charT, class traits&gt;</span></span>
<span id="cb148-17"><a href="#cb148-17"></a><span class="st">-   constexpr bool operator&gt; (basic_string_view&lt;charT, traits&gt; x,</span></span>
<span id="cb148-18"><a href="#cb148-18"></a><span class="st">-                             basic_string_view&lt;charT, traits&gt; y) noexcept;</span></span>
<span id="cb148-19"><a href="#cb148-19"></a><span class="st">- template&lt;class charT, class traits&gt;</span></span>
<span id="cb148-20"><a href="#cb148-20"></a><span class="st">-   constexpr bool operator&lt;=(basic_string_view&lt;charT, traits&gt; x,</span></span>
<span id="cb148-21"><a href="#cb148-21"></a><span class="st">-                             basic_string_view&lt;charT, traits&gt; y) noexcept;</span></span>
<span id="cb148-22"><a href="#cb148-22"></a><span class="st">- template&lt;class charT, class traits&gt;</span></span>
<span id="cb148-23"><a href="#cb148-23"></a><span class="st">-   constexpr bool operator&gt;=(basic_string_view&lt;charT, traits&gt; x,</span></span>
<span id="cb148-24"><a href="#cb148-24"></a><span class="st">-                             basic_string_view&lt;charT, traits&gt; y) noexcept;</span></span>
<span id="cb148-25"><a href="#cb148-25"></a><span class="va">+ template&lt;class charT, class traits&gt;</span></span>
<span id="cb148-26"><a href="#cb148-26"></a><span class="va">+   constexpr @_see below_@ operator&lt;=&gt;(basic_string_view&lt;charT, traits&gt; x,</span></span>
<span id="cb148-27"><a href="#cb148-27"></a><span class="va">+                                   basic_string_view&lt;charT, traits&gt; y) noexcept;</span></span>
<span id="cb148-28"><a href="#cb148-28"></a></span>
<span id="cb148-29"><a href="#cb148-29"></a>  // see [string.view.comparison], sufficient additional overloads of comparison functions</span>
<span id="cb148-30"><a href="#cb148-30"></a></span>
<span id="cb148-31"><a href="#cb148-31"></a>  [...]</span>
<span id="cb148-32"><a href="#cb148-32"></a>}</span></code></pre></div>
</blockquote>
<p>Add <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> to the table at the beginning of 21.4.3 [string.view.comparisons]:</p>
<blockquote>
<table>
<tr>
<th>
Expression
</th>
<th>
Equivalent to
</th>
</tr>
<tr>
<td>
<code class="sourceCode cpp">t <span class="op">==</span> sv</code>
</td>
<td>
<code class="sourceCode cpp">S<span class="op">(</span>t<span class="op">)</span> <span class="op">==</span> sv</code>
</td>
</tr>
<tr>
<td>
[…]
</td>
<td>
[…]
</td>
</tr>
<tr>
<td>
<span class="addu"><code>t &lt;=&gt; sv</code></span>
</td>
<td>
<span class="addu"><code>S(t) &lt;=&gt; sv</code></span>
</td>
</tr>
<tr>
<td>
<span class="addu"><code>sv &lt;=&gt; t</code></span>
</td>
<td>
<span class="addu"><code>sv &lt;=&gt; S(t)</code></span>
</td>
</tr>
</table>
</blockquote>
<p>Change the rest of 21.4.3 [string.view.comparisons]:</p>
<blockquote>
<div class="sourceCode" id="cb149"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb149-1"><a href="#cb149-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> charT, <span class="kw">class</span> traits<span class="op">&gt;</span></span>
<span id="cb149-2"><a href="#cb149-2"></a>  <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>basic_string_view<span class="op">&lt;</span>charT, traits<span class="op">&gt;</span> lhs,</span>
<span id="cb149-3"><a href="#cb149-3"></a>                            basic_string_view<span class="op">&lt;</span>charT, traits<span class="op">&gt;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>compare<span class="op">(</span>rhs<span class="op">)</span> <span class="op">==</span> <span class="dv">0</span></code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class charT, class traits&gt;
  constexpr bool operator!=(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>compare<span class="op">(</span>rhs<span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span></code>.</p>
<pre><code>template&lt;class charT, class traits&gt;
  constexpr bool operator&lt;(basic_string_view&lt;charT, traits&gt; lhs,
                           basic_string_view&lt;charT, traits&gt; rhs) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>compare<span class="op">(</span>rhs<span class="op">)</span> <span class="op">&lt;</span> <span class="dv">0</span></code>.</p>
<pre><code>template&lt;class charT, class traits&gt;
  constexpr bool operator&gt;(basic_string_view&lt;charT, traits&gt; lhs,
                           basic_string_view&lt;charT, traits&gt; rhs) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>compare<span class="op">(</span>rhs<span class="op">)</span> <span class="op">&gt;</span> <span class="dv">0</span></code>.</p>
<pre><code>template&lt;class charT, class traits&gt;
  constexpr bool operator&lt;=(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>compare<span class="op">(</span>rhs<span class="op">)</span> <span class="op">&lt;=</span> <span class="dv">0</span></code>.</p>
<pre><code>template&lt;class charT, class traits&gt;
  constexpr bool operator&gt;=(basic_string_view&lt;charT, traits&gt; lhs,
                            basic_string_view&lt;charT, traits&gt; rhs) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>compare<span class="op">(</span>rhs<span class="op">)</span> <span class="op">&gt;=</span> <span class="dv">0</span></code>.</p>
</div>
<div class="addu">
<pre><code>template&lt;class charT, class traits&gt;
  constexpr @_see below_@ operator&lt;=&gt;(basic_string_view&lt;charT, traits&gt; lhs,
                                  basic_string_view&lt;charT, traits&gt; rhs) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">8</a></span> Let <code class="sourceCode cpp">R</code> denote the type <code class="sourceCode cpp">traits<span class="op">::</span>comparison_category</code> if it exists, otherwise <code class="sourceCode cpp">R</code> is <code class="sourceCode cpp">weak_ordering</code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">9</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="kw">static_cast</span><span class="op">&lt;</span>R<span class="op">&gt;(</span>lhs<span class="op">.</span>compare<span class="op">(</span>rhs<span class="op">)</span> <span class="op">&lt;=&gt;</span> <span class="dv">0</span><span class="op">)</span></code>.</p>
</div>
</blockquote>
<h2 id="clause-22-containers-library"><span class="header-section-number">5.7</span> Clause 22: Containers library<a href="#clause-22-containers-library" class="self-link"></a></h2>
<p><code class="sourceCode cpp">array</code>’s comparisons move to be hidden friends to allow for use as non-type template parameters. All the other containers drop <code class="sourceCode cpp"><span class="op">!=</span></code> and, if they have relational operators, those get replaced with a <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code>.</p>
<p>Add to 22.2.1 [container.requirements.general]/4:</p>
<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> In Tables 62, 63, and 64 <code class="sourceCode cpp">X</code> denotes a container class containing objects of type <code class="sourceCode cpp">T</code>, <code class="sourceCode cpp">a</code> and <code class="sourceCode cpp">b</code> denote values of type <code class="sourceCode cpp">X</code>, <span class="addu"><code class="sourceCode cpp">i</code> and <code class="sourceCode cpp">j</code> denote values of type (possibly-const) <code class="sourceCode cpp">X<span class="op">::</span>iterator</code></span>, <code class="sourceCode cpp">u</code> denotes an identifier, <code class="sourceCode cpp">r</code> denotes a non-const value of type <code class="sourceCode cpp">X</code>, and <code class="sourceCode cpp">rv</code> denotes a non-const rvalue of type <code class="sourceCode cpp">X</code>.</p>
</blockquote>
<p>Add a row to 22.2.1, Table 62 [container.req]:</p>
<blockquote>
<table>
<tr>
<th>
Expression
</th>
<th>
Return type
</th>
<th>
Operational<br />semantics
</th>
<th>
Assertion/note<br />pre-/post-condition
</th>
<th>
Complexity
</th>
</tr>
<tr>
<td>
<span class="addu"><code class="sourceCode cpp">i <span class="op">&lt;=&gt;</span> j</code></span>
</td>
<td>
<span class="addu"><code class="sourceCode cpp">strong_ordering</code> if <code class="sourceCode cpp">X<span class="op">::</span>iterator</code> meets the random access iterator requirements, otherwise <code class="sourceCode cpp">strong_equality</code></span>
</td>
<td>
</td>
<td>
</td>
<td>
<span class="addu">constant</span>
</td>
</tr>
</table>
</blockquote>
<p>Add <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> to the requirements in 22.2.1 [container.requirements.general]/7:</p>
<blockquote>
<p>In the expressions</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb156-1"><a href="#cb156-1"></a>  i == j</span>
<span id="cb156-2"><a href="#cb156-2"></a>  i != j</span>
<span id="cb156-3"><a href="#cb156-3"></a>  i &lt; j</span>
<span id="cb156-4"><a href="#cb156-4"></a>  i &lt;= j</span>
<span id="cb156-5"><a href="#cb156-5"></a>  i &gt;= j</span>
<span id="cb156-6"><a href="#cb156-6"></a>  i &gt; j</span>
<span id="cb156-7"><a href="#cb156-7"></a><span class="va">+ i &lt;=&gt; j</span></span>
<span id="cb156-8"><a href="#cb156-8"></a>  i - j</span></code></pre></div>
<p>where <code class="sourceCode cpp">i</code> and <code class="sourceCode cpp">j</code> denote objects of a container’s iterator type, either or both may be replaced by an object of the container’s <code class="sourceCode cpp">const_iterator</code> type referring to the same element with no change in semantics.</p>
</blockquote>
<p>Replace 22.2.1 [container.requirements.general], Table 64 [container.opt] to refer to <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> using <em><code class="sourceCode default">synth-3way</code></em> instead of <code class="sourceCode cpp"><span class="op">&lt;</span></code>.</p>
<blockquote>
<p>Table 64 lists operations that are provided for some types of containers but not others. Those containers for which the listed operations are provided shall implement the semantics described in Table 64 unless otherwise stated. If the iterators passed to <span class="rm" style="color: #bf0303"><del><span><code class="sourceCode cpp">lexicographical_compare</code></span></del></span> <span class="addu"><code class="sourceCode cpp">lexicographical_compare_three_way</code></span> satisfy the constexpr iterator requirements ([iterator.requirements.general]) then the operations described in Table 64 are implemented by constexpr functions.</p>
<table>
<tr>
<th>
Expression
</th>
<th>
Return type
</th>
<th>
Operational<br />semantics
</th>
<th>
Assertion/note<br />pre-/post-condition
</th>
<th>
Complexity
</th>
</tr>
<tr>
<td>
<span class="rm" style="color: #bf0303"><del><span><code class="sourceCode cpp">a <span class="op">&lt;</span> b</code></span></del></span>
</td>
<td>
<span class="rm" style="color: #bf0303"><del>convertible to <span><code class="sourceCode default">bool</code></span></del></span>
</td>
<td>
<div class="rm" style="color: #bf0303">

<pre><code>lexicographical_compare(
    a.begin(), a.end(),
    b.begin(), b.end())</code></pre>

</div>
</td>
<td>
<span class="rm" style="color: #bf0303"><del><em>Expects</em>: <span><code class="sourceCode cpp"><span class="op">&lt;</span></code></span> is defined for values of type (possibly const) <span><code class="sourceCode cpp">T</code></span>. <span><code class="sourceCode cpp"><span class="op">&lt;</span></code></span> is a total ordering relationship.</del></span>
</td>
<td>
<span class="rm" style="color: #bf0303"><del>linear</del></span>
</td>
</tr>
<tr>
<td>
<span class="rm" style="color: #bf0303"><del><span><code class="sourceCode cpp">a <span class="op">&gt;</span> b</code></span></del></span>
</td>
<td>
<span class="rm" style="color: #bf0303"><del>convertible to <span><code class="sourceCode default">bool</code></span></del></span>
</td>
<td>
<span class="rm" style="color: #bf0303"><del><span><code class="sourceCode cpp">b <span class="op">&lt;</span> a</code></span></del></span>
</td>
<td>
</td>
<td>
<span class="rm" style="color: #bf0303"><del>linear</del></span>
</td>
</tr>
<tr>
<td>
<span class="rm" style="color: #bf0303"><del><span><code class="sourceCode cpp">a <span class="op">&lt;=</span> b</code></span></del></span>
</td>
<td>
<span class="rm" style="color: #bf0303"><del>convertible to <span><code class="sourceCode default">bool</code></span></del></span>
</td>
<td>
<span class="rm" style="color: #bf0303"><del><span><code class="sourceCode cpp"><span class="op">!(</span>a <span class="op">&gt;</span> b<span class="op">)</span></code></span></del></span>
</td>
<td>
</td>
<td>
<span class="rm" style="color: #bf0303"><del>linear</del></span>
</td>
</tr>
<tr>
<td>
<span class="rm" style="color: #bf0303"><del><span><code class="sourceCode cpp">a <span class="op">&gt;=</span> b</code></span></del></span>
</td>
<td>
<span class="rm" style="color: #bf0303"><del>convertible to <span><code class="sourceCode default">bool</code></span></del></span>
</td>
<td>
<span class="rm" style="color: #bf0303"><del><span><code class="sourceCode cpp"><span class="op">!(</span>a <span class="op">&lt;</span> b<span class="op">)</span></code></span></del></span>
</td>
<td>
</td>
<td>
<span class="rm" style="color: #bf0303"><del>linear</del></span>
</td>
</tr>
<tr>
<td>
<span class="addu"><code class="sourceCode cpp">a <span class="op">&lt;=&gt;</span> b</code></span>
</td>
<td>
<span class="addu"><em><code class="sourceCode default">synth-3way-result</code></em><code class="sourceCode cpp"><span class="op">&lt;</span>value_type<span class="op">&gt;</span></code></span>
</td>
<td>
<div class="addu">
<pre><code>lexicographical_compare_three_way(
    a.begin(), a.end(),
    b.begin(), b.end(),
    @_synth-3way_@)</code></pre>
</div>
</td>
<td>
<span class="addu"><em>Expects</em>: Either <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> is defined for values of type (possibly const) <code class="sourceCode cpp">T</code>, or <code class="sourceCode cpp"><span class="op">&lt;</span></code> is defined for values of type (possibly const) <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp"><span class="op">&lt;</span></code> is a total ordering relationship.</span>
</td>
<td>
<span class="addu">linear</span>
</td>
</tr>
</table>
</blockquote>
<p>Change 22.3.2 [array.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb159"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb159-1"><a href="#cb159-1"></a>#include &lt;initializer_list&gt;</span>
<span id="cb159-2"><a href="#cb159-2"></a></span>
<span id="cb159-3"><a href="#cb159-3"></a>namespace std {</span>
<span id="cb159-4"><a href="#cb159-4"></a>  // [array], class template array</span>
<span id="cb159-5"><a href="#cb159-5"></a>  template&lt;class T, size_t N&gt; struct array;</span>
<span id="cb159-6"><a href="#cb159-6"></a></span>
<span id="cb159-7"><a href="#cb159-7"></a><span class="st">- template&lt;class T, size_t N&gt;</span></span>
<span id="cb159-8"><a href="#cb159-8"></a><span class="st">-   constexpr bool operator==(const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);</span></span>
<span id="cb159-9"><a href="#cb159-9"></a><span class="st">- template&lt;class T, size_t N&gt;</span></span>
<span id="cb159-10"><a href="#cb159-10"></a><span class="st">-   constexpr bool operator!=(const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);</span></span>
<span id="cb159-11"><a href="#cb159-11"></a><span class="st">- template&lt;class T, size_t N&gt;</span></span>
<span id="cb159-12"><a href="#cb159-12"></a><span class="st">-   constexpr bool operator&lt; (const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);</span></span>
<span id="cb159-13"><a href="#cb159-13"></a><span class="st">- template&lt;class T, size_t N&gt;</span></span>
<span id="cb159-14"><a href="#cb159-14"></a><span class="st">-   constexpr bool operator&gt; (const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);</span></span>
<span id="cb159-15"><a href="#cb159-15"></a><span class="st">- template&lt;class T, size_t N&gt;</span></span>
<span id="cb159-16"><a href="#cb159-16"></a><span class="st">-   constexpr bool operator&lt;=(const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);</span></span>
<span id="cb159-17"><a href="#cb159-17"></a><span class="st">- template&lt;class T, size_t N&gt;</span></span>
<span id="cb159-18"><a href="#cb159-18"></a><span class="st">-   constexpr bool operator&gt;=(const array&lt;T, N&gt;&amp; x, const array&lt;T, N&gt;&amp; y);</span></span>
<span id="cb159-19"><a href="#cb159-19"></a>  template&lt;class T, size_t N&gt;</span>
<span id="cb159-20"><a href="#cb159-20"></a>    constexpr void swap(array&lt;T, N&gt;&amp; x, array&lt;T, N&gt;&amp; y) noexcept(noexcept(x.swap(y)));</span>
<span id="cb159-21"><a href="#cb159-21"></a>  [...]</span>
<span id="cb159-22"><a href="#cb159-22"></a>}</span></code></pre></div>
</blockquote>
<p>Change 22.3.3 [deque.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb160"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb160-1"><a href="#cb160-1"></a>#include &lt;initializer_list&gt;</span>
<span id="cb160-2"><a href="#cb160-2"></a></span>
<span id="cb160-3"><a href="#cb160-3"></a>namespace std {</span>
<span id="cb160-4"><a href="#cb160-4"></a>  // [deque], class template deque</span>
<span id="cb160-5"><a href="#cb160-5"></a>  template&lt;class T, class Allocator = allocator&lt;T&gt;&gt; class deque;</span>
<span id="cb160-6"><a href="#cb160-6"></a></span>
<span id="cb160-7"><a href="#cb160-7"></a>  template&lt;class T, class Allocator&gt;</span>
<span id="cb160-8"><a href="#cb160-8"></a>    bool operator==(const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);</span>
<span id="cb160-9"><a href="#cb160-9"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb160-10"><a href="#cb160-10"></a><span class="st">-   bool operator!=(const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb160-11"><a href="#cb160-11"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb160-12"><a href="#cb160-12"></a><span class="st">-   bool operator&lt; (const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb160-13"><a href="#cb160-13"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb160-14"><a href="#cb160-14"></a><span class="st">-   bool operator&gt; (const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb160-15"><a href="#cb160-15"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb160-16"><a href="#cb160-16"></a><span class="st">-   bool operator&lt;=(const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb160-17"><a href="#cb160-17"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb160-18"><a href="#cb160-18"></a><span class="st">-   bool operator&gt;=(const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb160-19"><a href="#cb160-19"></a><span class="va">+ template&lt;class T, class Allocator&gt;</span></span>
<span id="cb160-20"><a href="#cb160-20"></a><span class="va">+   @_synth-3way-result_@&lt;T&gt; operator&lt;=&gt;(const deque&lt;T, Allocator&gt;&amp; x, const deque&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb160-21"><a href="#cb160-21"></a></span>
<span id="cb160-22"><a href="#cb160-22"></a>  [...]</span>
<span id="cb160-23"><a href="#cb160-23"></a>}</span></code></pre></div>
</blockquote>
<p>Change 22.3.4 [forward.list.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb161"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb161-1"><a href="#cb161-1"></a>#include &lt;initializer_list&gt;</span>
<span id="cb161-2"><a href="#cb161-2"></a></span>
<span id="cb161-3"><a href="#cb161-3"></a>namespace std {</span>
<span id="cb161-4"><a href="#cb161-4"></a>  // [forwardlist], class template forward_list</span>
<span id="cb161-5"><a href="#cb161-5"></a>  template&lt;class T, class Allocator = allocator&lt;T&gt;&gt; class forward_list;</span>
<span id="cb161-6"><a href="#cb161-6"></a></span>
<span id="cb161-7"><a href="#cb161-7"></a>  template&lt;class T, class Allocator&gt;</span>
<span id="cb161-8"><a href="#cb161-8"></a>    bool operator==(const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);</span>
<span id="cb161-9"><a href="#cb161-9"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb161-10"><a href="#cb161-10"></a><span class="st">-   bool operator!=(const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb161-11"><a href="#cb161-11"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb161-12"><a href="#cb161-12"></a><span class="st">-   bool operator&lt; (const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb161-13"><a href="#cb161-13"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb161-14"><a href="#cb161-14"></a><span class="st">-   bool operator&gt; (const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb161-15"><a href="#cb161-15"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb161-16"><a href="#cb161-16"></a><span class="st">-   bool operator&lt;=(const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb161-17"><a href="#cb161-17"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb161-18"><a href="#cb161-18"></a><span class="st">-   bool operator&gt;=(const forward_list&lt;T, Allocator&gt;&amp; x, const forward_list&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb161-19"><a href="#cb161-19"></a><span class="va">+ template&lt;class T, class Allocator&gt;</span></span>
<span id="cb161-20"><a href="#cb161-20"></a><span class="va">+   @_synth-3way-result_@&lt;T&gt; operator&lt;=&gt;(const forward_list&lt;T, Allocator&gt;&amp; x,</span></span>
<span id="cb161-21"><a href="#cb161-21"></a><span class="va">+                                    const forward_list&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb161-22"><a href="#cb161-22"></a></span>
<span id="cb161-23"><a href="#cb161-23"></a>  [...]</span>
<span id="cb161-24"><a href="#cb161-24"></a>}</span></code></pre></div>
</blockquote>
<p>Change 22.3.5 [list.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb162"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb162-1"><a href="#cb162-1"></a>#include &lt;initializer_list&gt;</span>
<span id="cb162-2"><a href="#cb162-2"></a></span>
<span id="cb162-3"><a href="#cb162-3"></a>namespace std {</span>
<span id="cb162-4"><a href="#cb162-4"></a>  // [list], class template list</span>
<span id="cb162-5"><a href="#cb162-5"></a>  template&lt;class T, class Allocator = allocator&lt;T&gt;&gt; class list;</span>
<span id="cb162-6"><a href="#cb162-6"></a></span>
<span id="cb162-7"><a href="#cb162-7"></a>  template&lt;class T, class Allocator&gt;</span>
<span id="cb162-8"><a href="#cb162-8"></a>    bool operator==(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);</span>
<span id="cb162-9"><a href="#cb162-9"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb162-10"><a href="#cb162-10"></a><span class="st">-   bool operator!=(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb162-11"><a href="#cb162-11"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb162-12"><a href="#cb162-12"></a><span class="st">-   bool operator&lt; (const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb162-13"><a href="#cb162-13"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb162-14"><a href="#cb162-14"></a><span class="st">-   bool operator&gt; (const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb162-15"><a href="#cb162-15"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb162-16"><a href="#cb162-16"></a><span class="st">-   bool operator&lt;=(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb162-17"><a href="#cb162-17"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb162-18"><a href="#cb162-18"></a><span class="st">-   bool operator&gt;=(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb162-19"><a href="#cb162-19"></a><span class="va">+ template&lt;class T, class Allocator&gt;</span></span>
<span id="cb162-20"><a href="#cb162-20"></a><span class="va">+   @_synth-3way-result_@&lt;T&gt; operator&lt;=&gt;(const list&lt;T, Allocator&gt;&amp; x, const list&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb162-21"><a href="#cb162-21"></a>    </span>
<span id="cb162-22"><a href="#cb162-22"></a>  [...]</span>
<span id="cb162-23"><a href="#cb162-23"></a>}</span></code></pre></div>
</blockquote>
<p>Change 22.3.6 [vector.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb163"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb163-1"><a href="#cb163-1"></a>#include &lt;initializer_list&gt;</span>
<span id="cb163-2"><a href="#cb163-2"></a></span>
<span id="cb163-3"><a href="#cb163-3"></a>namespace std {</span>
<span id="cb163-4"><a href="#cb163-4"></a>  // [vector], class template vector</span>
<span id="cb163-5"><a href="#cb163-5"></a>  template&lt;class T, class Allocator = allocator&lt;T&gt;&gt; class vector;</span>
<span id="cb163-6"><a href="#cb163-6"></a></span>
<span id="cb163-7"><a href="#cb163-7"></a>  template&lt;class T, class Allocator&gt;</span>
<span id="cb163-8"><a href="#cb163-8"></a>    bool operator==(const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);</span>
<span id="cb163-9"><a href="#cb163-9"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb163-10"><a href="#cb163-10"></a><span class="st">-   bool operator!=(const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb163-11"><a href="#cb163-11"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb163-12"><a href="#cb163-12"></a><span class="st">-   bool operator&lt; (const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb163-13"><a href="#cb163-13"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb163-14"><a href="#cb163-14"></a><span class="st">-   bool operator&gt; (const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb163-15"><a href="#cb163-15"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb163-16"><a href="#cb163-16"></a><span class="st">-   bool operator&lt;=(const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb163-17"><a href="#cb163-17"></a><span class="st">- template&lt;class T, class Allocator&gt;</span></span>
<span id="cb163-18"><a href="#cb163-18"></a><span class="st">-   bool operator&gt;=(const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb163-19"><a href="#cb163-19"></a><span class="va">+ template&lt;class T, class Allocator&gt;</span></span>
<span id="cb163-20"><a href="#cb163-20"></a><span class="va">+   @_synth-3way-result_@&lt;T&gt; operator&lt;=&gt;(const vector&lt;T, Allocator&gt;&amp; x, const vector&lt;T, Allocator&gt;&amp; y);</span></span>
<span id="cb163-21"><a href="#cb163-21"></a></span>
<span id="cb163-22"><a href="#cb163-22"></a>  [...]</span>
<span id="cb163-23"><a href="#cb163-23"></a>}</span></code></pre></div>
</blockquote>
<p>Change 22.3.7.1 [array.overview]:</p>
<blockquote>
<div class="sourceCode" id="cb164"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb164-1"><a href="#cb164-1"></a>namespace std {</span>
<span id="cb164-2"><a href="#cb164-2"></a>  template&lt;class T, size_t N&gt;</span>
<span id="cb164-3"><a href="#cb164-3"></a>  struct array {</span>
<span id="cb164-4"><a href="#cb164-4"></a>    [...]</span>
<span id="cb164-5"><a href="#cb164-5"></a></span>
<span id="cb164-6"><a href="#cb164-6"></a>    constexpr T *       data() noexcept;</span>
<span id="cb164-7"><a href="#cb164-7"></a>    constexpr const T * data() const noexcept;</span>
<span id="cb164-8"><a href="#cb164-8"></a>    </span>
<span id="cb164-9"><a href="#cb164-9"></a><span class="va">+   friend constexpr bool operator==(const array&amp;, const array&amp;) = default;</span></span>
<span id="cb164-10"><a href="#cb164-10"></a><span class="va">+   friend constexpr @_synth-3way-result_@&lt;value_type&gt;</span></span>
<span id="cb164-11"><a href="#cb164-11"></a><span class="va">+     operator&lt;=&gt;(const array&amp;, const array&amp;);</span></span>
<span id="cb164-12"><a href="#cb164-12"></a>  };</span>
<span id="cb164-13"><a href="#cb164-13"></a></span>
<span id="cb164-14"><a href="#cb164-14"></a>  template&lt;class T, class... U&gt;</span>
<span id="cb164-15"><a href="#cb164-15"></a>    array(T, U...) -&gt; array&lt;T, 1 + sizeof...(U)&gt;;</span>
<span id="cb164-16"><a href="#cb164-16"></a>}</span></code></pre></div>
</blockquote>
<p>Change 22.4.2 [associative.map.syn]. Instead of writing out the value type of <code class="sourceCode cpp">pair<span class="op">&lt;</span><span class="kw">const</span> Key, T<span class="op">&gt;</span></code>, I’m using <em><code class="sourceCode default">see above</code></em> for the return types of all the <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code>s.</p>
<blockquote>
<div class="sourceCode" id="cb165"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb165-1"><a href="#cb165-1"></a>#include &lt;initializer_list&gt;</span>
<span id="cb165-2"><a href="#cb165-2"></a></span>
<span id="cb165-3"><a href="#cb165-3"></a>namespace std {</span>
<span id="cb165-4"><a href="#cb165-4"></a>  // [map], class template map</span>
<span id="cb165-5"><a href="#cb165-5"></a>  template&lt;class Key, class T, class Compare = less&lt;Key&gt;,</span>
<span id="cb165-6"><a href="#cb165-6"></a>           class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt;&gt;</span>
<span id="cb165-7"><a href="#cb165-7"></a>    class map;</span>
<span id="cb165-8"><a href="#cb165-8"></a></span>
<span id="cb165-9"><a href="#cb165-9"></a>  template&lt;class Key, class T, class Compare, class Allocator&gt;</span>
<span id="cb165-10"><a href="#cb165-10"></a>    bool operator==(const map&lt;Key, T, Compare, Allocator&gt;&amp; x,</span>
<span id="cb165-11"><a href="#cb165-11"></a>                    const map&lt;Key, T, Compare, Allocator&gt;&amp; y);</span>
<span id="cb165-12"><a href="#cb165-12"></a><span class="st">- template&lt;class Key, class T, class Compare, class Allocator&gt;</span></span>
<span id="cb165-13"><a href="#cb165-13"></a><span class="st">-   bool operator!=(const map&lt;Key, T, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb165-14"><a href="#cb165-14"></a><span class="st">-                   const map&lt;Key, T, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb165-15"><a href="#cb165-15"></a><span class="st">- template&lt;class Key, class T, class Compare, class Allocator&gt;</span></span>
<span id="cb165-16"><a href="#cb165-16"></a><span class="st">-   bool operator&lt; (const map&lt;Key, T, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb165-17"><a href="#cb165-17"></a><span class="st">-                   const map&lt;Key, T, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb165-18"><a href="#cb165-18"></a><span class="st">- template&lt;class Key, class T, class Compare, class Allocator&gt;</span></span>
<span id="cb165-19"><a href="#cb165-19"></a><span class="st">-   bool operator&gt; (const map&lt;Key, T, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb165-20"><a href="#cb165-20"></a><span class="st">-                   const map&lt;Key, T, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb165-21"><a href="#cb165-21"></a><span class="st">- template&lt;class Key, class T, class Compare, class Allocator&gt;</span></span>
<span id="cb165-22"><a href="#cb165-22"></a><span class="st">-   bool operator&lt;=(const map&lt;Key, T, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb165-23"><a href="#cb165-23"></a><span class="st">-                   const map&lt;Key, T, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb165-24"><a href="#cb165-24"></a><span class="st">- template&lt;class Key, class T, class Compare, class Allocator&gt;</span></span>
<span id="cb165-25"><a href="#cb165-25"></a><span class="st">-   bool operator&gt;=(const map&lt;Key, T, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb165-26"><a href="#cb165-26"></a><span class="st">-                   const map&lt;Key, T, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb165-27"><a href="#cb165-27"></a><span class="va">+ template&lt;class Key, class T, class Compare, class Allocator&gt;</span></span>
<span id="cb165-28"><a href="#cb165-28"></a><span class="va">+   @_see above_@ operator&lt;=&gt;(const map&lt;Key, T, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb165-29"><a href="#cb165-29"></a><span class="va">+                         const map&lt;Key, T, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb165-30"><a href="#cb165-30"></a></span>
<span id="cb165-31"><a href="#cb165-31"></a>  [...]</span>
<span id="cb165-32"><a href="#cb165-32"></a>  </span>
<span id="cb165-33"><a href="#cb165-33"></a></span>
<span id="cb165-34"><a href="#cb165-34"></a>  // [multimap], class template multimap</span>
<span id="cb165-35"><a href="#cb165-35"></a>  template&lt;class Key, class T, class Compare = less&lt;Key&gt;,</span>
<span id="cb165-36"><a href="#cb165-36"></a>           class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt;&gt;</span>
<span id="cb165-37"><a href="#cb165-37"></a>    class multimap;</span>
<span id="cb165-38"><a href="#cb165-38"></a></span>
<span id="cb165-39"><a href="#cb165-39"></a>  template&lt;class Key, class T, class Compare, class Allocator&gt;</span>
<span id="cb165-40"><a href="#cb165-40"></a>    bool operator==(const multimap&lt;Key, T, Compare, Allocator&gt;&amp; x,</span>
<span id="cb165-41"><a href="#cb165-41"></a>                    const multimap&lt;Key, T, Compare, Allocator&gt;&amp; y);</span>
<span id="cb165-42"><a href="#cb165-42"></a><span class="st">- template&lt;class Key, class T, class Compare, class Allocator&gt;</span></span>
<span id="cb165-43"><a href="#cb165-43"></a><span class="st">-   bool operator!=(const multimap&lt;Key, T, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb165-44"><a href="#cb165-44"></a><span class="st">-                   const multimap&lt;Key, T, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb165-45"><a href="#cb165-45"></a><span class="st">- template&lt;class Key, class T, class Compare, class Allocator&gt;</span></span>
<span id="cb165-46"><a href="#cb165-46"></a><span class="st">-   bool operator&lt; (const multimap&lt;Key, T, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb165-47"><a href="#cb165-47"></a><span class="st">-                   const multimap&lt;Key, T, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb165-48"><a href="#cb165-48"></a><span class="st">- template&lt;class Key, class T, class Compare, class Allocator&gt;</span></span>
<span id="cb165-49"><a href="#cb165-49"></a><span class="st">-   bool operator&gt; (const multimap&lt;Key, T, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb165-50"><a href="#cb165-50"></a><span class="st">-                   const multimap&lt;Key, T, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb165-51"><a href="#cb165-51"></a><span class="st">- template&lt;class Key, class T, class Compare, class Allocator&gt;</span></span>
<span id="cb165-52"><a href="#cb165-52"></a><span class="st">-   bool operator&lt;=(const multimap&lt;Key, T, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb165-53"><a href="#cb165-53"></a><span class="st">-                   const multimap&lt;Key, T, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb165-54"><a href="#cb165-54"></a><span class="st">- template&lt;class Key, class T, class Compare, class Allocator&gt;</span></span>
<span id="cb165-55"><a href="#cb165-55"></a><span class="st">-   bool operator&gt;=(const multimap&lt;Key, T, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb165-56"><a href="#cb165-56"></a><span class="st">-                   const multimap&lt;Key, T, Compare, Allocator&gt;&amp; y);  </span></span>
<span id="cb165-57"><a href="#cb165-57"></a><span class="va">+ template&lt;class Key, class T, class Compare, class Allocator&gt;</span></span>
<span id="cb165-58"><a href="#cb165-58"></a><span class="va">+   @_see above_@ operator&lt;=&gt;(const multimap&lt;Key, T, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb165-59"><a href="#cb165-59"></a><span class="va">+                         const multimap&lt;Key, T, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb165-60"><a href="#cb165-60"></a></span>
<span id="cb165-61"><a href="#cb165-61"></a>  [...]</span>
<span id="cb165-62"><a href="#cb165-62"></a>]</span></code></pre></div>
</blockquote>
<p>Change 22.4.3 [associative.set.syn]. These could just use <code class="sourceCode cpp">Key</code> directly, but decided to use <em><code class="sourceCode default">see above</code></em> anyway just to keep the associative containers consistent.</p>
<blockquote>
<div class="sourceCode" id="cb166"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb166-1"><a href="#cb166-1"></a>#include &lt;initializer_list&gt;</span>
<span id="cb166-2"><a href="#cb166-2"></a></span>
<span id="cb166-3"><a href="#cb166-3"></a>namespace std {</span>
<span id="cb166-4"><a href="#cb166-4"></a>  // [set], class template set</span>
<span id="cb166-5"><a href="#cb166-5"></a>  template&lt;class Key, class Compare = less&lt;Key&gt;, class Allocator = allocator&lt;Key&gt;&gt;</span>
<span id="cb166-6"><a href="#cb166-6"></a>    class set;</span>
<span id="cb166-7"><a href="#cb166-7"></a></span>
<span id="cb166-8"><a href="#cb166-8"></a>  template&lt;class Key, class Compare, class Allocator&gt;</span>
<span id="cb166-9"><a href="#cb166-9"></a>    bool operator==(const set&lt;Key, Compare, Allocator&gt;&amp; x,</span>
<span id="cb166-10"><a href="#cb166-10"></a>                    const set&lt;Key, Compare, Allocator&gt;&amp; y);</span>
<span id="cb166-11"><a href="#cb166-11"></a><span class="st">- template&lt;class Key, class Compare, class Allocator&gt;</span></span>
<span id="cb166-12"><a href="#cb166-12"></a><span class="st">-   bool operator!=(const set&lt;Key, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb166-13"><a href="#cb166-13"></a><span class="st">-                   const set&lt;Key, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb166-14"><a href="#cb166-14"></a><span class="st">- template&lt;class Key, class Compare, class Allocator&gt;</span></span>
<span id="cb166-15"><a href="#cb166-15"></a><span class="st">-   bool operator&lt; (const set&lt;Key, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb166-16"><a href="#cb166-16"></a><span class="st">-                   const set&lt;Key, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb166-17"><a href="#cb166-17"></a><span class="st">- template&lt;class Key, class Compare, class Allocator&gt;</span></span>
<span id="cb166-18"><a href="#cb166-18"></a><span class="st">-   bool operator&gt; (const set&lt;Key, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb166-19"><a href="#cb166-19"></a><span class="st">-                   const set&lt;Key, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb166-20"><a href="#cb166-20"></a><span class="st">- template&lt;class Key, class Compare, class Allocator&gt;</span></span>
<span id="cb166-21"><a href="#cb166-21"></a><span class="st">-   bool operator&lt;=(const set&lt;Key, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb166-22"><a href="#cb166-22"></a><span class="st">-                   const set&lt;Key, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb166-23"><a href="#cb166-23"></a><span class="st">- template&lt;class Key, class Compare, class Allocator&gt;</span></span>
<span id="cb166-24"><a href="#cb166-24"></a><span class="st">-   bool operator&gt;=(const set&lt;Key, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb166-25"><a href="#cb166-25"></a><span class="st">-                   const set&lt;Key, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb166-26"><a href="#cb166-26"></a><span class="va">+ template&lt;class Key, class Compare, class Allocator&gt;</span></span>
<span id="cb166-27"><a href="#cb166-27"></a><span class="va">+   @_see above_@ operator&lt;=&gt;(const set&lt;Key, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb166-28"><a href="#cb166-28"></a><span class="va">+                         const set&lt;Key, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb166-29"><a href="#cb166-29"></a>                    </span>
<span id="cb166-30"><a href="#cb166-30"></a>  [...]</span>
<span id="cb166-31"><a href="#cb166-31"></a>  </span>
<span id="cb166-32"><a href="#cb166-32"></a>  // [multiset], class template multiset</span>
<span id="cb166-33"><a href="#cb166-33"></a>  template&lt;class Key, class Compare = less&lt;Key&gt;, class Allocator = allocator&lt;Key&gt;&gt;</span>
<span id="cb166-34"><a href="#cb166-34"></a>    class multiset;</span>
<span id="cb166-35"><a href="#cb166-35"></a></span>
<span id="cb166-36"><a href="#cb166-36"></a>  template&lt;class Key, class Compare, class Allocator&gt;</span>
<span id="cb166-37"><a href="#cb166-37"></a>    bool operator==(const multiset&lt;Key, Compare, Allocator&gt;&amp; x,</span>
<span id="cb166-38"><a href="#cb166-38"></a>                    const multiset&lt;Key, Compare, Allocator&gt;&amp; y);</span>
<span id="cb166-39"><a href="#cb166-39"></a><span class="st">- template&lt;class Key, class Compare, class Allocator&gt;</span></span>
<span id="cb166-40"><a href="#cb166-40"></a><span class="st">-   bool operator!=(const multiset&lt;Key, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb166-41"><a href="#cb166-41"></a><span class="st">-                   const multiset&lt;Key, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb166-42"><a href="#cb166-42"></a><span class="st">- template&lt;class Key, class Compare, class Allocator&gt;</span></span>
<span id="cb166-43"><a href="#cb166-43"></a><span class="st">-   bool operator&lt; (const multiset&lt;Key, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb166-44"><a href="#cb166-44"></a><span class="st">-                   const multiset&lt;Key, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb166-45"><a href="#cb166-45"></a><span class="st">- template&lt;class Key, class Compare, class Allocator&gt;</span></span>
<span id="cb166-46"><a href="#cb166-46"></a><span class="st">-   bool operator&gt; (const multiset&lt;Key, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb166-47"><a href="#cb166-47"></a><span class="st">-                   const multiset&lt;Key, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb166-48"><a href="#cb166-48"></a><span class="st">- template&lt;class Key, class Compare, class Allocator&gt;</span></span>
<span id="cb166-49"><a href="#cb166-49"></a><span class="st">-   bool operator&lt;=(const multiset&lt;Key, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb166-50"><a href="#cb166-50"></a><span class="st">-                   const multiset&lt;Key, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb166-51"><a href="#cb166-51"></a><span class="st">- template&lt;class Key, class Compare, class Allocator&gt;</span></span>
<span id="cb166-52"><a href="#cb166-52"></a><span class="st">-   bool operator&gt;=(const multiset&lt;Key, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb166-53"><a href="#cb166-53"></a><span class="st">-                   const multiset&lt;Key, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb166-54"><a href="#cb166-54"></a><span class="va">+ template&lt;class Key, class Compare, class Allocator&gt;</span></span>
<span id="cb166-55"><a href="#cb166-55"></a><span class="va">+   @_see above_@ operator&lt;=&gt;(const multiset&lt;Key, Compare, Allocator&gt;&amp; x,</span></span>
<span id="cb166-56"><a href="#cb166-56"></a><span class="va">+                         const multiset&lt;Key, Compare, Allocator&gt;&amp; y);</span></span>
<span id="cb166-57"><a href="#cb166-57"></a></span>
<span id="cb166-58"><a href="#cb166-58"></a></span>
<span id="cb166-59"><a href="#cb166-59"></a>  [...]</span>
<span id="cb166-60"><a href="#cb166-60"></a>}</span></code></pre></div>
</blockquote>
<p>Change 22.5.2 [unord.map.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb167"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb167-1"><a href="#cb167-1"></a>#include &lt;initializer_list&gt;</span>
<span id="cb167-2"><a href="#cb167-2"></a></span>
<span id="cb167-3"><a href="#cb167-3"></a>namespace std {</span>
<span id="cb167-4"><a href="#cb167-4"></a>  // [unord.map], class template unordered_map</span>
<span id="cb167-5"><a href="#cb167-5"></a>  template&lt;class Key,</span>
<span id="cb167-6"><a href="#cb167-6"></a>           class T,</span>
<span id="cb167-7"><a href="#cb167-7"></a>           class Hash = hash&lt;Key&gt;,</span>
<span id="cb167-8"><a href="#cb167-8"></a>           class Pred = equal_to&lt;Key&gt;,</span>
<span id="cb167-9"><a href="#cb167-9"></a>           class Alloc = allocator&lt;pair&lt;const Key, T&gt;&gt;&gt;</span>
<span id="cb167-10"><a href="#cb167-10"></a>    class unordered_map;</span>
<span id="cb167-11"><a href="#cb167-11"></a></span>
<span id="cb167-12"><a href="#cb167-12"></a>  // [unord.multimap], class template unordered_multimap</span>
<span id="cb167-13"><a href="#cb167-13"></a>  template&lt;class Key,</span>
<span id="cb167-14"><a href="#cb167-14"></a>           class T,</span>
<span id="cb167-15"><a href="#cb167-15"></a>           class Hash = hash&lt;Key&gt;,</span>
<span id="cb167-16"><a href="#cb167-16"></a>           class Pred = equal_to&lt;Key&gt;,</span>
<span id="cb167-17"><a href="#cb167-17"></a>           class Alloc = allocator&lt;pair&lt;const Key, T&gt;&gt;&gt;</span>
<span id="cb167-18"><a href="#cb167-18"></a>    class unordered_multimap;</span>
<span id="cb167-19"><a href="#cb167-19"></a></span>
<span id="cb167-20"><a href="#cb167-20"></a>  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;</span>
<span id="cb167-21"><a href="#cb167-21"></a>    bool operator==(const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; a,</span>
<span id="cb167-22"><a href="#cb167-22"></a>                    const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; b);</span>
<span id="cb167-23"><a href="#cb167-23"></a><span class="st">- template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;</span></span>
<span id="cb167-24"><a href="#cb167-24"></a><span class="st">-   bool operator!=(const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; a,</span></span>
<span id="cb167-25"><a href="#cb167-25"></a><span class="st">-                   const unordered_map&lt;Key, T, Hash, Pred, Alloc&gt;&amp; b);</span></span>
<span id="cb167-26"><a href="#cb167-26"></a></span>
<span id="cb167-27"><a href="#cb167-27"></a>  template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;</span>
<span id="cb167-28"><a href="#cb167-28"></a>    bool operator==(const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; a,</span>
<span id="cb167-29"><a href="#cb167-29"></a>                    const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; b);</span>
<span id="cb167-30"><a href="#cb167-30"></a><span class="st">- template&lt;class Key, class T, class Hash, class Pred, class Alloc&gt;</span></span>
<span id="cb167-31"><a href="#cb167-31"></a><span class="st">-   bool operator!=(const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; a,</span></span>
<span id="cb167-32"><a href="#cb167-32"></a><span class="st">-                   const unordered_multimap&lt;Key, T, Hash, Pred, Alloc&gt;&amp; b);</span></span>
<span id="cb167-33"><a href="#cb167-33"></a>                    </span>
<span id="cb167-34"><a href="#cb167-34"></a>  [...]</span>
<span id="cb167-35"><a href="#cb167-35"></a>}</span></code></pre></div>
</blockquote>
<p>Change 22.5.3 [unordered.set.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb168"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb168-1"><a href="#cb168-1"></a>#include &lt;initializer_list&gt;</span>
<span id="cb168-2"><a href="#cb168-2"></a></span>
<span id="cb168-3"><a href="#cb168-3"></a>namespace std {</span>
<span id="cb168-4"><a href="#cb168-4"></a>  // [unord.set], class template unordered_set</span>
<span id="cb168-5"><a href="#cb168-5"></a>  template&lt;class Key,</span>
<span id="cb168-6"><a href="#cb168-6"></a>           class Hash = hash&lt;Key&gt;,</span>
<span id="cb168-7"><a href="#cb168-7"></a>           class Pred = equal_to&lt;Key&gt;,</span>
<span id="cb168-8"><a href="#cb168-8"></a>           class Alloc = allocator&lt;Key&gt;&gt;</span>
<span id="cb168-9"><a href="#cb168-9"></a>    class unordered_set;</span>
<span id="cb168-10"><a href="#cb168-10"></a></span>
<span id="cb168-11"><a href="#cb168-11"></a>  // [unord.multiset], class template unordered_multiset</span>
<span id="cb168-12"><a href="#cb168-12"></a>  template&lt;class Key,</span>
<span id="cb168-13"><a href="#cb168-13"></a>           class Hash = hash&lt;Key&gt;,</span>
<span id="cb168-14"><a href="#cb168-14"></a>           class Pred = equal_to&lt;Key&gt;,</span>
<span id="cb168-15"><a href="#cb168-15"></a>           class Alloc = allocator&lt;Key&gt;&gt;</span>
<span id="cb168-16"><a href="#cb168-16"></a>    class unordered_multiset;</span>
<span id="cb168-17"><a href="#cb168-17"></a></span>
<span id="cb168-18"><a href="#cb168-18"></a>  template&lt;class Key, class Hash, class Pred, class Alloc&gt;</span>
<span id="cb168-19"><a href="#cb168-19"></a>    bool operator==(const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; a,</span>
<span id="cb168-20"><a href="#cb168-20"></a>                    const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; b);</span>
<span id="cb168-21"><a href="#cb168-21"></a><span class="st">- template&lt;class Key, class Hash, class Pred, class Alloc&gt;</span></span>
<span id="cb168-22"><a href="#cb168-22"></a><span class="st">-   bool operator!=(const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; a,</span></span>
<span id="cb168-23"><a href="#cb168-23"></a><span class="st">-                   const unordered_set&lt;Key, Hash, Pred, Alloc&gt;&amp; b);</span></span>
<span id="cb168-24"><a href="#cb168-24"></a></span>
<span id="cb168-25"><a href="#cb168-25"></a>  template&lt;class Key, class Hash, class Pred, class Alloc&gt;</span>
<span id="cb168-26"><a href="#cb168-26"></a>    bool operator==(const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; a,</span>
<span id="cb168-27"><a href="#cb168-27"></a>                    const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; b);</span>
<span id="cb168-28"><a href="#cb168-28"></a><span class="st">- template&lt;class Key, class Hash, class Pred, class Alloc&gt;</span></span>
<span id="cb168-29"><a href="#cb168-29"></a><span class="st">-   bool operator!=(const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; a,</span></span>
<span id="cb168-30"><a href="#cb168-30"></a><span class="st">-                   const unordered_multiset&lt;Key, Hash, Pred, Alloc&gt;&amp; b);</span></span>
<span id="cb168-31"><a href="#cb168-31"></a></span>
<span id="cb168-32"><a href="#cb168-32"></a>  [...]</span>
<span id="cb168-33"><a href="#cb168-33"></a>}</span></code></pre></div>
</blockquote>
<p>Change 22.6.2 [queue.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb169"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb169-1"><a href="#cb169-1"></a>#include &lt;initializer_list&gt;</span>
<span id="cb169-2"><a href="#cb169-2"></a></span>
<span id="cb169-3"><a href="#cb169-3"></a>namespace std {</span>
<span id="cb169-4"><a href="#cb169-4"></a>  template&lt;class T, class Container = deque&lt;T&gt;&gt; class queue;</span>
<span id="cb169-5"><a href="#cb169-5"></a></span>
<span id="cb169-6"><a href="#cb169-6"></a>  template&lt;class T, class Container&gt;</span>
<span id="cb169-7"><a href="#cb169-7"></a>    bool operator==(const queue&lt;T, Container&gt;&amp; x, const queue&lt;T, Container&gt;&amp; y);</span>
<span id="cb169-8"><a href="#cb169-8"></a>  template&lt;class T, class Container&gt;</span>
<span id="cb169-9"><a href="#cb169-9"></a>    bool operator!=(const queue&lt;T, Container&gt;&amp; x, const queue&lt;T, Container&gt;&amp; y);</span>
<span id="cb169-10"><a href="#cb169-10"></a>  template&lt;class T, class Container&gt;</span>
<span id="cb169-11"><a href="#cb169-11"></a>    bool operator&lt; (const queue&lt;T, Container&gt;&amp; x, const queue&lt;T, Container&gt;&amp; y);</span>
<span id="cb169-12"><a href="#cb169-12"></a>  template&lt;class T, class Container&gt;</span>
<span id="cb169-13"><a href="#cb169-13"></a>    bool operator&gt; (const queue&lt;T, Container&gt;&amp; x, const queue&lt;T, Container&gt;&amp; y);</span>
<span id="cb169-14"><a href="#cb169-14"></a>  template&lt;class T, class Container&gt;</span>
<span id="cb169-15"><a href="#cb169-15"></a>    bool operator&lt;=(const queue&lt;T, Container&gt;&amp; x, const queue&lt;T, Container&gt;&amp; y);</span>
<span id="cb169-16"><a href="#cb169-16"></a>  template&lt;class T, class Container&gt;</span>
<span id="cb169-17"><a href="#cb169-17"></a>    bool operator&gt;=(const queue&lt;T, Container&gt;&amp; x, const queue&lt;T, Container&gt;&amp; y);</span>
<span id="cb169-18"><a href="#cb169-18"></a><span class="va">+ template&lt;class T, ThreeWayComparable Container&gt;</span></span>
<span id="cb169-19"><a href="#cb169-19"></a><span class="va">+   compare_three_way_result_t&lt;Container&gt;</span></span>
<span id="cb169-20"><a href="#cb169-20"></a><span class="va">+     operator&lt;=&gt;(const queue&lt;T, Container&gt;&amp; x, const queue&lt;T, Container&gt;&amp; y);</span></span>
<span id="cb169-21"><a href="#cb169-21"></a></span>
<span id="cb169-22"><a href="#cb169-22"></a>  [...]</span>
<span id="cb169-23"><a href="#cb169-23"></a>}</span></code></pre></div>
</blockquote>
<p>Change 22.6.3 [stack.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb170"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb170-1"><a href="#cb170-1"></a>#include &lt;initializer_list&gt;</span>
<span id="cb170-2"><a href="#cb170-2"></a></span>
<span id="cb170-3"><a href="#cb170-3"></a>namespace std {</span>
<span id="cb170-4"><a href="#cb170-4"></a>  template&lt;class T, class Container = deque&lt;T&gt;&gt; class stack;</span>
<span id="cb170-5"><a href="#cb170-5"></a></span>
<span id="cb170-6"><a href="#cb170-6"></a>  template&lt;class T, class Container&gt;</span>
<span id="cb170-7"><a href="#cb170-7"></a>    bool operator==(const stack&lt;T, Container&gt;&amp; x, const stack&lt;T, Container&gt;&amp; y);</span>
<span id="cb170-8"><a href="#cb170-8"></a>  template&lt;class T, class Container&gt;</span>
<span id="cb170-9"><a href="#cb170-9"></a>    bool operator!=(const stack&lt;T, Container&gt;&amp; x, const stack&lt;T, Container&gt;&amp; y);</span>
<span id="cb170-10"><a href="#cb170-10"></a>  template&lt;class T, class Container&gt;</span>
<span id="cb170-11"><a href="#cb170-11"></a>    bool operator&lt; (const stack&lt;T, Container&gt;&amp; x, const stack&lt;T, Container&gt;&amp; y);</span>
<span id="cb170-12"><a href="#cb170-12"></a>  template&lt;class T, class Container&gt;</span>
<span id="cb170-13"><a href="#cb170-13"></a>    bool operator&gt; (const stack&lt;T, Container&gt;&amp; x, const stack&lt;T, Container&gt;&amp; y);</span>
<span id="cb170-14"><a href="#cb170-14"></a>  template&lt;class T, class Container&gt;</span>
<span id="cb170-15"><a href="#cb170-15"></a>    bool operator&lt;=(const stack&lt;T, Container&gt;&amp; x, const stack&lt;T, Container&gt;&amp; y);</span>
<span id="cb170-16"><a href="#cb170-16"></a>  template&lt;class T, class Container&gt;</span>
<span id="cb170-17"><a href="#cb170-17"></a>    bool operator&gt;=(const stack&lt;T, Container&gt;&amp; x, const stack&lt;T, Container&gt;&amp; y);</span>
<span id="cb170-18"><a href="#cb170-18"></a><span class="va">+ template&lt;class T, ThreeWayComparable Container&gt;</span></span>
<span id="cb170-19"><a href="#cb170-19"></a><span class="va">+   compare_three_way_result_t&lt;Container&gt;</span></span>
<span id="cb170-20"><a href="#cb170-20"></a><span class="va">+     operator&lt;=&gt;(const stack&lt;T, Container&gt;&amp; x, const stack&lt;T, Container&gt;&amp; y);</span></span>
<span id="cb170-21"><a href="#cb170-21"></a></span>
<span id="cb170-22"><a href="#cb170-22"></a>  template&lt;class T, class Container&gt;</span>
<span id="cb170-23"><a href="#cb170-23"></a>    void swap(stack&lt;T, Container&gt;&amp; x, stack&lt;T, Container&gt;&amp; y) noexcept(noexcept(x.swap(y)));</span>
<span id="cb170-24"><a href="#cb170-24"></a>  template&lt;class T, class Container, class Alloc&gt;</span>
<span id="cb170-25"><a href="#cb170-25"></a>    struct uses_allocator&lt;stack&lt;T, Container&gt;, Alloc&gt;;</span>
<span id="cb170-26"><a href="#cb170-26"></a>}</span></code></pre></div>
</blockquote>
<p>Add to 22.6.4.4 [queue.ops]:</p>
<blockquote>
<div class="sourceCode" id="cb171"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb171-1"><a href="#cb171-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> Container<span class="op">&gt;</span></span>
<span id="cb171-2"><a href="#cb171-2"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><span class="kw">const</span> queue<span class="op">&lt;</span>T, Container<span class="op">&gt;&amp;</span> x,</span>
<span id="cb171-3"><a href="#cb171-3"></a>                    <span class="kw">const</span> queue<span class="op">&lt;</span>T, Container<span class="op">&gt;&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Returns</em>: <code class="sourceCode cpp">x<span class="op">.</span>c <span class="op">&gt;=</span> y<span class="op">.</span>c</code>.</p>
<div class="addu">
<pre><code>template&lt;class T, ThreeWayComparable Container&gt;
  compare_three_way_result_t&lt;Container&gt;
    operator&lt;=&gt;(const queue&lt;T, Container&gt;&amp; x,
                const queue&lt;T, Container&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Returns</em>: <code class="sourceCode cpp">x<span class="op">.</span>c <span class="op">&lt;=&gt;</span> y<span class="op">.</span>c</code>.</p>
</div>
</blockquote>
<p>Add to 22.6.6.4 [stack.ops]:</p>
<blockquote>
<div class="sourceCode" id="cb173"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb173-1"><a href="#cb173-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> Container<span class="op">&gt;</span></span>
<span id="cb173-2"><a href="#cb173-2"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><span class="kw">const</span> stack<span class="op">&lt;</span>T, Container<span class="op">&gt;&amp;</span> x,</span>
<span id="cb173-3"><a href="#cb173-3"></a>                    <span class="kw">const</span> stack<span class="op">&lt;</span>T, Container<span class="op">&gt;&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Returns</em>: <code class="sourceCode cpp">x<span class="op">.</span>c <span class="op">&gt;=</span> y<span class="op">.</span>c</code>.</p>
<div class="addu">
<pre><code>template&lt;class T, ThreeWayComparable Container&gt;
  compare_three_way_result_t&lt;Container&gt;
    operator&lt;=&gt;(const stack&lt;T, Container&gt;&amp; x,
                const stack&lt;T, Container&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Returns</em>: <code class="sourceCode cpp">x<span class="op">.</span>c <span class="op">&lt;=&gt;</span> y<span class="op">.</span>c</code>.</p>
</div>
</blockquote>
<h2 id="clause-23-iterators-library"><span class="header-section-number">5.8</span> Clause 23: Iterators library<a href="#clause-23-iterators-library" class="self-link"></a></h2>
<p>We preserve existing comparison operators for <code class="sourceCode cpp">reverse_iterator</code> because <code class="sourceCode cpp"><span class="op">&gt;</span></code> actually forwards to the base <code class="sourceCode cpp"><span class="op">&gt;</span></code> rather than invoking the <code class="sourceCode cpp"><span class="op">&lt;</span></code> with the arguments reversed. So, like <code class="sourceCode cpp">optional</code>, we cannot synthesize a <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code>.</p>
<p>We preserve existing comparison operators <code class="sourceCode cpp">move_iterator</code> because it seems pretty bad to try to synthesize a three-way comparison out of two operator calls instead of just making the one operator call.</p>
<p>Notably, we do <em>not</em> add <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> to any iterator requirements.</p>
<p>Change 23.2 [iterator.synopsis]:</p>
<blockquote>
<div class="sourceCode" id="cb175"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb175-1"><a href="#cb175-1"></a>#include &lt;concepts&gt;</span>
<span id="cb175-2"><a href="#cb175-2"></a></span>
<span id="cb175-3"><a href="#cb175-3"></a>namespace std {</span>
<span id="cb175-4"><a href="#cb175-4"></a>  [...]</span>
<span id="cb175-5"><a href="#cb175-5"></a>  </span>
<span id="cb175-6"><a href="#cb175-6"></a>  // [predef.iterators], predefined iterators and sentinels</span>
<span id="cb175-7"><a href="#cb175-7"></a>  // [reverse.iterators], reverse iterators</span>
<span id="cb175-8"><a href="#cb175-8"></a>  template&lt;class Iterator&gt; class reverse_iterator;</span>
<span id="cb175-9"><a href="#cb175-9"></a></span>
<span id="cb175-10"><a href="#cb175-10"></a>  template&lt;class Iterator1, class Iterator2&gt;</span>
<span id="cb175-11"><a href="#cb175-11"></a>    constexpr bool operator==(</span>
<span id="cb175-12"><a href="#cb175-12"></a>      const reverse_iterator&lt;Iterator1&gt;&amp; x,</span>
<span id="cb175-13"><a href="#cb175-13"></a>      const reverse_iterator&lt;Iterator2&gt;&amp; y);</span>
<span id="cb175-14"><a href="#cb175-14"></a>  template&lt;class Iterator1, class Iterator2&gt;</span>
<span id="cb175-15"><a href="#cb175-15"></a>    constexpr bool operator!=(</span>
<span id="cb175-16"><a href="#cb175-16"></a>      const reverse_iterator&lt;Iterator1&gt;&amp; x,</span>
<span id="cb175-17"><a href="#cb175-17"></a>      const reverse_iterator&lt;Iterator2&gt;&amp; y);</span>
<span id="cb175-18"><a href="#cb175-18"></a>  template&lt;class Iterator1, class Iterator2&gt;</span>
<span id="cb175-19"><a href="#cb175-19"></a>    constexpr bool operator&lt;(</span>
<span id="cb175-20"><a href="#cb175-20"></a>      const reverse_iterator&lt;Iterator1&gt;&amp; x,</span>
<span id="cb175-21"><a href="#cb175-21"></a>      const reverse_iterator&lt;Iterator2&gt;&amp; y);</span>
<span id="cb175-22"><a href="#cb175-22"></a>  template&lt;class Iterator1, class Iterator2&gt;</span>
<span id="cb175-23"><a href="#cb175-23"></a>    constexpr bool operator&gt;(</span>
<span id="cb175-24"><a href="#cb175-24"></a>      const reverse_iterator&lt;Iterator1&gt;&amp; x,</span>
<span id="cb175-25"><a href="#cb175-25"></a>      const reverse_iterator&lt;Iterator2&gt;&amp; y);</span>
<span id="cb175-26"><a href="#cb175-26"></a>  template&lt;class Iterator1, class Iterator2&gt;</span>
<span id="cb175-27"><a href="#cb175-27"></a>    constexpr bool operator&lt;=(</span>
<span id="cb175-28"><a href="#cb175-28"></a>      const reverse_iterator&lt;Iterator1&gt;&amp; x,</span>
<span id="cb175-29"><a href="#cb175-29"></a>      const reverse_iterator&lt;Iterator2&gt;&amp; y);</span>
<span id="cb175-30"><a href="#cb175-30"></a>  template&lt;class Iterator1, class Iterator2&gt;</span>
<span id="cb175-31"><a href="#cb175-31"></a>    constexpr bool operator&gt;=(</span>
<span id="cb175-32"><a href="#cb175-32"></a>      const reverse_iterator&lt;Iterator1&gt;&amp; x,</span>
<span id="cb175-33"><a href="#cb175-33"></a>      const reverse_iterator&lt;Iterator2&gt;&amp; y);  </span>
<span id="cb175-34"><a href="#cb175-34"></a><span class="va">+ template&lt;class Iterator1, ThreeWayComparableWith&lt;Iterator1&gt; Iterator2&gt;</span></span>
<span id="cb175-35"><a href="#cb175-35"></a><span class="va">+   constexpr compare_three_way_result_t&lt;Iterator1, Iterator2&gt;</span></span>
<span id="cb175-36"><a href="#cb175-36"></a><span class="va">+     operator&lt;=&gt;(const reverse_iterator&lt;Iterator1&gt;&amp; x,</span></span>
<span id="cb175-37"><a href="#cb175-37"></a><span class="va">+                 const reverse_iterator&lt;Iterator2&gt;&amp; y);      </span></span>
<span id="cb175-38"><a href="#cb175-38"></a></span>
<span id="cb175-39"><a href="#cb175-39"></a>  [...]</span>
<span id="cb175-40"><a href="#cb175-40"></a>  </span>
<span id="cb175-41"><a href="#cb175-41"></a>  // [move.iterators], move iterators and sentinels</span>
<span id="cb175-42"><a href="#cb175-42"></a>  template&lt;class Iterator&gt; class move_iterator;</span>
<span id="cb175-43"><a href="#cb175-43"></a></span>
<span id="cb175-44"><a href="#cb175-44"></a>  template&lt;class Iterator1, class Iterator2&gt;</span>
<span id="cb175-45"><a href="#cb175-45"></a>    constexpr bool operator==(</span>
<span id="cb175-46"><a href="#cb175-46"></a>      const move_iterator&lt;Iterator1&gt;&amp; x, const move_iterator&lt;Iterator2&gt;&amp; y);</span>
<span id="cb175-47"><a href="#cb175-47"></a><span class="st">- template&lt;class Iterator1, class Iterator2&gt;</span></span>
<span id="cb175-48"><a href="#cb175-48"></a><span class="st">-   constexpr bool operator!=(</span></span>
<span id="cb175-49"><a href="#cb175-49"></a><span class="st">-     const move_iterator&lt;Iterator1&gt;&amp; x, const move_iterator&lt;Iterator2&gt;&amp; y);</span></span>
<span id="cb175-50"><a href="#cb175-50"></a>  template&lt;class Iterator1, class Iterator2&gt;</span>
<span id="cb175-51"><a href="#cb175-51"></a>    constexpr bool operator&lt;(</span>
<span id="cb175-52"><a href="#cb175-52"></a>      const move_iterator&lt;Iterator1&gt;&amp; x, const move_iterator&lt;Iterator2&gt;&amp; y);</span>
<span id="cb175-53"><a href="#cb175-53"></a>  template&lt;class Iterator1, class Iterator2&gt;</span>
<span id="cb175-54"><a href="#cb175-54"></a>    constexpr bool operator&gt;(</span>
<span id="cb175-55"><a href="#cb175-55"></a>      const move_iterator&lt;Iterator1&gt;&amp; x, const move_iterator&lt;Iterator2&gt;&amp; y);</span>
<span id="cb175-56"><a href="#cb175-56"></a>  template&lt;class Iterator1, class Iterator2&gt;</span>
<span id="cb175-57"><a href="#cb175-57"></a>    constexpr bool operator&lt;=(</span>
<span id="cb175-58"><a href="#cb175-58"></a>      const move_iterator&lt;Iterator1&gt;&amp; x, const move_iterator&lt;Iterator2&gt;&amp; y);</span>
<span id="cb175-59"><a href="#cb175-59"></a>  template&lt;class Iterator1, class Iterator2&gt;</span>
<span id="cb175-60"><a href="#cb175-60"></a>    constexpr bool operator&gt;=(</span>
<span id="cb175-61"><a href="#cb175-61"></a>      const move_iterator&lt;Iterator1&gt;&amp; x, const move_iterator&lt;Iterator2&gt;&amp; y);</span>
<span id="cb175-62"><a href="#cb175-62"></a><span class="va">+ template&lt;class Iterator1, ThreeWayComparableWith&lt;Iterator1&gt; Iterator2&gt;</span></span>
<span id="cb175-63"><a href="#cb175-63"></a><span class="va">+   constexpr compare_three_way_result_t&lt;Iterator1, Iterator2&gt;</span></span>
<span id="cb175-64"><a href="#cb175-64"></a><span class="va">+     operator&lt;=&gt;(const move_iterator&lt;Iterator1&gt;&amp; x,</span></span>
<span id="cb175-65"><a href="#cb175-65"></a><span class="va">+                 const move_iterator&lt;Iterator2&gt;&amp; y);</span></span>
<span id="cb175-66"><a href="#cb175-66"></a></span>
<span id="cb175-67"><a href="#cb175-67"></a>  [...]</span>
<span id="cb175-68"><a href="#cb175-68"></a>  </span>
<span id="cb175-69"><a href="#cb175-69"></a>  // [stream.iterators], stream iterators</span>
<span id="cb175-70"><a href="#cb175-70"></a>  template&lt;class T, class charT = char, class traits = char_traits&lt;charT&gt;,</span>
<span id="cb175-71"><a href="#cb175-71"></a>           class Distance = ptrdiff_t&gt;</span>
<span id="cb175-72"><a href="#cb175-72"></a>  class istream_iterator;</span>
<span id="cb175-73"><a href="#cb175-73"></a>  template&lt;class T, class charT, class traits, class Distance&gt;</span>
<span id="cb175-74"><a href="#cb175-74"></a>    bool operator==(const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; x,</span>
<span id="cb175-75"><a href="#cb175-75"></a>            const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; y);</span>
<span id="cb175-76"><a href="#cb175-76"></a><span class="st">- template&lt;class T, class charT, class traits, class Distance&gt;</span></span>
<span id="cb175-77"><a href="#cb175-77"></a><span class="st">-   bool operator!=(const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; x,</span></span>
<span id="cb175-78"><a href="#cb175-78"></a><span class="st">-           const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; y);</span></span>
<span id="cb175-79"><a href="#cb175-79"></a></span>
<span id="cb175-80"><a href="#cb175-80"></a>  template&lt;class T, class charT = char, class traits = char_traits&lt;charT&gt;&gt;</span>
<span id="cb175-81"><a href="#cb175-81"></a>      class ostream_iterator;</span>
<span id="cb175-82"><a href="#cb175-82"></a></span>
<span id="cb175-83"><a href="#cb175-83"></a>  template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;</span>
<span id="cb175-84"><a href="#cb175-84"></a>    class istreambuf_iterator;</span>
<span id="cb175-85"><a href="#cb175-85"></a>  template&lt;class charT, class traits&gt;</span>
<span id="cb175-86"><a href="#cb175-86"></a>    bool operator==(const istreambuf_iterator&lt;charT,traits&gt;&amp; a,</span>
<span id="cb175-87"><a href="#cb175-87"></a>            const istreambuf_iterator&lt;charT,traits&gt;&amp; b);</span>
<span id="cb175-88"><a href="#cb175-88"></a><span class="st">- template&lt;class charT, class traits&gt;</span></span>
<span id="cb175-89"><a href="#cb175-89"></a><span class="st">-   bool operator!=(const istreambuf_iterator&lt;charT,traits&gt;&amp; a,</span></span>
<span id="cb175-90"><a href="#cb175-90"></a><span class="st">-           const istreambuf_iterator&lt;charT,traits&gt;&amp; b);</span></span>
<span id="cb175-91"><a href="#cb175-91"></a></span>
<span id="cb175-92"><a href="#cb175-92"></a>  [...]         </span>
<span id="cb175-93"><a href="#cb175-93"></a>}</span></code></pre></div>
</blockquote>
<p>Add <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> to 23.5.1.7 [reverse.iter.cmp]:</p>
<blockquote>
<div class="sourceCode" id="cb176"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb176-1"><a href="#cb176-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Iterator1, <span class="kw">class</span> Iterator2<span class="op">&gt;</span></span>
<span id="cb176-2"><a href="#cb176-2"></a>  <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span></span>
<span id="cb176-3"><a href="#cb176-3"></a>    <span class="kw">const</span> reverse_iterator<span class="op">&lt;</span>Iterator1<span class="op">&gt;&amp;</span> x,</span>
<span id="cb176-4"><a href="#cb176-4"></a>    <span class="kw">const</span> reverse_iterator<span class="op">&lt;</span>Iterator2<span class="op">&gt;&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">11</a></span> <em>Constraints</em>: <code class="sourceCode cpp">x<span class="op">.</span>base<span class="op">()</span> <span class="op">&lt;=</span> y<span class="op">.</span>base<span class="op">()</span></code> is well-formed and convertible to <code class="sourceCode cpp"><span class="dt">bool</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">12</a></span> <em>Returns</em>: <code class="sourceCode cpp">x<span class="op">.</span>base<span class="op">()</span> <span class="op">&lt;=</span> y<span class="op">.</span>base<span class="op">()</span></code>.</p>
<div class="addu">
<pre><code>template&lt;class Iterator1, ThreeWayComparableWith&lt;Iterator1&gt; Iterator2&gt;
  constexpr compare_three_way_result_t&lt;Iterator1, Iterator2&gt;
    operator&lt;=&gt;(const reverse_iterator&lt;Iterator1&gt;&amp; x,
                const reverse_iterator&lt;Iterator2&gt;&amp; y);      </code></pre>
<p><span class="marginalizedparent"><a class="marginalized">13</a></span> <em>Returns</em>: <code class="sourceCode cpp">x<span class="op">.</span>base<span class="op">()</span> <span class="op">&lt;=&gt;</span> y<span class="op">.</span>base<span class="op">()</span></code>.</p>
</div>
</blockquote>
<p>Change 23.5.3.1 [move.iterator]:</p>
<blockquote>
<div class="sourceCode" id="cb178"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb178-1"><a href="#cb178-1"></a>namespace std {</span>
<span id="cb178-2"><a href="#cb178-2"></a>  template&lt;class Iterator&gt;</span>
<span id="cb178-3"><a href="#cb178-3"></a>  class move_iterator {</span>
<span id="cb178-4"><a href="#cb178-4"></a>  public:</span>
<span id="cb178-5"><a href="#cb178-5"></a>    [...]</span>
<span id="cb178-6"><a href="#cb178-6"></a></span>
<span id="cb178-7"><a href="#cb178-7"></a>    template&lt;Sentinel&lt;Iterator&gt; S&gt;</span>
<span id="cb178-8"><a href="#cb178-8"></a>      friend constexpr bool</span>
<span id="cb178-9"><a href="#cb178-9"></a>        operator==(const move_iterator&amp; x, const move_sentinel&lt;S&gt;&amp; y);</span>
<span id="cb178-10"><a href="#cb178-10"></a><span class="st">-   template&lt;Sentinel&lt;Iterator&gt; S&gt;</span></span>
<span id="cb178-11"><a href="#cb178-11"></a><span class="st">-     friend constexpr bool</span></span>
<span id="cb178-12"><a href="#cb178-12"></a><span class="st">-       operator==(const move_sentinel&lt;S&gt;&amp; x, const move_iterator&amp; y);</span></span>
<span id="cb178-13"><a href="#cb178-13"></a><span class="st">-   template&lt;Sentinel&lt;Iterator&gt; S&gt;</span></span>
<span id="cb178-14"><a href="#cb178-14"></a><span class="st">-     friend constexpr bool</span></span>
<span id="cb178-15"><a href="#cb178-15"></a><span class="st">-       operator!=(const move_iterator&amp; x, const move_sentinel&lt;S&gt;&amp; y);</span></span>
<span id="cb178-16"><a href="#cb178-16"></a><span class="st">-   template&lt;Sentinel&lt;Iterator&gt; S&gt;</span></span>
<span id="cb178-17"><a href="#cb178-17"></a><span class="st">-     friend constexpr bool</span></span>
<span id="cb178-18"><a href="#cb178-18"></a><span class="st">-       operator!=(const move_sentinel&lt;S&gt;&amp; x, const move_iterator&amp; y);</span></span>
<span id="cb178-19"><a href="#cb178-19"></a>    template&lt;SizedSentinel&lt;Iterator&gt; S&gt;</span>
<span id="cb178-20"><a href="#cb178-20"></a>      friend constexpr iter_difference_t&lt;Iterator&gt;</span>
<span id="cb178-21"><a href="#cb178-21"></a>        operator-(const move_sentinel&lt;S&gt;&amp; x, const move_iterator&amp; y);</span>
<span id="cb178-22"><a href="#cb178-22"></a>        </span>
<span id="cb178-23"><a href="#cb178-23"></a>    [...]</span>
<span id="cb178-24"><a href="#cb178-24"></a>  };</span>
<span id="cb178-25"><a href="#cb178-25"></a>}</span></code></pre></div>
</blockquote>
<p>Remove <code class="sourceCode cpp"><span class="op">!=</span></code> and add <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> to 23.5.3.7 [move.iter.op.comp]:</p>
<blockquote>
<div class="sourceCode" id="cb179"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb179-1"><a href="#cb179-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Iterator1, <span class="kw">class</span> Iterator2<span class="op">&gt;</span></span>
<span id="cb179-2"><a href="#cb179-2"></a>  <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> move_iterator<span class="op">&lt;</span>Iterator1<span class="op">&gt;&amp;</span> x,</span>
<span id="cb179-3"><a href="#cb179-3"></a>                            <span class="kw">const</span> move_iterator<span class="op">&lt;</span>Iterator2<span class="op">&gt;&amp;</span> y<span class="op">)</span>;</span>
<span id="cb179-4"><a href="#cb179-4"></a><span class="kw">template</span><span class="op">&lt;</span>Sentinel<span class="op">&lt;</span>Iterator<span class="op">&gt;</span> S<span class="op">&gt;</span></span>
<span id="cb179-5"><a href="#cb179-5"></a>  <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> move_iterator<span class="op">&amp;</span> x,</span>
<span id="cb179-6"><a href="#cb179-6"></a>                                   <span class="kw">const</span> move_sentinel<span class="op">&lt;</span>S<span class="op">&gt;&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;Sentinel&lt;Iterator&gt; S&gt;
  friend constexpr bool operator==(const move_sentinel&lt;S&gt;&amp; x,
                                   const move_iterator&amp; y);</code></pre>

</div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Constraints</em>: <code class="sourceCode cpp">x<span class="op">.</span>base<span class="op">()</span> <span class="op">==</span> y<span class="op">.</span>base<span class="op">()</span></code> is well-formed and convertible to <code class="sourceCode cpp"><span class="dt">bool</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp">x<span class="op">.</span>base<span class="op">()</span> <span class="op">==</span> y<span class="op">.</span>base<span class="op">()</span></code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class Iterator1, class Iterator2&gt;
  constexpr bool operator!=(const move_iterator&lt;Iterator1&gt;&amp; x,
                            const move_iterator&lt;Iterator2&gt;&amp; y);
template&lt;Sentinel&lt;Iterator&gt; S&gt;
  friend constexpr bool operator!=(const move_iterator&amp; x,
                                   const move_sentinel&lt;S&gt;&amp; y);
template&lt;Sentinel&lt;Iterator&gt; S&gt;
  friend constexpr bool operator!=(const move_sentinel&lt;S&gt;&amp; x,
                                   const move_iterator&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Constraints</em>: <code class="sourceCode cpp">x<span class="op">.</span>base<span class="op">()</span> <span class="op">==</span> y<span class="op">.</span>base<span class="op">()</span></code> is well-formed and convertible to <code class="sourceCode cpp"><span class="dt">bool</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span></code>.</p>
</div>
<div class="sourceCode" id="cb182"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb182-1"><a href="#cb182-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Iterator1, <span class="kw">class</span> Iterator2<span class="op">&gt;</span></span>
<span id="cb182-2"><a href="#cb182-2"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span><span class="kw">const</span> move_iterator<span class="op">&lt;</span>Iterator1<span class="op">&gt;&amp;</span> x, <span class="kw">const</span> move_iterator<span class="op">&lt;</span>Iterator2<span class="op">&gt;&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Constraints</em>: <code class="sourceCode cpp">x<span class="op">.</span>base<span class="op">()</span> <span class="op">&lt;</span> y<span class="op">.</span>base<span class="op">()</span></code> is well-formed and convertible to <code class="sourceCode cpp"><span class="dt">bool</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Returns</em>: <code class="sourceCode cpp">x<span class="op">.</span>base<span class="op">()</span> <span class="op">&lt;</span> y<span class="op">.</span>base<span class="op">()</span></code>.</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb183-1"><a href="#cb183-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Iterator1, <span class="kw">class</span> Iterator2<span class="op">&gt;</span></span>
<span id="cb183-2"><a href="#cb183-2"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;(</span><span class="kw">const</span> move_iterator<span class="op">&lt;</span>Iterator1<span class="op">&gt;&amp;</span> x, <span class="kw">const</span> move_iterator<span class="op">&lt;</span>Iterator2<span class="op">&gt;&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Constraints</em>: <code class="sourceCode cpp">y<span class="op">.</span>base<span class="op">()</span> <span class="op">&lt;</span> x<span class="op">.</span>base<span class="op">()</span></code> is well-formed and convertible to <code class="sourceCode cpp"><span class="dt">bool</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">8</a></span> <em>Returns</em>: <code class="sourceCode cpp">y <span class="op">&lt;</span> x</code>.</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb184-1"><a href="#cb184-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Iterator1, <span class="kw">class</span> Iterator2<span class="op">&gt;</span></span>
<span id="cb184-2"><a href="#cb184-2"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span><span class="kw">const</span> move_iterator<span class="op">&lt;</span>Iterator1<span class="op">&gt;&amp;</span> x, <span class="kw">const</span> move_iterator<span class="op">&lt;</span>Iterator2<span class="op">&gt;&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">9</a></span> <em>Constraints</em>: <code class="sourceCode cpp">y<span class="op">.</span>base<span class="op">()</span> <span class="op">&lt;</span> x<span class="op">.</span>base<span class="op">()</span></code> is well-formed and convertible to <code class="sourceCode cpp"><span class="dt">bool</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">10</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(</span>y <span class="op">&lt;</span> x<span class="op">)</span></code>.</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb185-1"><a href="#cb185-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> Iterator1, <span class="kw">class</span> Iterator2<span class="op">&gt;</span></span>
<span id="cb185-2"><a href="#cb185-2"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><span class="kw">const</span> move_iterator<span class="op">&lt;</span>Iterator1<span class="op">&gt;&amp;</span> x, <span class="kw">const</span> move_iterator<span class="op">&lt;</span>Iterator2<span class="op">&gt;&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">11</a></span> <em>Constraints</em>: <code class="sourceCode cpp">x<span class="op">.</span>base<span class="op">()</span> <span class="op">&lt;</span> y<span class="op">.</span>base<span class="op">()</span></code> is well-formed and convertible to <code class="sourceCode cpp"><span class="dt">bool</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">12</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(</span>x <span class="op">&lt;</span> y<span class="op">)</span></code>.</p>
<div class="addu">
<pre><code>template&lt;class Iterator1, ThreeWayComparableWith&lt;Iterator1&gt; Iterator2&gt;
  constexpr compare_three_way_result_t&lt;Iterator1, Iterator2&gt;
    operator&lt;=&gt;(const move_iterator&lt;Iterator1&gt;&amp; x,
                const move_iterator&lt;Iterator2&gt;&amp; y);     </code></pre>
<p><span class="marginalizedparent"><a class="marginalized">13</a></span> <em>Returns</em>: <code class="sourceCode cpp">x<span class="op">.</span>base<span class="op">()</span> <span class="op">&lt;=&gt;</span> y<span class="op">.</span>base<span class="op">()</span></code>.</p>
</div>
</blockquote>
<p>Remove <code class="sourceCode cpp"><span class="op">!=</span></code> from 23.5.4.1 [common.iterator]:</p>
<blockquote>
<div class="sourceCode" id="cb187"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb187-1"><a href="#cb187-1"></a>namespace std {</span>
<span id="cb187-2"><a href="#cb187-2"></a>  template&lt;Iterator I, Sentinel&lt;I&gt; S&gt;</span>
<span id="cb187-3"><a href="#cb187-3"></a>    requires (!Same&lt;I, S&gt;)</span>
<span id="cb187-4"><a href="#cb187-4"></a>  class common_iterator {</span>
<span id="cb187-5"><a href="#cb187-5"></a>  public:</span>
<span id="cb187-6"><a href="#cb187-6"></a>    [...]</span>
<span id="cb187-7"><a href="#cb187-7"></a>    </span>
<span id="cb187-8"><a href="#cb187-8"></a></span>
<span id="cb187-9"><a href="#cb187-9"></a>    template&lt;class I2, Sentinel&lt;I&gt; S2&gt;</span>
<span id="cb187-10"><a href="#cb187-10"></a>      requires Sentinel&lt;S, I2&gt;</span>
<span id="cb187-11"><a href="#cb187-11"></a>    friend bool operator==(</span>
<span id="cb187-12"><a href="#cb187-12"></a>      const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);</span>
<span id="cb187-13"><a href="#cb187-13"></a>    template&lt;class I2, Sentinel&lt;I&gt; S2&gt;</span>
<span id="cb187-14"><a href="#cb187-14"></a>      requires Sentinel&lt;S, I2&gt; &amp;&amp; EqualityComparableWith&lt;I, I2&gt;</span>
<span id="cb187-15"><a href="#cb187-15"></a>    friend bool operator==(</span>
<span id="cb187-16"><a href="#cb187-16"></a>      const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);</span>
<span id="cb187-17"><a href="#cb187-17"></a><span class="st">-   template&lt;class I2, Sentinel&lt;I&gt; S2&gt;</span></span>
<span id="cb187-18"><a href="#cb187-18"></a><span class="st">-     requires Sentinel&lt;S, I2&gt;</span></span>
<span id="cb187-19"><a href="#cb187-19"></a><span class="st">-   friend bool operator!=(</span></span>
<span id="cb187-20"><a href="#cb187-20"></a><span class="st">-     const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);</span></span>
<span id="cb187-21"><a href="#cb187-21"></a></span>
<span id="cb187-22"><a href="#cb187-22"></a>    [...]</span>
<span id="cb187-23"><a href="#cb187-23"></a>  };</span>
<span id="cb187-24"><a href="#cb187-24"></a>}  </span></code></pre></div>
</blockquote>
<p>Remove <code class="sourceCode cpp"><span class="op">!=</span></code> from 23.5.4.6 [common.iter.cmp]:</p>
<blockquote>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class I2, Sentinel&lt;I&gt; S2&gt;
  requires Sentinel&lt;S, I2&gt;
friend bool operator!=(
  const common_iterator&amp; x, const common_iterator&lt;I2, S2&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span>;</code></p>
</div>
</blockquote>
<p>Change 23.5.6.1 [counted.iterator]:</p>
<blockquote>
<div class="sourceCode" id="cb189"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb189-1"><a href="#cb189-1"></a>namespace std {</span>
<span id="cb189-2"><a href="#cb189-2"></a>  template&lt;Iterator I&gt;</span>
<span id="cb189-3"><a href="#cb189-3"></a>  class counted_iterator {</span>
<span id="cb189-4"><a href="#cb189-4"></a>  public:</span>
<span id="cb189-5"><a href="#cb189-5"></a>    [...]</span>
<span id="cb189-6"><a href="#cb189-6"></a></span>
<span id="cb189-7"><a href="#cb189-7"></a>    template&lt;Common&lt;I&gt; I2&gt;</span>
<span id="cb189-8"><a href="#cb189-8"></a>      friend constexpr bool operator==(</span>
<span id="cb189-9"><a href="#cb189-9"></a>        const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);</span>
<span id="cb189-10"><a href="#cb189-10"></a>    friend constexpr bool operator==(</span>
<span id="cb189-11"><a href="#cb189-11"></a>      const counted_iterator&amp; x, default_sentinel_t);</span>
<span id="cb189-12"><a href="#cb189-12"></a><span class="st">-   friend constexpr bool operator==(</span></span>
<span id="cb189-13"><a href="#cb189-13"></a><span class="st">-     default_sentinel_t, const counted_iterator&amp; x);</span></span>
<span id="cb189-14"><a href="#cb189-14"></a></span>
<span id="cb189-15"><a href="#cb189-15"></a><span class="st">-   template&lt;Common&lt;I&gt; I2&gt;</span></span>
<span id="cb189-16"><a href="#cb189-16"></a><span class="st">-     friend constexpr bool operator!=(</span></span>
<span id="cb189-17"><a href="#cb189-17"></a><span class="st">-       const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);</span></span>
<span id="cb189-18"><a href="#cb189-18"></a><span class="st">-   friend constexpr bool operator!=(</span></span>
<span id="cb189-19"><a href="#cb189-19"></a><span class="st">-     const counted_iterator&amp; x, default_sentinel_t y);</span></span>
<span id="cb189-20"><a href="#cb189-20"></a><span class="st">-   friend constexpr bool operator!=(</span></span>
<span id="cb189-21"><a href="#cb189-21"></a><span class="st">-     default_sentinel_t x, const counted_iterator&amp; y);</span></span>
<span id="cb189-22"><a href="#cb189-22"></a></span>
<span id="cb189-23"><a href="#cb189-23"></a><span class="st">-   template&lt;Common&lt;I&gt; I2&gt;</span></span>
<span id="cb189-24"><a href="#cb189-24"></a><span class="st">-     friend constexpr bool operator&lt;(</span></span>
<span id="cb189-25"><a href="#cb189-25"></a><span class="st">-       const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);</span></span>
<span id="cb189-26"><a href="#cb189-26"></a><span class="st">-   template&lt;Common&lt;I&gt; I2&gt;</span></span>
<span id="cb189-27"><a href="#cb189-27"></a><span class="st">-     friend constexpr bool operator&gt;(</span></span>
<span id="cb189-28"><a href="#cb189-28"></a><span class="st">-       const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);</span></span>
<span id="cb189-29"><a href="#cb189-29"></a><span class="st">-   template&lt;Common&lt;I&gt; I2&gt;</span></span>
<span id="cb189-30"><a href="#cb189-30"></a><span class="st">-     friend constexpr bool operator&lt;=(</span></span>
<span id="cb189-31"><a href="#cb189-31"></a><span class="st">-       const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);</span></span>
<span id="cb189-32"><a href="#cb189-32"></a><span class="st">-   template&lt;Common&lt;I&gt; I2&gt;</span></span>
<span id="cb189-33"><a href="#cb189-33"></a><span class="st">-     friend constexpr bool operator&gt;=(</span></span>
<span id="cb189-34"><a href="#cb189-34"></a><span class="st">-       const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);</span></span>
<span id="cb189-35"><a href="#cb189-35"></a><span class="va">+   template&lt;Common&lt;I&gt; I2&gt;</span></span>
<span id="cb189-36"><a href="#cb189-36"></a><span class="va">+     friend constexpr strong_ordering operator&lt;=&gt;(</span></span>
<span id="cb189-37"><a href="#cb189-37"></a><span class="va">+       const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);</span></span>
<span id="cb189-38"><a href="#cb189-38"></a></span>
<span id="cb189-39"><a href="#cb189-39"></a>    [...]       </span>
<span id="cb189-40"><a href="#cb189-40"></a>  };</span>
<span id="cb189-41"><a href="#cb189-41"></a>}</span></code></pre></div>
</blockquote>
<p>Make the same changes to 23.5.6.6 [counted.iter.comp]:</p>
<blockquote>
<div class="sourceCode" id="cb190"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb190-1"><a href="#cb190-1"></a><span class="kw">template</span><span class="op">&lt;</span>Common<span class="op">&lt;</span>I<span class="op">&gt;</span> I2<span class="op">&gt;</span></span>
<span id="cb190-2"><a href="#cb190-2"></a>  <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span></span>
<span id="cb190-3"><a href="#cb190-3"></a>    <span class="kw">const</span> counted_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> counted_iterator<span class="op">&lt;</span>I2<span class="op">&gt;&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Expects</em>: <code class="sourceCode cpp">x</code> and <code class="sourceCode cpp">y</code> refer to elements of the same sequence ([counted.iterator]).</p>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>length <span class="op">==</span> y<span class="op">.</span>length;</code></p>
<div class="sourceCode" id="cb191"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb191-1"><a href="#cb191-1"></a>  <span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span></span>
<span id="cb191-2"><a href="#cb191-2"></a>    <span class="kw">const</span> counted_iterator<span class="op">&amp;</span> x, default_sentinel_t<span class="op">)</span>;</span></code></pre></div>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator==(
  default_sentinel_t, const counted_iterator&amp; x);</code></pre>

</div>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>length <span class="op">==</span> <span class="dv">0</span>;</code></p>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;Common&lt;I&gt; I2&gt;
  friend constexpr bool operator!=(
    const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);
friend constexpr bool operator!=(
  const counted_iterator&amp; x, default_sentinel_t y);
friend constexpr bool operator!=(
  default_sentinel_t x, const counted_iterator&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span>;</code></p>
<pre><code>template&lt;Common&lt;I&gt; I2&gt;
  friend constexpr bool operator&lt;(
    const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Expects</em>: <code class="sourceCode cpp">x</code> and <code class="sourceCode cpp">y</code> refer to elements of the same sequence ([counted.iterator]).</p>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> y<span class="op">.</span>length <span class="op">&lt;</span> x<span class="op">.</span>length;</code></p>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> [<em>Note</em>: The argument order in the <em>Effects</em>: element is reversed because length counts down, not up. —<em>end note</em>]</p>
<pre><code>template&lt;Common&lt;I&gt; I2&gt;
  friend constexpr bool operator&gt;(
    const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">8</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> y <span class="op">&lt;</span> x;</code></p>
<pre><code>template&lt;Common&lt;I&gt; I2&gt;
  friend constexpr bool operator&lt;=(
    const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">9</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>y <span class="op">&lt;</span> x<span class="op">)</span>;</code></p>
<pre><code>template&lt;Common&lt;I&gt; I2&gt;
  friend constexpr bool operator&gt;=(
    const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">10</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">&lt;</span> y<span class="op">)</span>;</code></p>
</div>
<div class="addu">
<pre><code>template&lt;Common&lt;I&gt; I2&gt;
  friend constexpr strong_ordering operator&lt;=&gt;(
    const counted_iterator&amp; x, const counted_iterator&lt;I2&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">11</a></span> <em>Expects</em>: <code class="sourceCode cpp">x</code> and <code class="sourceCode cpp">y</code> refer to elements of the same sequence ([counted.iterator]).</p>
<p><span class="marginalizedparent"><a class="marginalized">12</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> y<span class="op">.</span>length <span class="op">&lt;=&gt;</span> x<span class="op">.</span>length;</code></p>
<p><span class="marginalizedparent"><a class="marginalized">13</a></span> [<em>Note</em>: The argument order in the <em>Effects</em>: element is reversed because length counts down, not up. —<em>end note</em>]</p>
</div>
</blockquote>
<p>Change 23.5.7.1 [unreachable.sentinel] to just define what will become the single operator in the synopsis:</p>
<blockquote>
<div class="sourceCode" id="cb199"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb199-1"><a href="#cb199-1"></a>  namespace std {</span>
<span id="cb199-2"><a href="#cb199-2"></a>    struct unreachable_sentinel_t {</span>
<span id="cb199-3"><a href="#cb199-3"></a>      template&lt;WeaklyIncrementable I&gt;</span>
<span id="cb199-4"><a href="#cb199-4"></a><span class="st">-       friend constexpr bool operator==(unreachable_sentinel_t, const I&amp;) noexcept@[;]{.diffdel}@</span></span>
<span id="cb199-5"><a href="#cb199-5"></a><span class="va">+       friend constexpr bool operator==(unreachable_sentinel_t, const I&amp;) noexcept</span></span>
<span id="cb199-6"><a href="#cb199-6"></a><span class="va">+         { return false; }</span></span>
<span id="cb199-7"><a href="#cb199-7"></a><span class="st">-       friend constexpr bool operator==(unreachable_sentinel_t, const I&amp;) noexcept;</span></span>
<span id="cb199-8"><a href="#cb199-8"></a><span class="st">-     template&lt;WeaklyIncrementable I&gt;</span></span>
<span id="cb199-9"><a href="#cb199-9"></a><span class="st">-       friend constexpr bool operator==(const I&amp;, unreachable_sentinel_t) noexcept;</span></span>
<span id="cb199-10"><a href="#cb199-10"></a><span class="st">-     template&lt;WeaklyIncrementable I&gt;</span></span>
<span id="cb199-11"><a href="#cb199-11"></a><span class="st">-       friend constexpr bool operator!=(unreachable_sentinel_t, const I&amp;) noexcept;</span></span>
<span id="cb199-12"><a href="#cb199-12"></a><span class="st">-     template&lt;WeaklyIncrementable I&gt;</span></span>
<span id="cb199-13"><a href="#cb199-13"></a><span class="st">-       friend constexpr bool operator!=(const I&amp;, unreachable_sentinel_t) noexcept;</span></span>
<span id="cb199-14"><a href="#cb199-14"></a>    };</span>
<span id="cb199-15"><a href="#cb199-15"></a>  }</span></code></pre></div>
</blockquote>
<p>Remove all of 23.5.7.2 [unreachable.sentinel.cmp] (which is just the definitions of <code class="sourceCode cpp"><span class="op">==</span></code> and <code class="sourceCode cpp"><span class="op">!=</span></code>)</p>
<blockquote>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;WeaklyIncrementable I&gt;
  friend constexpr bool operator==(unreachable_sentinel_t, const I&amp;) noexcept;
template&lt;WeaklyIncrementable I&gt;
  friend constexpr bool operator==(const I&amp;, unreachable_sentinel_t) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="kw">false</span></code>.</p>
<pre><code>template&lt;WeaklyIncrementable I&gt;
  friend constexpr bool operator!=(unreachable_sentinel_t, const I&amp;) noexcept;
template&lt;WeaklyIncrementable I&gt;
  friend constexpr bool operator!=(const I&amp;, unreachable_sentinel_t) noexcept;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="kw">true</span></code>.</p>
</div>
</blockquote>
<p>Change 23.6.1 [istream.iterator]:</p>
<blockquote>
<div class="sourceCode" id="cb202"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb202-1"><a href="#cb202-1"></a>namespace std {</span>
<span id="cb202-2"><a href="#cb202-2"></a>  template&lt;class T, class charT = char, class traits = char_traits&lt;charT&gt;,</span>
<span id="cb202-3"><a href="#cb202-3"></a>           class Distance = ptrdiff_t&gt;</span>
<span id="cb202-4"><a href="#cb202-4"></a>  class istream_iterator {</span>
<span id="cb202-5"><a href="#cb202-5"></a>  public:</span>
<span id="cb202-6"><a href="#cb202-6"></a>    [...]</span>
<span id="cb202-7"><a href="#cb202-7"></a></span>
<span id="cb202-8"><a href="#cb202-8"></a>    friend bool operator==(const istream_iterator&amp; i, default_sentinel_t);</span>
<span id="cb202-9"><a href="#cb202-9"></a><span class="st">-   friend bool operator==(default_sentinel_t, const istream_iterator&amp; i);</span></span>
<span id="cb202-10"><a href="#cb202-10"></a><span class="st">-   friend bool operator!=(const istream_iterator&amp; x, default_sentinel_t y);</span></span>
<span id="cb202-11"><a href="#cb202-11"></a><span class="st">-   friend bool operator!=(default_sentinel_t x, const istream_iterator&amp; y);</span></span>
<span id="cb202-12"><a href="#cb202-12"></a></span>
<span id="cb202-13"><a href="#cb202-13"></a>    [...]</span>
<span id="cb202-14"><a href="#cb202-14"></a>  };</span>
<span id="cb202-15"><a href="#cb202-15"></a>}</span></code></pre></div>
</blockquote>
<p>Change 23.6.1.2 [istream.iterator.ops]:</p>
<blockquote>
<div class="sourceCode" id="cb203"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb203-1"><a href="#cb203-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> charT, <span class="kw">class</span> traits, <span class="kw">class</span> Distance<span class="op">&gt;</span></span>
<span id="cb203-2"><a href="#cb203-2"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> istream_iterator<span class="op">&lt;</span>T,charT,traits,Distance<span class="op">&gt;&amp;</span> x,</span>
<span id="cb203-3"><a href="#cb203-3"></a>                  <span class="kw">const</span> istream_iterator<span class="op">&lt;</span>T,charT,traits,Distance<span class="op">&gt;&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">10</a></span> <em>Returns</em>: <code class="sourceCode cpp">x<span class="op">.</span>in_stream <span class="op">==</span> y<span class="op">.</span>in_stream</code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>friend bool operator==(default_sentinel_t, const istream_iterator&amp; i);</code></pre>

</div>
<div class="sourceCode" id="cb205"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb205-1"><a href="#cb205-1"></a><span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> istream_iterator<span class="op">&amp;</span> i, default_sentinel_t<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">11</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!</span>i<span class="op">.</span>in_stream</code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class T, class charT, class traits, class Distance&gt;
  bool operator!=(const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; x,
                  const istream_iterator&lt;T,charT,traits,Distance&gt;&amp; y);
friend bool operator!=(default_sentinel_t x, const istream_iterator&amp; y);
friend bool operator!=(const istream_iterator&amp; x, default_sentinel_t y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">12</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span></code></p>
</div>
</blockquote>
<p>Change 23.6.3 [istreambuf.iterator]:</p>
<blockquote>
<div class="sourceCode" id="cb207"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb207-1"><a href="#cb207-1"></a>namespace std {</span>
<span id="cb207-2"><a href="#cb207-2"></a>  template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;</span>
<span id="cb207-3"><a href="#cb207-3"></a>  class istreambuf_iterator {</span>
<span id="cb207-4"><a href="#cb207-4"></a>    [...]</span>
<span id="cb207-5"><a href="#cb207-5"></a>    </span>
<span id="cb207-6"><a href="#cb207-6"></a><span class="st">-   friend bool operator==(default_sentinel_t s, const istreambuf_iterator&amp; i);</span></span>
<span id="cb207-7"><a href="#cb207-7"></a>    friend bool operator==(const istreambuf_iterator&amp; i, default_sentinel_t s);</span>
<span id="cb207-8"><a href="#cb207-8"></a><span class="st">-   friend bool operator!=(default_sentinel_t a, const istreambuf_iterator&amp; b);</span></span>
<span id="cb207-9"><a href="#cb207-9"></a><span class="st">-   friend bool operator!=(const istreambuf_iterator&amp; a, default_sentinel_t b);</span></span>
<span id="cb207-10"><a href="#cb207-10"></a></span>
<span id="cb207-11"><a href="#cb207-11"></a>    [...]</span>
<span id="cb207-12"><a href="#cb207-12"></a>  };</span>
<span id="cb207-13"><a href="#cb207-13"></a>}   </span></code></pre></div>
</blockquote>
<p>Change 23.6.3.3 [istreambuf.iterator.ops]:</p>
<blockquote>
<div class="sourceCode" id="cb208"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb208-1"><a href="#cb208-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> charT, <span class="kw">class</span> traits<span class="op">&gt;</span></span>
<span id="cb208-2"><a href="#cb208-2"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> istreambuf_iterator<span class="op">&lt;</span>charT,traits<span class="op">&gt;&amp;</span> a,</span>
<span id="cb208-3"><a href="#cb208-3"></a>                  <span class="kw">const</span> istreambuf_iterator<span class="op">&lt;</span>charT,traits<span class="op">&gt;&amp;</span> b<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Returns</em>: <code class="sourceCode cpp">a<span class="op">.</span>equal<span class="op">(</span>b<span class="op">)</span></code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>friend bool operator==(default_sentinel_t s, const istreambuf_iterator&amp; i);</code></pre>

</div>
<div class="sourceCode" id="cb210"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb210-1"><a href="#cb210-1"></a><span class="kw">friend</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> istreambuf_iterator<span class="op">&amp;</span> i, default_sentinel_t s<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Returns</em>: <code class="sourceCode cpp">i<span class="op">.</span>equal<span class="op">(</span>s<span class="op">)</span></code>.</p>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class charT, class traits&gt;
  bool operator!=(const istreambuf_iterator&lt;charT,traits&gt;&amp; a,
                  const istreambuf_iterator&lt;charT,traits&gt;&amp; b);
friend bool operator!=(default_sentinel_t a, const istreambuf_iterator&amp; b);
friend bool operator!=(const istreambuf_iterator&amp; a, default_sentinel_t b);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">8</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!</span>a<span class="op">.</span>equal<span class="op">(</span>b<span class="op">)</span></code>.</p>
</div>
</blockquote>
<h2 id="clause-24-ranges-library"><span class="header-section-number">5.9</span> Clause 24: Ranges library<a href="#clause-24-ranges-library" class="self-link"></a></h2>
<p>Remove no-longer-needed <code class="sourceCode cpp"><span class="op">==</span></code> and <code class="sourceCode cpp"><span class="op">!=</span></code> operators from several iterators. Add a constrained <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> to <code class="sourceCode cpp">iota_view<span class="op">::</span>iterator</code> and <code class="sourceCode cpp">transform_view<span class="op">::</span>iterator</code>.</p>
<p>Change 24.6.3.3 [range.iota.iterator]:</p>
<blockquote>
<div class="sourceCode" id="cb212"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb212-1"><a href="#cb212-1"></a>namespace std::ranges {</span>
<span id="cb212-2"><a href="#cb212-2"></a>  template&lt;class W, class Bound&gt;</span>
<span id="cb212-3"><a href="#cb212-3"></a>  struct iota_view&lt;W, Bound&gt;::iterator {</span>
<span id="cb212-4"><a href="#cb212-4"></a>    [...]</span>
<span id="cb212-5"><a href="#cb212-5"></a></span>
<span id="cb212-6"><a href="#cb212-6"></a>    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)</span>
<span id="cb212-7"><a href="#cb212-7"></a>      requires EqualityComparable&lt;W&gt;;</span>
<span id="cb212-8"><a href="#cb212-8"></a><span class="st">-   friend constexpr bool operator!=(const iterator&amp; x, const iterator&amp; y)</span></span>
<span id="cb212-9"><a href="#cb212-9"></a><span class="st">-     requires EqualityComparable&lt;W&gt;;</span></span>
<span id="cb212-10"><a href="#cb212-10"></a></span>
<span id="cb212-11"><a href="#cb212-11"></a>    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)</span>
<span id="cb212-12"><a href="#cb212-12"></a>      requires StrictTotallyOrdered&lt;W&gt;;</span>
<span id="cb212-13"><a href="#cb212-13"></a>    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)</span>
<span id="cb212-14"><a href="#cb212-14"></a>      requires StrictTotallyOrdered&lt;W&gt;;</span>
<span id="cb212-15"><a href="#cb212-15"></a>    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)</span>
<span id="cb212-16"><a href="#cb212-16"></a>      requires StrictTotallyOrdered&lt;W&gt;;</span>
<span id="cb212-17"><a href="#cb212-17"></a>    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)</span>
<span id="cb212-18"><a href="#cb212-18"></a>      requires StrictTotallyOrdered&lt;W&gt;;</span>
<span id="cb212-19"><a href="#cb212-19"></a><span class="va">+   friend constexpr compare_three_way_result_t&lt;W&gt; operator&lt;=&gt;(</span></span>
<span id="cb212-20"><a href="#cb212-20"></a><span class="va">+       const iterator&amp; x, const iterator&amp; y)</span></span>
<span id="cb212-21"><a href="#cb212-21"></a><span class="va">+     requires StrictTotallyOrdered&lt;W&gt; &amp;&amp; ThreeWayComparable&lt;W&gt;;</span></span>
<span id="cb212-22"><a href="#cb212-22"></a>    [...]</span>
<span id="cb212-23"><a href="#cb212-23"></a>  };</span>
<span id="cb212-24"><a href="#cb212-24"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb213"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb213-1"><a href="#cb213-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> iterator<span class="op">&amp;</span> x, <span class="kw">const</span> iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb213-2"><a href="#cb213-2"></a>  <span class="kw">requires</span> EqualityComparable<span class="op">&lt;</span>W<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">14</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>value_ <span class="op">==</span> y<span class="op">.</span>value_;</code></p>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator!=(const iterator&amp; x, const iterator&amp; y)
  requires EqualityComparable&lt;W&gt;;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">15</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span>;</code></p>
</div>
<div class="sourceCode" id="cb215"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb215-1"><a href="#cb215-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span><span class="kw">const</span> iterator<span class="op">&amp;</span> x, <span class="kw">const</span> iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb215-2"><a href="#cb215-2"></a>  <span class="kw">requires</span> StrictTotallyOrdered<span class="op">&lt;</span>W<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">16</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>value_ <span class="op">&lt;</span> y<span class="op">.</span>value_;</code></p>
<div class="sourceCode" id="cb216"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb216-1"><a href="#cb216-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;(</span><span class="kw">const</span> iterator<span class="op">&amp;</span> x, <span class="kw">const</span> iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb216-2"><a href="#cb216-2"></a>  <span class="kw">requires</span> StrictTotallyOrdered<span class="op">&lt;</span>W<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">17</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> y <span class="op">&lt;</span> x;</code></p>
<div class="sourceCode" id="cb217"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb217-1"><a href="#cb217-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span><span class="kw">const</span> iterator<span class="op">&amp;</span> x, <span class="kw">const</span> iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb217-2"><a href="#cb217-2"></a>  <span class="kw">requires</span> StrictTotallyOrdered<span class="op">&lt;</span>W<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">18</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>y <span class="op">&lt;</span> x<span class="op">)</span>;</code></p>
<div class="sourceCode" id="cb218"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb218-1"><a href="#cb218-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><span class="kw">const</span> iterator<span class="op">&amp;</span> x, <span class="kw">const</span> iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb218-2"><a href="#cb218-2"></a>  <span class="kw">requires</span> StrictTotallyOrdered<span class="op">&lt;</span>W<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">19</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">&lt;</span> y<span class="op">)</span>;</code></p>
<div class="addu">
<pre><code>friend constexpr compare_three_way_result_t&lt;W&gt;
  operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
    requires StrictTotallyOrdered&lt;W&gt; &amp;&amp; ThreeWayComparable&lt;W&gt;;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">19</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>value_ <span class="op">&lt;=&gt;</span> y<span class="op">.</span>value_;</code></p>
</div>
</blockquote>
<p>Change 24.6.3.4 [range.iota.sentinel]:</p>
<blockquote>
<div class="sourceCode" id="cb220"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb220-1"><a href="#cb220-1"></a>namespace std::ranges {</span>
<span id="cb220-2"><a href="#cb220-2"></a>  template&lt;class W, class Bound&gt;</span>
<span id="cb220-3"><a href="#cb220-3"></a>  struct iota_view&lt;W, Bound&gt;::sentinel {</span>
<span id="cb220-4"><a href="#cb220-4"></a>    [...]</span>
<span id="cb220-5"><a href="#cb220-5"></a></span>
<span id="cb220-6"><a href="#cb220-6"></a>    friend constexpr bool operator==(const iterator&amp; x, const sentinel&amp; y);</span>
<span id="cb220-7"><a href="#cb220-7"></a><span class="st">-   friend constexpr bool operator==(const sentinel&amp; x, const iterator&amp; y);</span></span>
<span id="cb220-8"><a href="#cb220-8"></a><span class="st">-   friend constexpr bool operator!=(const iterator&amp; x, const sentinel&amp; y);</span></span>
<span id="cb220-9"><a href="#cb220-9"></a><span class="st">-   friend constexpr bool operator!=(const sentinel&amp; x, const iterator&amp; y);</span></span>
<span id="cb220-10"><a href="#cb220-10"></a>  };</span>
<span id="cb220-11"><a href="#cb220-11"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb221"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb221-1"><a href="#cb221-1"></a><span class="kw">constexpr</span> <span class="kw">explicit</span> sentinel<span class="op">(</span>Bound bound<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Effects</em>: Initializes <code class="sourceCode cpp">bound_</code> with <code class="sourceCode cpp">bound</code>.</p>
<div class="sourceCode" id="cb222"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb222-1"><a href="#cb222-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> iterator<span class="op">&amp;</span> x, <span class="kw">const</span> sentinel<span class="op">&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>value_ <span class="op">==</span> y<span class="op">.</span>bound_;</code></p>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator==(const sentinel&amp; x, const iterator&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> y <span class="op">==</span> x;</code></p>
<pre><code>friend constexpr bool operator!=(const iterator&amp; x, const sentinel&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span>;</code></p>
<pre><code>friend constexpr bool operator!=(const sentinel&amp; x, const iterator&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>y <span class="op">==</span> x<span class="op">)</span>;</code></p>
</div>
</blockquote>
<p>Remove <code class="sourceCode cpp"><span class="op">!=</span></code> from 24.7.4.3 [range.filter.iterator]:</p>
<blockquote>
<div class="sourceCode" id="cb226"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb226-1"><a href="#cb226-1"></a>namespace std::ranges {</span>
<span id="cb226-2"><a href="#cb226-2"></a>  template&lt;class V, class Pred&gt;</span>
<span id="cb226-3"><a href="#cb226-3"></a>  class filter_view&lt;V, Pred&gt;::iterator {</span>
<span id="cb226-4"><a href="#cb226-4"></a>    [...]</span>
<span id="cb226-5"><a href="#cb226-5"></a></span>
<span id="cb226-6"><a href="#cb226-6"></a>    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)</span>
<span id="cb226-7"><a href="#cb226-7"></a>      requires EqualityComparable&lt;iterator_t&lt;V&gt;&gt;;</span>
<span id="cb226-8"><a href="#cb226-8"></a><span class="st">-   friend constexpr bool operator!=(const iterator&amp; x, const iterator&amp; y)</span></span>
<span id="cb226-9"><a href="#cb226-9"></a><span class="st">-     requires EqualityComparable&lt;iterator_t&lt;V&gt;&gt;;</span></span>
<span id="cb226-10"><a href="#cb226-10"></a></span>
<span id="cb226-11"><a href="#cb226-11"></a>    [...]</span>
<span id="cb226-12"><a href="#cb226-12"></a>  };</span>
<span id="cb226-13"><a href="#cb226-13"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb227"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb227-1"><a href="#cb227-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> iterator<span class="op">&amp;</span> x, <span class="kw">const</span> iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb227-2"><a href="#cb227-2"></a>  <span class="kw">requires</span> EqualityComparable<span class="op">&lt;</span>iterator_t<span class="op">&lt;</span>V<span class="op">&gt;&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">13</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>current_ <span class="op">==</span> y<span class="op">.</span>current_;</code></p>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator!=(const iterator&amp; x, const iterator&amp; y)
  requires EqualityComparable&lt;iterator_t&lt;V&gt;&gt;;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">14</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span>;</code></p>
</div>
</blockquote>
<p>Change 24.7.4.4 [range.filter.sentinel]:</p>
<blockquote>
<div class="sourceCode" id="cb229"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb229-1"><a href="#cb229-1"></a>namespace std::ranges {</span>
<span id="cb229-2"><a href="#cb229-2"></a>  template&lt;class V, class Pred&gt;</span>
<span id="cb229-3"><a href="#cb229-3"></a>  class filter_view&lt;V, Pred&gt;::sentinel {</span>
<span id="cb229-4"><a href="#cb229-4"></a>    [...]</span>
<span id="cb229-5"><a href="#cb229-5"></a></span>
<span id="cb229-6"><a href="#cb229-6"></a>    friend constexpr bool operator==(const iterator&amp; x, const sentinel&amp; y);</span>
<span id="cb229-7"><a href="#cb229-7"></a><span class="st">-   friend constexpr bool operator==(const sentinel&amp; x, const iterator&amp; y);</span></span>
<span id="cb229-8"><a href="#cb229-8"></a><span class="st">-   friend constexpr bool operator!=(const iterator&amp; x, const sentinel&amp; y);</span></span>
<span id="cb229-9"><a href="#cb229-9"></a><span class="st">-   friend constexpr bool operator!=(const sentinel&amp; x, const iterator&amp; y);</span></span>
<span id="cb229-10"><a href="#cb229-10"></a>  };</span>
<span id="cb229-11"><a href="#cb229-11"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb230"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb230-1"><a href="#cb230-1"></a><span class="kw">constexpr</span> <span class="kw">explicit</span> sentinel<span class="op">(</span>filter_view<span class="op">&amp;</span> parent<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Effects</em>: Initializes <code class="sourceCode cpp">end_</code> with <code class="sourceCode cpp">ranges<span class="op">::</span>end<span class="op">(</span>parent<span class="op">)</span></code>.</p>
<div class="sourceCode" id="cb231"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb231-1"><a href="#cb231-1"></a><span class="kw">constexpr</span> sentinel_t<span class="op">&lt;</span>V<span class="op">&gt;</span> base<span class="op">()</span> <span class="kw">const</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> end_;</code></p>
<div class="sourceCode" id="cb232"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb232-1"><a href="#cb232-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> iterator<span class="op">&amp;</span> x, <span class="kw">const</span> sentinel<span class="op">&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>current_ <span class="op">==</span> y<span class="op">.</span>end_;</code></p>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator==(const sentinel&amp; x, const iterator&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> y <span class="op">==</span> x;</code></p>
<pre><code>friend constexpr bool operator!=(const iterator&amp; x, const sentinel&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span>;</code></p>
<pre><code>friend constexpr bool operator!=(const sentinel&amp; x, const iterator&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>y <span class="op">==</span> x<span class="op">)</span>;</code></p>
</div>
</blockquote>
<p>Change 24.7.5.3 [range.transform.iterator].</p>
<p>Given that the relational operators here all require <code class="sourceCode cpp">RandomAccessRange</code>, could we just provide a single <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> whose implementation is <code class="sourceCode cpp"><span class="op">(</span>x <span class="op">-</span> y<span class="op">)</span> <span class="op">&lt;=&gt;</span> <span class="dv">0</span></code>? Or at least <code class="sourceCode cpp">x <span class="op">&lt;=&gt;</span> y</code> if possible, else fall back to the subtraction?</p>
<blockquote>
<div class="sourceCode" id="cb236"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb236-1"><a href="#cb236-1"></a>namespace std::ranges {</span>
<span id="cb236-2"><a href="#cb236-2"></a>  template&lt;class V, class F&gt;</span>
<span id="cb236-3"><a href="#cb236-3"></a>  template&lt;bool Const&gt;</span>
<span id="cb236-4"><a href="#cb236-4"></a>  class transform_view&lt;V, F&gt;::iterator {</span>
<span id="cb236-5"><a href="#cb236-5"></a>    [...]</span>
<span id="cb236-6"><a href="#cb236-6"></a>    </span>
<span id="cb236-7"><a href="#cb236-7"></a></span>
<span id="cb236-8"><a href="#cb236-8"></a>    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)</span>
<span id="cb236-9"><a href="#cb236-9"></a>      requires EqualityComparable&lt;iterator_t&lt;Base&gt;&gt;;</span>
<span id="cb236-10"><a href="#cb236-10"></a><span class="st">-   friend constexpr bool operator!=(const iterator&amp; x, const iterator&amp; y)</span></span>
<span id="cb236-11"><a href="#cb236-11"></a><span class="st">-     requires EqualityComparable&lt;iterator_t&lt;Base&gt;&gt;;</span></span>
<span id="cb236-12"><a href="#cb236-12"></a></span>
<span id="cb236-13"><a href="#cb236-13"></a>    friend constexpr bool operator&lt;(const iterator&amp; x, const iterator&amp; y)</span>
<span id="cb236-14"><a href="#cb236-14"></a>      requires RandomAccessRange&lt;Base&gt;;</span>
<span id="cb236-15"><a href="#cb236-15"></a>    friend constexpr bool operator&gt;(const iterator&amp; x, const iterator&amp; y)</span>
<span id="cb236-16"><a href="#cb236-16"></a>      requires RandomAccessRange&lt;Base&gt;;</span>
<span id="cb236-17"><a href="#cb236-17"></a>    friend constexpr bool operator&lt;=(const iterator&amp; x, const iterator&amp; y)</span>
<span id="cb236-18"><a href="#cb236-18"></a>      requires RandomAccessRange&lt;Base&gt;;</span>
<span id="cb236-19"><a href="#cb236-19"></a>    friend constexpr bool operator&gt;=(const iterator&amp; x, const iterator&amp; y)</span>
<span id="cb236-20"><a href="#cb236-20"></a>      requires RandomAccessRange&lt;Base&gt;;</span>
<span id="cb236-21"><a href="#cb236-21"></a><span class="va">+   friend constexpr compare_three_way_result_t&lt;iterator_t&lt;Base&gt;&gt;</span></span>
<span id="cb236-22"><a href="#cb236-22"></a><span class="va">+     operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)</span></span>
<span id="cb236-23"><a href="#cb236-23"></a><span class="va">+       requires RandomAccessRange&lt;Base&gt; &amp;&amp; ThreeWayComparable&lt;iterator_t&lt;Base&gt;&gt;;</span></span>
<span id="cb236-24"><a href="#cb236-24"></a></span>
<span id="cb236-25"><a href="#cb236-25"></a>    [...]</span>
<span id="cb236-26"><a href="#cb236-26"></a>  };</span>
<span id="cb236-27"><a href="#cb236-27"></a>}  </span></code></pre></div>
<div class="sourceCode" id="cb237"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb237-1"><a href="#cb237-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> iterator<span class="op">&amp;</span> x, <span class="kw">const</span> iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb237-2"><a href="#cb237-2"></a>  <span class="kw">requires</span> EqualityComparable<span class="op">&lt;</span>iterator_t<span class="op">&lt;</span>Base<span class="op">&gt;&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">13</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>current_ <span class="op">==</span> y<span class="op">.</span>current_;</code></p>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator!=(const iterator&amp; x, const iterator&amp; y)
  requires EqualityComparable&lt;iterator_t&lt;Base&gt;&gt;;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">14</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span>;</code></p>
</div>
<div class="sourceCode" id="cb239"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb239-1"><a href="#cb239-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;(</span><span class="kw">const</span> iterator<span class="op">&amp;</span> x, <span class="kw">const</span> iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb239-2"><a href="#cb239-2"></a>  <span class="kw">requires</span> RandomAccessRange<span class="op">&lt;</span>Base<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">15</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>current_ <span class="op">&lt;</span> y<span class="op">.</span>current_;</code></p>
<div class="sourceCode" id="cb240"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb240-1"><a href="#cb240-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;(</span><span class="kw">const</span> iterator<span class="op">&amp;</span> x, <span class="kw">const</span> iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb240-2"><a href="#cb240-2"></a>  <span class="kw">requires</span> RandomAccessRange<span class="op">&lt;</span>Base<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">16</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> y <span class="op">&lt;</span> x;</code></p>
<div class="sourceCode" id="cb241"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb241-1"><a href="#cb241-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span><span class="kw">const</span> iterator<span class="op">&amp;</span> x, <span class="kw">const</span> iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb241-2"><a href="#cb241-2"></a>  <span class="kw">requires</span> RandomAccessRange<span class="op">&lt;</span>Base<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">17</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>y <span class="op">&lt;</span> x<span class="op">)</span>;</code></p>
<div class="sourceCode" id="cb242"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb242-1"><a href="#cb242-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><span class="kw">const</span> iterator<span class="op">&amp;</span> x, <span class="kw">const</span> iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb242-2"><a href="#cb242-2"></a>  <span class="kw">requires</span> RandomAccessRange<span class="op">&lt;</span>Base<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">18</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">&lt;</span> y<span class="op">)</span>;</code></p>
<div class="addu">
<pre><code>friend constexpr compare_three_way_result_t&lt;iterator_t&lt;Base&gt;&gt;
  operator&lt;=&gt;(const iterator&amp; x, const iterator&amp; y)
    requires RandomAccessRange&lt;Base&gt; &amp;&amp; ThreeWayComparable&lt;iterator_t&lt;Base&gt;&gt;;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">19</a></span> <em>Effects</em>: Equivalent to <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>current_ <span class="op">&lt;=&gt;</span> y<span class="op">.</span>current_;</code></p>
</div>
</blockquote>
<p>Change 24.7.5.4 [range.transform.sentinel]:</p>
<blockquote>
<div class="sourceCode" id="cb244"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb244-1"><a href="#cb244-1"></a>namespace std::ranges {</span>
<span id="cb244-2"><a href="#cb244-2"></a>  template&lt;class V, class F&gt;</span>
<span id="cb244-3"><a href="#cb244-3"></a>  template&lt;bool Const&gt;</span>
<span id="cb244-4"><a href="#cb244-4"></a>  class transform_view&lt;V, F&gt;::sentinel {</span>
<span id="cb244-5"><a href="#cb244-5"></a>    [...]</span>
<span id="cb244-6"><a href="#cb244-6"></a>    </span>
<span id="cb244-7"><a href="#cb244-7"></a>    friend constexpr bool operator==(const iterator&lt;Const&gt;&amp; x, const sentinel&amp; y);</span>
<span id="cb244-8"><a href="#cb244-8"></a><span class="st">-   friend constexpr bool operator==(const sentinel&amp; x, const iterator&lt;Const&gt;&amp; y);</span></span>
<span id="cb244-9"><a href="#cb244-9"></a><span class="st">-   friend constexpr bool operator!=(const iterator&lt;Const&gt;&amp; x, const sentinel&amp; y);</span></span>
<span id="cb244-10"><a href="#cb244-10"></a><span class="st">-   friend constexpr bool operator!=(const sentinel&amp; x, const iterator&lt;Const&gt;&amp; y);</span></span>
<span id="cb244-11"><a href="#cb244-11"></a></span>
<span id="cb244-12"><a href="#cb244-12"></a>    [...]   </span>
<span id="cb244-13"><a href="#cb244-13"></a>  };</span>
<span id="cb244-14"><a href="#cb244-14"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb245"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb245-1"><a href="#cb245-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> iterator<span class="op">&lt;</span>Const<span class="op">&gt;&amp;</span> x, <span class="kw">const</span> sentinel<span class="op">&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>current_ <span class="op">==</span> y<span class="op">.</span>end_;</code></p>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator==(const sentinel&amp; x, const iterator&lt;Const&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> y <span class="op">==</span> x;</code></p>
<pre><code>friend constexpr bool operator!=(const iterator&lt;Const&gt;&amp; x, const sentinel&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span>;</code></p>
<pre><code>friend constexpr bool operator!=(const sentinel&amp; x, const iterator&lt;Const&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>y <span class="op">==</span> x<span class="op">)</span>;</code></p>
</div>
</blockquote>
<p>Change 24.7.6.3 [range.take.sentinel]:</p>
<blockquote>
<div class="sourceCode" id="cb249"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb249-1"><a href="#cb249-1"></a>namespace std::ranges {</span>
<span id="cb249-2"><a href="#cb249-2"></a>  template&lt;class V&gt;</span>
<span id="cb249-3"><a href="#cb249-3"></a>  template&lt;bool Const&gt;</span>
<span id="cb249-4"><a href="#cb249-4"></a>  class take_view&lt;V&gt;::sentinel {</span>
<span id="cb249-5"><a href="#cb249-5"></a>    [...]</span>
<span id="cb249-6"><a href="#cb249-6"></a></span>
<span id="cb249-7"><a href="#cb249-7"></a><span class="st">-   friend constexpr bool operator==(const sentinel&amp; x, const CI&amp; y);</span></span>
<span id="cb249-8"><a href="#cb249-8"></a>    friend constexpr bool operator==(const CI&amp; y, const sentinel&amp; x);</span>
<span id="cb249-9"><a href="#cb249-9"></a><span class="st">-   friend constexpr bool operator!=(const sentinel&amp; x, const CI&amp; y);</span></span>
<span id="cb249-10"><a href="#cb249-10"></a><span class="st">-   friend constexpr bool operator!=(const CI&amp; y, const sentinel&amp; x);</span></span>
<span id="cb249-11"><a href="#cb249-11"></a>  };</span>
<span id="cb249-12"><a href="#cb249-12"></a>}</span></code></pre></div>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator==(const sentinel&amp; x, const CI&amp; y);</code></pre>

</div>
<div class="sourceCode" id="cb251"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb251-1"><a href="#cb251-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> CI<span class="op">&amp;</span> y, <span class="kw">const</span> sentinel<span class="op">&amp;</span> x<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> y<span class="op">.</span>count<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> y<span class="op">.</span>base<span class="op">()</span> <span class="op">==</span> x<span class="op">.</span>end_;</code></p>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator!=(const sentinel&amp; x, const CI&amp; y);
friend constexpr bool operator!=(const CI&amp; y, const sentinel&amp; x);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span>;</code></p>
</div>
</blockquote>
<p>Change 24.7.7.3 [range.join.iterator]:</p>
<blockquote>
<div class="sourceCode" id="cb253"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb253-1"><a href="#cb253-1"></a>namespace std::ranges {</span>
<span id="cb253-2"><a href="#cb253-2"></a>template&lt;class V&gt;</span>
<span id="cb253-3"><a href="#cb253-3"></a>  template&lt;bool Const&gt;</span>
<span id="cb253-4"><a href="#cb253-4"></a>  struct join_view&lt;V&gt;::iterator {</span>
<span id="cb253-5"><a href="#cb253-5"></a>    [...]</span>
<span id="cb253-6"><a href="#cb253-6"></a></span>
<span id="cb253-7"><a href="#cb253-7"></a>    friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)</span>
<span id="cb253-8"><a href="#cb253-8"></a>      requires ref_is_glvalue &amp;&amp; EqualityComparable&lt;iterator_t&lt;Base&gt;&gt; &amp;&amp;</span>
<span id="cb253-9"><a href="#cb253-9"></a>               EqualityComparable&lt;iterator_t&lt;iter_reference_t&lt;iterator_t&lt;Base&gt;&gt;&gt;&gt;;</span>
<span id="cb253-10"><a href="#cb253-10"></a></span>
<span id="cb253-11"><a href="#cb253-11"></a><span class="st">-   friend constexpr bool operator!=(const iterator&amp; x, const iterator&amp; y)</span></span>
<span id="cb253-12"><a href="#cb253-12"></a><span class="st">-     requires ref_is_glvalue &amp;&amp; EqualityComparable&lt;iterator_t&lt;Base&gt;&gt; &amp;&amp;</span></span>
<span id="cb253-13"><a href="#cb253-13"></a><span class="st">-              EqualityComparable&lt;iterator_t&lt;iter_reference_t&lt;iterator_t&lt;Base&gt;&gt;&gt;&gt;;</span></span>
<span id="cb253-14"><a href="#cb253-14"></a></span>
<span id="cb253-15"><a href="#cb253-15"></a>    [...]              </span>
<span id="cb253-16"><a href="#cb253-16"></a>  };</span>
<span id="cb253-17"><a href="#cb253-17"></a>}</span></code></pre></div>
<pre><code>friend constexpr bool operator==(const iterator&amp; x, const iterator&amp; y)
  requires ref_is_glvalue &amp;&amp; EqualityComparable&lt;iterator_t&lt;Base&gt;&gt; &amp;&amp;
           EqualityComparable&lt;iterator_t&lt;iter_reference_t&lt;iterator_t&lt;Base&gt;&gt;&gt;&gt;;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">16</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>outer_ <span class="op">==</span> y<span class="op">.</span>outer_ <span class="op">&amp;&amp;</span> x<span class="op">.</span>inner_ <span class="op">==</span> y<span class="op">.</span>inner_;</code></p>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator!=(const iterator&amp; x, const iterator&amp; y)
  requires ref_is_glvalue &amp;&amp; EqualityComparable&lt;iterator_t&lt;Base&gt;&gt; &amp;&amp;
           EqualityComparable&lt;iterator_t&lt;iter_reference_t&lt;iterator_t&lt;Base&gt;&gt;&gt;&gt;;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">17</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span>;</code></p>
</div>
</blockquote>
<p>Change 24.7.7.4 [range.join.sentinel]:</p>
<blockquote>
<div class="sourceCode" id="cb256"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb256-1"><a href="#cb256-1"></a>namespace std::ranges {</span>
<span id="cb256-2"><a href="#cb256-2"></a>  template&lt;class V&gt;</span>
<span id="cb256-3"><a href="#cb256-3"></a>  template&lt;bool Const&gt;</span>
<span id="cb256-4"><a href="#cb256-4"></a>  struct join_view&lt;V&gt;::sentinel {</span>
<span id="cb256-5"><a href="#cb256-5"></a>    [...]</span>
<span id="cb256-6"><a href="#cb256-6"></a></span>
<span id="cb256-7"><a href="#cb256-7"></a>    friend constexpr bool operator==(const iterator&lt;Const&gt;&amp; x, const sentinel&amp; y);</span>
<span id="cb256-8"><a href="#cb256-8"></a><span class="st">-   friend constexpr bool operator==(const sentinel&amp; x, const iterator&lt;Const&gt;&amp; y);</span></span>
<span id="cb256-9"><a href="#cb256-9"></a><span class="st">-   friend constexpr bool operator!=(const iterator&lt;Const&gt;&amp; x, const sentinel&amp; y);</span></span>
<span id="cb256-10"><a href="#cb256-10"></a><span class="st">-   friend constexpr bool operator!=(const sentinel&amp; x, const iterator&lt;Const&gt;&amp; y);</span></span>
<span id="cb256-11"><a href="#cb256-11"></a>  };</span>
<span id="cb256-12"><a href="#cb256-12"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb257"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb257-1"><a href="#cb257-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> iterator<span class="op">&lt;</span>Const<span class="op">&gt;&amp;</span> x, <span class="kw">const</span> sentinel<span class="op">&amp;</span> y<span class="op">)</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>outer_ <span class="op">==</span> y<span class="op">.</span>end_;</code></p>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator==(const sentinel&amp; x, const iterator&lt;Const&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> y <span class="op">==</span> x;</code></p>
<pre><code>friend constexpr bool operator!=(const iterator&lt;Const&gt;&amp; x, const sentinel&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span>;</code></p>
<pre><code>friend constexpr bool operator!=(const sentinel&amp; x, const iterator&lt;Const&gt;&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>y <span class="op">==</span> x<span class="op">)</span>;</code></p>
</div>
</blockquote>
<p>Change 24.7.8.3 [range.split.outer]:</p>
<blockquote>
<div class="sourceCode" id="cb261"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb261-1"><a href="#cb261-1"></a>namespace std::ranges {</span>
<span id="cb261-2"><a href="#cb261-2"></a>  template&lt;class V, class Pattern&gt;</span>
<span id="cb261-3"><a href="#cb261-3"></a>  template&lt;bool Const&gt;</span>
<span id="cb261-4"><a href="#cb261-4"></a>  struct split_view&lt;V, Pattern&gt;::outer_iterator {</span>
<span id="cb261-5"><a href="#cb261-5"></a>    [...]</span>
<span id="cb261-6"><a href="#cb261-6"></a>    </span>
<span id="cb261-7"><a href="#cb261-7"></a>    friend constexpr bool operator==(const outer_iterator&amp; x, const outer_iterator&amp; y)</span>
<span id="cb261-8"><a href="#cb261-8"></a>      requires ForwardRange&lt;Base&gt;;</span>
<span id="cb261-9"><a href="#cb261-9"></a><span class="st">-   friend constexpr bool operator!=(const outer_iterator&amp; x, const outer_iterator&amp; y)</span></span>
<span id="cb261-10"><a href="#cb261-10"></a><span class="st">-     requires ForwardRange&lt;Base&gt;;</span></span>
<span id="cb261-11"><a href="#cb261-11"></a></span>
<span id="cb261-12"><a href="#cb261-12"></a>    friend constexpr bool operator==(const outer_iterator&amp; x, default_sentinel_t);</span>
<span id="cb261-13"><a href="#cb261-13"></a><span class="st">-   friend constexpr bool operator==(default_sentinel_t, const outer_iterator&amp; x);</span></span>
<span id="cb261-14"><a href="#cb261-14"></a><span class="st">-   friend constexpr bool operator!=(const outer_iterator&amp; x, default_sentinel_t y);</span></span>
<span id="cb261-15"><a href="#cb261-15"></a><span class="st">-   friend constexpr bool operator!=(default_sentinel_t y, const outer_iterator&amp; x);</span></span>
<span id="cb261-16"><a href="#cb261-16"></a>  };</span>
<span id="cb261-17"><a href="#cb261-17"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb262"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb262-1"><a href="#cb262-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> outer_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> outer_iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb262-2"><a href="#cb262-2"></a>  <span class="kw">requires</span> ForwardRange<span class="op">&lt;</span>Base<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>current_ <span class="op">==</span> y<span class="op">.</span>current_;</code></p>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator!=(const outer_iterator&amp; x, const outer_iterator&amp; y)
  requires ForwardRange&lt;Base&gt;;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">8</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span>;</code></p>
</div>
<div class="sourceCode" id="cb264"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb264-1"><a href="#cb264-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> outer_iterator<span class="op">&amp;</span> x, default_sentinel_t<span class="op">)</span>;</span></code></pre></div>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator==(default_sentinel_t, const outer_iterator&amp; x);</code></pre>

</div>
<p><span class="marginalizedparent"><a class="marginalized">9</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>current <span class="op">==</span> ranges<span class="op">::</span>end<span class="op">(</span>x<span class="op">.</span>parent_<span class="op">-&gt;</span>base_<span class="op">)</span>;</code></p>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator!=(const outer_iterator&amp; x, default_sentinel_t y);
friend constexpr bool operator!=(default_sentinel_t y, const outer_iterator&amp; x);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">10</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span>;</code></p>
</div>
</blockquote>
<p>Change 24.7.8.5 [range.split.inner]:</p>
<blockquote>
<div class="sourceCode" id="cb267"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb267-1"><a href="#cb267-1"></a>namespace std::ranges {</span>
<span id="cb267-2"><a href="#cb267-2"></a>  template&lt;class V, class Pattern&gt;</span>
<span id="cb267-3"><a href="#cb267-3"></a>  template&lt;bool Const&gt;</span>
<span id="cb267-4"><a href="#cb267-4"></a>  struct split_view&lt;V, Pattern&gt;::inner_iterator {</span>
<span id="cb267-5"><a href="#cb267-5"></a>    [...]</span>
<span id="cb267-6"><a href="#cb267-6"></a>    </span>
<span id="cb267-7"><a href="#cb267-7"></a>    friend constexpr bool operator==(const inner_iterator&amp; x, const inner_iterator&amp; y)</span>
<span id="cb267-8"><a href="#cb267-8"></a>      requires ForwardRange&lt;Base&gt;;</span>
<span id="cb267-9"><a href="#cb267-9"></a><span class="st">-   friend constexpr bool operator!=(const inner_iterator&amp; x, const inner_iterator&amp; y)</span></span>
<span id="cb267-10"><a href="#cb267-10"></a><span class="st">-     requires ForwardRange&lt;Base&gt;;</span></span>
<span id="cb267-11"><a href="#cb267-11"></a></span>
<span id="cb267-12"><a href="#cb267-12"></a>    friend constexpr bool operator==(const inner_iterator&amp; x, default_sentinel_t);</span>
<span id="cb267-13"><a href="#cb267-13"></a><span class="st">-   friend constexpr bool operator==(default_sentinel_t, const inner_iterator&amp; x);</span></span>
<span id="cb267-14"><a href="#cb267-14"></a><span class="st">-   friend constexpr bool operator!=(const inner_iterator&amp; x, default_sentinel_t y);</span></span>
<span id="cb267-15"><a href="#cb267-15"></a><span class="st">-   friend constexpr bool operator!=(default_sentinel_t y, const inner_iterator&amp; x);</span></span>
<span id="cb267-16"><a href="#cb267-16"></a></span>
<span id="cb267-17"><a href="#cb267-17"></a>    [...]</span>
<span id="cb267-18"><a href="#cb267-18"></a>  };</span>
<span id="cb267-19"><a href="#cb267-19"></a>}  </span></code></pre></div>
<div class="sourceCode" id="cb268"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb268-1"><a href="#cb268-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> inner_iterator<span class="op">&amp;</span> x, <span class="kw">const</span> inner_iterator<span class="op">&amp;</span> y<span class="op">)</span></span>
<span id="cb268-2"><a href="#cb268-2"></a>  <span class="kw">requires</span> ForwardRange<span class="op">&lt;</span>Base<span class="op">&gt;</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> x<span class="op">.</span>i_<span class="op">.</span>current_ <span class="op">==</span> y<span class="op">.</span>i_<span class="op">.</span>current_;</code></p>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator!=(const inner_iterator&amp; x, const inner_iterator&amp; y)
  requires ForwardRange&lt;Base&gt;;</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span>;</code></p>
</div>
<div class="sourceCode" id="cb270"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb270-1"><a href="#cb270-1"></a><span class="kw">friend</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> inner_iterator<span class="op">&amp;</span> x, default_sentinel_t<span class="op">)</span>;</span></code></pre></div>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator==(default_sentinel_t, const inner_iterator&amp; x);</code></pre>

</div>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Effects</em>: Equivalent to:</p>
<blockquote>
<div class="sourceCode" id="cb272"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb272-1"><a href="#cb272-1"></a><span class="kw">auto</span> cur <span class="op">=</span> x<span class="op">.</span>i_<span class="op">.</span>current;</span>
<span id="cb272-2"><a href="#cb272-2"></a><span class="kw">auto</span> end <span class="op">=</span> ranges<span class="op">::</span>end<span class="op">(</span>x<span class="op">.</span>i_<span class="op">.</span>parent_<span class="op">-&gt;</span>base_<span class="op">)</span>;</span>
<span id="cb272-3"><a href="#cb272-3"></a><span class="cf">if</span> <span class="op">(</span>cur <span class="op">==</span> end<span class="op">)</span> <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="cb272-4"><a href="#cb272-4"></a><span class="kw">auto</span> <span class="op">[</span>pcur, pend<span class="op">]</span> <span class="op">=</span> subrange<span class="op">{</span>x<span class="op">.</span>i_<span class="op">.</span>parent_<span class="op">-&gt;</span>pattern_<span class="op">}</span>;</span>
<span id="cb272-5"><a href="#cb272-5"></a><span class="cf">if</span> <span class="op">(</span>pcur <span class="op">==</span> pend<span class="op">)</span> <span class="cf">return</span> x<span class="op">.</span>incremented_;</span>
<span id="cb272-6"><a href="#cb272-6"></a><span class="cf">do</span> <span class="op">{</span></span>
<span id="cb272-7"><a href="#cb272-7"></a>  <span class="cf">if</span> <span class="op">(*</span>cur <span class="op">!=</span> <span class="op">*</span>pcur<span class="op">)</span> <span class="cf">return</span> <span class="kw">false</span>;</span>
<span id="cb272-8"><a href="#cb272-8"></a>  <span class="cf">if</span> <span class="op">(++</span>pcur <span class="op">==</span> pend<span class="op">)</span> <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="cb272-9"><a href="#cb272-9"></a><span class="op">}</span> <span class="cf">while</span> <span class="op">(++</span>cur <span class="op">!=</span> end<span class="op">)</span>;</span>
<span id="cb272-10"><a href="#cb272-10"></a><span class="cf">return</span> <span class="kw">false</span>;</span></code></pre></div>
</blockquote>
<div class="rm" style="color: #bf0303">

<pre><code>friend constexpr bool operator!=(const inner_iterator&amp; x, default_sentinel_t y);
friend constexpr bool operator!=(default_sentinel_t y, const inner_iterator&amp; x);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Effects</em>: Equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> <span class="op">!(</span>x <span class="op">==</span> y<span class="op">)</span>;</code></p>
</div>
</blockquote>
<h2 id="clause-25-algorithms-library"><span class="header-section-number">5.10</span> Clause 25: Algorithms library<a href="#clause-25-algorithms-library" class="self-link"></a></h2>
<p>Remove <code class="sourceCode cpp">compare_3way</code> and rename <code class="sourceCode cpp">lexicographical_compare_3way</code>.</p>
<p>Change 25.4 [algorithm.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb274"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb274-1"><a href="#cb274-1"></a>namespace std {</span>
<span id="cb274-2"><a href="#cb274-2"></a>   [...]</span>
<span id="cb274-3"><a href="#cb274-3"></a></span>
<span id="cb274-4"><a href="#cb274-4"></a>  // [alg.3way], three-way comparison algorithms</span>
<span id="cb274-5"><a href="#cb274-5"></a><span class="st">- template&lt;class T, class U&gt;</span></span>
<span id="cb274-6"><a href="#cb274-6"></a><span class="st">-   constexpr auto compare_3way(const T&amp; a, const U&amp; b);</span></span>
<span id="cb274-7"><a href="#cb274-7"></a>  template&lt;class InputIterator1, class InputIterator2, class Cmp&gt;</span>
<span id="cb274-8"><a href="#cb274-8"></a>    constexpr auto</span>
<span id="cb274-9"><a href="#cb274-9"></a><span class="st">-     lexicographical_compare_3way(InputIterator1 b1, InputIterator1 e1,</span></span>
<span id="cb274-10"><a href="#cb274-10"></a><span class="va">+     @[lexicographical_compare_three_way]{.diffins}@(InputIterator1 b1, InputIterator1 e1,</span></span>
<span id="cb274-11"><a href="#cb274-11"></a>                                   InputIterator2 b2, InputIterator2 e2,</span>
<span id="cb274-12"><a href="#cb274-12"></a>                                   Cmp comp)</span>
<span id="cb274-13"><a href="#cb274-13"></a>        -&gt; common_comparison_category_t&lt;decltype(comp(*b1, *b2)), strong_ordering&gt;;</span>
<span id="cb274-14"><a href="#cb274-14"></a>  template&lt;class InputIterator1, class InputIterator2&gt;</span>
<span id="cb274-15"><a href="#cb274-15"></a>    constexpr auto</span>
<span id="cb274-16"><a href="#cb274-16"></a><span class="st">-     lexicographical_compare_3way(InputIterator1 b1, InputIterator1 e1,</span></span>
<span id="cb274-17"><a href="#cb274-17"></a><span class="va">+     @[lexicographical_compare_three_way]{.diffins}@(InputIterator1 b1, InputIterator1 e1,</span></span>
<span id="cb274-18"><a href="#cb274-18"></a>                                   InputIterator2 b2, InputIterator2 e2);</span>
<span id="cb274-19"><a href="#cb274-19"></a>   </span>
<span id="cb274-20"><a href="#cb274-20"></a>   [...]</span>
<span id="cb274-21"><a href="#cb274-21"></a>}</span></code></pre></div>
</blockquote>
<p>Change 25.7.11 [alg.3way]:</p>
<blockquote>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class T, class U&gt; constexpr auto compare_3way(const T&amp; a, const U&amp; b);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Effects</em>: Compares two values and produces a result of the strongest applicable comparison category type:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(1.1)</a></span> Returns <code class="sourceCode cpp">a <span class="op">&lt;=&gt;</span> b</code> if that expression is well-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.2)</a></span> Otherwise, if the expressions <code class="sourceCode cpp">a <span class="op">==</span> b</code> and <code class="sourceCode cpp">a <span class="op">&lt;</span> b</code> are each well-formed and convertible to <code class="sourceCode cpp"><span class="dt">bool</span></code>, returns <code class="sourceCode cpp">strong_ordering<span class="op">::</span>equal</code> when <code class="sourceCode cpp">a <span class="op">==</span> b</code> is <code class="sourceCode cpp"><span class="kw">true</span></code>, otherwise returns <code class="sourceCode cpp">strong_ordering<span class="op">::</span>less</code> when <code class="sourceCode cpp">a <span class="op">&lt;</span> b</code> is <code class="sourceCode cpp"><span class="kw">true</span></code>, and otherwise returns <code class="sourceCode cpp">strong_ordering<span class="op">::</span>greater</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.3)</a></span> Otherwise, if the expression <code class="sourceCode cpp">a <span class="op">==</span> b</code> is well-formed and convertible to <code class="sourceCode cpp"><span class="dt">bool</span></code>, returns <code class="sourceCode cpp">strong_equality<span class="op">::</span>equal</code> when <code class="sourceCode cpp">a <span class="op">==</span> b</code> is <code class="sourceCode cpp"><span class="kw">true</span></code>, and otherwise returns <code class="sourceCode cpp">strong_equality<span class="op">::</span>nonequal</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.4)</a></span> Otherwise, the function is defined as deleted.</li>
</ul>

</div>
<div class="sourceCode" id="cb276"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb276-1"><a href="#cb276-1"></a>  template&lt;class InputIterator1, class InputIterator2, class Cmp&gt;</span>
<span id="cb276-2"><a href="#cb276-2"></a>    constexpr auto</span>
<span id="cb276-3"><a href="#cb276-3"></a><span class="st">-     lexicographical_compare_3way(InputIterator1 b1, InputIterator1 e1,</span></span>
<span id="cb276-4"><a href="#cb276-4"></a><span class="va">+     @[lexicographical_compare_three_way]{.diffins}@(InputIterator1 b1, InputIterator1 e1,</span></span>
<span id="cb276-5"><a href="#cb276-5"></a>                                   InputIterator2 b2, InputIterator2 e2,</span>
<span id="cb276-6"><a href="#cb276-6"></a>                                   Cmp comp)</span>
<span id="cb276-7"><a href="#cb276-7"></a>        -&gt; common_comparison_category_t&lt;decltype(comp(*b1, *b2)), strong_ordering&gt;;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Requires</em>: <code class="sourceCode cpp">Cmp</code> shall be a function object type whose return type is a comparison category type. <span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Effects</em>: Lexicographically compares two ranges and produces a result of the strongest applicable comparison category type. Equivalent to:</p>
<blockquote>
<div class="sourceCode" id="cb277"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb277-1"><a href="#cb277-1"></a><span class="cf">for</span> <span class="op">(</span> ; b1 <span class="op">!=</span> e1 <span class="op">&amp;&amp;</span> b2 <span class="op">!=</span> e2; <span class="dt">void</span><span class="op">(++</span>b1<span class="op">)</span>, <span class="dt">void</span><span class="op">(++</span>b2<span class="op">)</span> <span class="op">)</span></span>
<span id="cb277-2"><a href="#cb277-2"></a>  <span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> cmp <span class="op">=</span> comp<span class="op">(*</span>b1,<span class="op">*</span>b2<span class="op">)</span>; cmp <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb277-3"><a href="#cb277-3"></a>    <span class="cf">return</span> cmp;</span>
<span id="cb277-4"><a href="#cb277-4"></a><span class="cf">return</span> b1 <span class="op">!=</span> e1 <span class="op">?</span> strong_ordering<span class="op">::</span>greater <span class="op">:</span></span>
<span id="cb277-5"><a href="#cb277-5"></a>       b2 <span class="op">!=</span> e2 <span class="op">?</span> strong_ordering<span class="op">::</span>less <span class="op">:</span></span>
<span id="cb277-6"><a href="#cb277-6"></a>                  strong_ordering<span class="op">::</span>equal;</span></code></pre></div>
</blockquote>
<div class="sourceCode" id="cb278"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb278-1"><a href="#cb278-1"></a>  template&lt;class InputIterator1, class InputIterator2&gt;</span>
<span id="cb278-2"><a href="#cb278-2"></a>    constexpr auto</span>
<span id="cb278-3"><a href="#cb278-3"></a><span class="st">-     lexicographical_compare_3way(InputIterator1 b1, InputIterator1 e1,</span></span>
<span id="cb278-4"><a href="#cb278-4"></a><span class="va">+     @[lexicographical_compare_three_way]{.diffins}@(InputIterator1 b1, InputIterator1 e1,</span></span>
<span id="cb278-5"><a href="#cb278-5"></a>                                   InputIterator2 b2, InputIterator2 e2);</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Effects</em>: Equivalent to:</p>
<blockquote>
<div class="sourceCode" id="cb279"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb279-1"><a href="#cb279-1"></a>  return lexicographical_compare_3way(b1, e1, b2, e2,</span>
<span id="cb279-2"><a href="#cb279-2"></a><span class="st">-                                     [](const auto&amp; t, const auto&amp; u) {</span></span>
<span id="cb279-3"><a href="#cb279-3"></a><span class="st">-                                       return compare_3way(t, u);</span></span>
<span id="cb279-4"><a href="#cb279-4"></a><span class="st">-                                     });</span></span>
<span id="cb279-5"><a href="#cb279-5"></a><span class="va">+                                     compare_three_way());</span></span></code></pre></div>
</blockquote>
</blockquote>
<h2 id="clause-26-numerics-library"><span class="header-section-number">5.11</span> Clause 26: Numerics library<a href="#clause-26-numerics-library" class="self-link"></a></h2>
<p>Remove obsolete <code class="sourceCode cpp"><span class="op">==</span></code> and <code class="sourceCode cpp"><span class="op">!=</span></code> operators from <code class="sourceCode cpp">complex</code>, add a new <code class="sourceCode cpp"><span class="op">==</span></code> to <code class="sourceCode cpp">slice</code>.</p>
<p>Change 26.4.1 [complex.syn]:</p>
<blockquote>
<div class="sourceCode" id="cb280"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb280-1"><a href="#cb280-1"></a>namespace std {</span>
<span id="cb280-2"><a href="#cb280-2"></a>  // [complex], class template complex</span>
<span id="cb280-3"><a href="#cb280-3"></a>  template&lt;class T&gt; class complex;</span>
<span id="cb280-4"><a href="#cb280-4"></a></span>
<span id="cb280-5"><a href="#cb280-5"></a>  // [complex.special], specializations</span>
<span id="cb280-6"><a href="#cb280-6"></a>  template&lt;&gt; class complex&lt;float&gt;;</span>
<span id="cb280-7"><a href="#cb280-7"></a>  template&lt;&gt; class complex&lt;double&gt;;</span>
<span id="cb280-8"><a href="#cb280-8"></a>  template&lt;&gt; class complex&lt;long double&gt;;</span>
<span id="cb280-9"><a href="#cb280-9"></a>  </span>
<span id="cb280-10"><a href="#cb280-10"></a>  [...]</span>
<span id="cb280-11"><a href="#cb280-11"></a>  </span>
<span id="cb280-12"><a href="#cb280-12"></a>  template&lt;class T&gt; constexpr bool operator==(const complex&lt;T&gt;&amp;, const complex&lt;T&gt;&amp;);</span>
<span id="cb280-13"><a href="#cb280-13"></a>  template&lt;class T&gt; constexpr bool operator==(const complex&lt;T&gt;&amp;, const T&amp;);</span>
<span id="cb280-14"><a href="#cb280-14"></a><span class="st">- template&lt;class T&gt; constexpr bool operator==(const T&amp;, const complex&lt;T&gt;&amp;);</span></span>
<span id="cb280-15"><a href="#cb280-15"></a></span>
<span id="cb280-16"><a href="#cb280-16"></a><span class="st">- template&lt;class T&gt; constexpr bool operator!=(const complex&lt;T&gt;&amp;, const complex&lt;T&gt;&amp;);</span></span>
<span id="cb280-17"><a href="#cb280-17"></a><span class="st">- template&lt;class T&gt; constexpr bool operator!=(const complex&lt;T&gt;&amp;, const T&amp;);</span></span>
<span id="cb280-18"><a href="#cb280-18"></a><span class="st">- template&lt;class T&gt; constexpr bool operator!=(const T&amp;, const complex&lt;T&gt;&amp;);</span></span>
<span id="cb280-19"><a href="#cb280-19"></a></span>
<span id="cb280-20"><a href="#cb280-20"></a>  [...]</span>
<span id="cb280-21"><a href="#cb280-21"></a>}  </span></code></pre></div>
</blockquote>
<p>Change 26.4.6 [complex.ops]:</p>
<blockquote>
<div class="sourceCode" id="cb281"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb281-1"><a href="#cb281-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> complex<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> lhs, <span class="kw">const</span> complex<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> rhs<span class="op">)</span>;</span>
<span id="cb281-2"><a href="#cb281-2"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span> <span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> complex<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span> lhs, <span class="kw">const</span> T<span class="op">&amp;</span> rhs<span class="op">)</span>;</span></code></pre></div>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class T&gt; constexpr bool operator==(const T&amp; lhs, const complex&lt;T&gt;&amp; rhs);</code></pre>

</div>
<p><span class="marginalizedparent"><a class="marginalized">9</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>real<span class="op">()</span> <span class="op">==</span> rhs<span class="op">.</span>real<span class="op">()</span> <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>imag<span class="op">()</span> <span class="op">==</span> rhs<span class="op">.</span>imag<span class="op">()</span></code>.</p>
<p><span class="marginalizedparent"><a class="marginalized">10</a></span> <em>Remarks</em>: The imaginary part is assumed to be <code class="sourceCode cpp">T<span class="op">()</span></code>, or <code class="sourceCode cpp"><span class="fl">0.0</span></code>, for the <code class="sourceCode cpp">T</code> arguments.</p>
<div class="rm" style="color: #bf0303">

<pre><code>template&lt;class T&gt; constexpr bool operator!=(const complex&lt;T&gt;&amp; lhs, const complex&lt;T&gt;&amp; rhs);
template&lt;class T&gt; constexpr bool operator!=(const complex&lt;T&gt;&amp; lhs, const T&amp; rhs);
template&lt;class T&gt; constexpr bool operator!=(const T&amp; lhs, const complex&lt;T&gt;&amp; rhs);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">11</a></span> <code class="sourceCode cpp">Returns</code>: <code class="sourceCode cpp">rhs<span class="op">.</span>real<span class="op">()</span> <span class="op">!=</span> lhs<span class="op">.</span>real<span class="op">()</span> <span class="op">||</span> rhs<span class="op">.</span>imag<span class="op">()</span> <span class="op">!=</span> lhs<span class="op">.</span>imag<span class="op">()</span></code>.</p>
</div>
</blockquote>
<p>Change 26.7.4.1 [class.slice.overview]:</p>
<blockquote>
<div class="sourceCode" id="cb284"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb284-1"><a href="#cb284-1"></a>namespace std {</span>
<span id="cb284-2"><a href="#cb284-2"></a>  class slice {</span>
<span id="cb284-3"><a href="#cb284-3"></a>  public:</span>
<span id="cb284-4"><a href="#cb284-4"></a>    slice();</span>
<span id="cb284-5"><a href="#cb284-5"></a>    slice(size_t, size_t, size_t);</span>
<span id="cb284-6"><a href="#cb284-6"></a></span>
<span id="cb284-7"><a href="#cb284-7"></a>    size_t start() const;</span>
<span id="cb284-8"><a href="#cb284-8"></a>    size_t size() const;</span>
<span id="cb284-9"><a href="#cb284-9"></a>    size_t stride() const;</span>
<span id="cb284-10"><a href="#cb284-10"></a>    </span>
<span id="cb284-11"><a href="#cb284-11"></a><span class="va">+   friend bool operator==(const slice&amp; x, const slice&amp; y);</span></span>
<span id="cb284-12"><a href="#cb284-12"></a>  };</span>
<span id="cb284-13"><a href="#cb284-13"></a>}</span></code></pre></div>
</blockquote>
<p>Add a new subclause 26.7.4.4 “Operators” [slice.ops]:</p>
<blockquote>
<div class="addu">
<pre><code>friend bool operator==(const slice&amp; x, const slice&amp; y);</code></pre>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Effects</em>: Equivalent to:</p>
<blockquote>
<pre><code>return x.start() == y.start() &amp;&amp;
  x.size() == y.size() &amp;&amp;
  x.stride() == y.stride();</code></pre>
</blockquote>
</div>
</blockquote>
<h2 id="clause-27-time-library"><span class="header-section-number">5.12</span> Clause 27: Time library<a href="#clause-27-time-library" class="self-link"></a></h2>
<p>TBD</p>
<h2 id="clause-28-localization-library"><span class="header-section-number">5.13</span> Clause 28: Localization library<a href="#clause-28-localization-library" class="self-link"></a></h2>
<p>TBD</p>
<h2 id="clause-29-inputoutput-library"><span class="header-section-number">5.14</span> Clause 29: Input/output library<a href="#clause-29-inputoutput-library" class="self-link"></a></h2>
<p>TBD</p>
<h2 id="clause-30-regular-expressions-library"><span class="header-section-number">5.15</span> Clause 30: Regular expressions library<a href="#clause-30-regular-expressions-library" class="self-link"></a></h2>
<p>TBD</p>
<h2 id="clause-31-atomic-operations-library"><span class="header-section-number">5.16</span> Clause 31: Atomic operations library<a href="#clause-31-atomic-operations-library" class="self-link"></a></h2>
<p>TBD</p>
<h2 id="clause-32-thread-support-library"><span class="header-section-number">5.17</span> Clause 32: Thread support library<a href="#clause-32-thread-support-library" class="self-link"></a></h2>
<p>TBD</p>
<h1 id="references" style="border-bottom:1px solid #cccccc"><span class="header-section-number">6</span> References<a href="#references" class="self-link"></a></h1>

<div id="refs" role="doc-bibliography">
<div id="ref-D1186R2">
<p>[D1186R2] Barry Revzin. 2019. When do you actually use <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code>? <br />
<a href="https://brevzin.github.io/cpp_proposals/118x_spaceship/d1186r2.html">https://brevzin.github.io/cpp_proposals/118x_spaceship/d1186r2.html</a></p>
</div>
<div id="ref-P0732R2">
<p>[P0732R2] Jeff Snyder, Louis Dionne. 2018. Class Types in Non-Type Template Parameters. <br />
<a href="https://wg21.link/p0732r2">https://wg21.link/p0732r2</a></p>
</div>
<div id="ref-P0790R2">
<p>[P0790R2] David Stone. 2019. Effect of operator&lt;=&gt; on the C++ Standard Library. <br />
<a href="https://wg21.link/p0790r2">https://wg21.link/p0790r2</a></p>
</div>
<div id="ref-P0891R2">
<p>[P0891R2] Gašper Ažman, Jeff Snyder. 2019. Make <code class="sourceCode cpp">strong_order</code> a Customization Point! <br />
<a href="https://wg21.link/p0891r2">https://wg21.link/p0891r2</a></p>
</div>
<div id="ref-P1154R1">
<p>[P1154R1] Arthur O’Dwyer, Jeff Snyder. 2019. Type traits for structural comparison. <br />
<a href="https://wg21.link/p1154r1">https://wg21.link/p1154r1</a></p>
</div>
<div id="ref-P1185R2">
<p>[P1185R2] Barry Revzin. 2019. <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span> <span class="op">!=</span> <span class="op">==</span></code>. <br />
<a href="https://wg21.link/p1185r2">https://wg21.link/p1185r2</a></p>
</div>
<div id="ref-P1186R1">
<p>[P1186R1] Barry Revzin. 2019. When do you actually use <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code>? <br />
<a href="https://wg21.link/p1186r1">https://wg21.link/p1186r1</a></p>
</div>
<div id="ref-P1188R0">
<p>[P1188R0] Barry Revzin. 2019. Library utilities for <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code>. <br />
<a href="https://wg21.link/p1188r0">https://wg21.link/p1188r0</a></p>
</div>
<div id="ref-P1189R0">
<p>[P1189R0] Barry Revzin. 2019. Adding <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> to library. <br />
<a href="https://wg21.link/p1189r0">https://wg21.link/p1189r0</a></p>
</div>
<div id="ref-P1191R0">
<p>[P1191R0] David Stone. 2018. Adding <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code> to types that are not currently comparable. <br />
<a href="https://wg21.link/p1191r0">https://wg21.link/p1191r0</a></p>
</div>
<div id="ref-P1201R0">
<p>[P1201R0] Oleg Fatkhiev, Antony Polukhin. 2018. Variant direct comparisons. <br />
<a href="https://wg21.link/p1201r0">https://wg21.link/p1201r0</a></p>
</div>
<div id="ref-P1295R0">
<p>[P1295R0] Tomasz Kamiński. 2018. Spaceship library update. <br />
<a href="https://wg21.link/p1295r0">https://wg21.link/p1295r0</a></p>
</div>
<div id="ref-P1380R1">
<p>[P1380R1] Lawrence Crowl. 2019. Ambiguity and Insecurities with Three-Way Comparison. <br />
<a href="https://wg21.link/p1380r1">https://wg21.link/p1380r1</a></p>
</div>
<div id="ref-P1614R0">
<p>[P1614R0] Barry Revzin. 2019. The Mothership Has Landed: Adding <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> to the Library. <br />
<a href="https://wg21.link/p1614r0">https://wg21.link/p1614r0</a></p>
</div>
</div>
</div>
</div>
</body>
</html>
