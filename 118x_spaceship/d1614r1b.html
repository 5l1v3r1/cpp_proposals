<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2019-06-13" />
  <title>The Mothership has Landed</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  background-color: #f6f8fa; }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span. { } /* Normal */
code span.al { color: #ff0000; } /* Alert */
code span.an { } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #9f6807; } /* BaseN */
code span.bu { color: #9f6807; } /* BuiltIn */
code span.cf { color: #00607c; } /* ControlFlow */
code span.ch { color: #9f6807; } /* Char */
code span.cn { } /* Constant */
code span.co { color: #008000; font-style: italic; } /* Comment */
code span.cv { color: #008000; font-style: italic; } /* CommentVar */
code span.do { color: #008000; } /* Documentation */
code span.dt { color: #00607c; } /* DataType */
code span.dv { color: #9f6807; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #9f6807; } /* Float */
code span.fu { } /* Function */
code span.im { } /* Import */
code span.in { color: #008000; } /* Information */
code span.kw { color: #00607c; } /* Keyword */
code span.op { color: #af1915; } /* Operator */
code span.ot { } /* Other */
code span.pp { color: #6f4e37; } /* Preprocessor */
code span.re { } /* RegionMarker */
code span.sc { color: #9f6807; } /* SpecialChar */
code span.ss { color: #9f6807; } /* SpecialString */
code span.st { color: #9f6807; } /* String */
code span.va { } /* Variable */
code span.vs { color: #9f6807; } /* VerbatimString */
code span.wa { color: #008000; font-weight: bold; } /* Warning */
code.diff {color: #898887}
code.diff span.va {color: #006e28}
code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li > span.marginalizedparent { left: -7em; }
li > ul > li > span.marginalizedparent { left: -9em; }
li > ul > li > ul > li > span.marginalizedparent { left: -11em; }
li > ul > li > ul > li > ul > li > span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }
div#refs p { padding-left: 32px; text-indent: -32px; }
</style>
  <style type="text/css">a {
color : #4183C4;
text-decoration: underline;
}
a.marginalized {
text-decoration: none;
}
a.self-link {
text-decoration: none;
}
h1#toctitle {
border-bottom: 1px solid #cccccc;
}
#TOC li {
margin-top: 1px;
margin-bottom: 1px;
}
#TOC ul>li:before { display: none; }
h3.subtitle { margin-top: -15px; }
h1:target { background-color: transparent; }
h2:target { background-color: transparent; }
h3:target { background-color: transparent; }
h4:target { background-color: transparent; }
h5:target { background-color: transparent; }
h6:target { background-color: transparent; }
code span.co { font-family: monospace; }
table tr {
background-color: white;
}
table tr:nth-child(2n) {
background-color: #f6f8fa;
}
#title-block-header > table tr:nth-child(2n) {
background-color: white;
}
td > div.sourceCode {
background-color: inherit;
}
table {
border-collapse: collapse;
}
table td, table th {
border: 1px solid #cccccc;
}
table th {
border-bottom: 1px solid black;
}
table tr:first-child th {
border-top: 0;
}
table tr:last-child td {
border-bottom: 0;
}
table tr td:first-child,
table tr th:first-child {
border-left: 0;
}
table tr td:last-child,
table tr th:last-child {
border-right: 0;
}
table tbody tr:first-child td {
border-top: 1px solid black;
}
#title-block-header td { border: 0; }
@media all {
body {
margin: 2em;
}
}
@media screen and (min-width: 480px) {
body {
margin: 5em;
}
}
#refs code{padding-left: 0px; text-indent: 0px;}
div.rm { text-decoration: line-through; }
div.rm code.sourceCode { text-decoration: line-through; }
div.addu { color: #006e28; }
div.addu p { text-decoration: underline; }
div.addu > pre { text-decoration: underline; }
div.addu code.sourceCode { text-decoration: underline; }
div.addu pre, div.rm pre, div.add pre { background-color: #f6f8fa; }
div.addu > blockquote {
border-left: 4px solid #00a000;
padding: 0 15px;
color: #006e28;
text-decoration: none;
}
div.addu blockquote code.sourceCode { text-decoration: none; }
div.addu blockquote pre { text-decoration: none; }
div.addu blockquote pre code { text-decoration: none; }
</style>
  <link href="data:image/vnd.microsoft.icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">The Mothership has Landed</h1>
<h3 class="subtitle" style="text-align:center">Adding <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> to the Library</h3>

<table style="border:none;float:right">
  <tr>
    <td>Document #: </td>
    <td>D1614R1</td>
  </tr>
  <tr>
    <td>Date: </td>
    <td>2019-06-13</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project: </td>
    <td>Programming Language C++<br>
      LWG<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to: </td>
    <td>
      Barry Revzin<br>&lt;<a href="mailto:barry.revzin@gmail.com" class="email">barry.revzin@gmail.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#revision-history"><span class="toc-section-number">1</span> Revision History<span></span></a></li>
<li><a href="#introduction"><span class="toc-section-number">2</span> Introduction<span></span></a></li>
<li><a href="#friendship"><span class="toc-section-number">3</span> Friendship<span></span></a><ul>
<li><a href="#was-well-formed-now-ill-formed"><span class="toc-section-number">3.1</span> Was well-formed, now ill-formed<span></span></a></li>
<li><a href="#was-ill-formed-now-well-formed"><span class="toc-section-number">3.2</span> Was ill-formed, now well-formed<span></span></a></li>
<li><a href="#alternatives"><span class="toc-section-number">3.3</span> Alternatives<span></span></a></li>
<li><a href="#proposed-direction"><span class="toc-section-number">3.4</span> Proposed Direction<span></span></a></li>
</ul></li>
<li><a href="#acknowledgements"><span class="toc-section-number">4</span> Acknowledgements<span></span></a></li>
<li><a href="#wording"><span class="toc-section-number">5</span> Wording<span></span></a><ul>
<li><a href="#clause-16-library-introduction"><span class="toc-section-number">5.1</span> Clause 16: Library Introduction<span></span></a></li>
<li><a href="#clause-17-language-support-library"><span class="toc-section-number">5.2</span> Clause 17: Language support library<span></span></a></li>
<li><a href="#clause-18-concepts-library"><span class="toc-section-number">5.3</span> Clause 18: Concepts Library<span></span></a></li>
<li><a href="#clause-19-diagnostics-library"><span class="toc-section-number">5.4</span> Clause 19: Diagnostics Library<span></span></a></li>
<li><a href="#clause-20-general-utilities-library"><span class="toc-section-number">5.5</span> Clause 20: General utilities library<span></span></a></li>
</ul></li>
<li><a href="#references"><span class="toc-section-number">6</span> References<span></span></a></li>
</ul>
</div>
<h1 id="revision-history" style="border-bottom:1px solid #cccccc"><span class="header-section-number">1</span> Revision History<a href="#revision-history" class="self-link"></a></h1>
<p><span class="citation" data-cites="P1614R0">[<a href="#ref-P1614R0" role="doc-biblioref">P1614R0</a>]</span> took the route of adding the new comparison operators as hidden friends. This paper instead preserves the current method of declaring comparisons - typically as non-member functions. See <a href="#friendship">friendship</a> for a more thorough discussion.</p>
<p>Additionally, R0 used the <code class="sourceCode default">3WAY</code><code class="sourceCode cpp"><span class="op">&lt;</span>R<span class="op">&gt;</span></code> wording from <span class="citation" data-cites="P1186R1">[<a href="#ref-P1186R1" role="doc-biblioref">P1186R1</a>]</span>, which was removed in the subsequent <span class="citation" data-cites="D1186R2">[<a href="#ref-D1186R2" role="doc-biblioref">D1186R2</a>]</span> - so the relevant wording for the fallback objects was changed as well.</p>
<h1 id="introduction" style="border-bottom:1px solid #cccccc"><span class="header-section-number">2</span> Introduction<a href="#introduction" class="self-link"></a></h1>
<p>The work of integrating <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code> into the library has been performed by multiple different papers, each addressing a different aspect of the integration. In the interest of streamlining review by the Library Working Group, the wording has been combined into a single paper. This is that paper.</p>
<p>In San Diego and Kona, several papers were approved by LEWG adding functionality to the library related to comparisons. What follows is the list of those papers, in alphabetical order, with a brief description of what those papers are. The complete motivation and design rationale for each can be found within the papers themselves.</p>
<ul>
<li><span class="citation" data-cites="P0790R2">[<a href="#ref-P0790R2" role="doc-biblioref">P0790R2</a>]</span> - adding <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code> to the standard library types whose behavior is not dependent on a template parameter.</li>
<li><span class="citation" data-cites="P0891R2">[<a href="#ref-P0891R2" role="doc-biblioref">P0891R2</a>]</span> - making the <code class="sourceCode cpp">XXX_order</code> algorithms customization points and introducing <code class="sourceCode cpp">compare_XXX_order_fallback</code> algorithms that preferentially invoke the former algorithm and fallback to synthesizing an ordering from <code class="sourceCode cpp"><span class="op">==</span></code> and <code class="sourceCode cpp"><span class="op">&lt;</span></code> (using the rules from <span class="citation" data-cites="P1186R1">[<a href="#ref-P1186R1" role="doc-biblioref">P1186R1</a>]</span>).</li>
<li><span class="citation" data-cites="P1154R1">[<a href="#ref-P1154R1" role="doc-biblioref">P1154R1</a>]</span> - adding the type trait <code class="sourceCode cpp">has_strong_structural_equality<span class="op">&lt;</span>T<span class="op">&gt;</span></code> (useful to check if a type can be used as a non-type template parameter).</li>
<li><span class="citation" data-cites="P1188R0">[<a href="#ref-P1188R0" role="doc-biblioref">P1188R0</a>]</span> - adding the type trait <code class="sourceCode cpp">compare_three_way_result<span class="op">&lt;</span>T<span class="op">&gt;</span></code>, the concepts <code class="sourceCode cpp">ThreeWayComparable<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp">ThreeWayComparableWith<span class="op">&lt;</span>T,U<span class="op">&gt;</span></code>, removing the algorithm <code class="sourceCode cpp">compare_3way</code> and replacing it with a function comparison object <code class="sourceCode cpp">compare_three_way</code> (i.e. the <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> version of <code class="sourceCode cpp">std<span class="op">::</span>ranges<span class="op">::</span>less</code>).</li>
<li><span class="citation" data-cites="P1189R0">[<a href="#ref-P1189R0" role="doc-biblioref">P1189R0</a>]</span> - adding <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code> to the standard library types whose behavior is dependent on a template parameter, removing those equality operators made redundant by <span class="citation" data-cites="P1185R2">[<a href="#ref-P1185R2" role="doc-biblioref">P1185R2</a>]</span> and defaulting <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> where appropriate.</li>
<li><span class="citation" data-cites="P1191R0">[<a href="#ref-P1191R0" role="doc-biblioref">P1191R0</a>]</span> - adding equality to several previously incomparable standard library types.</li>
<li><span class="citation" data-cites="P1295R0">[<a href="#ref-P1295R0" role="doc-biblioref">P1295R0</a>]</span> - adding equality and <code class="sourceCode cpp">common_type</code> for the comparison categories.</li>
<li><span class="citation" data-cites="P1380R1">[<a href="#ref-P1380R1" role="doc-biblioref">P1380R1</a>]</span> - extending the floating point customization points for <code class="sourceCode cpp">strong_order</code> and <code class="sourceCode cpp">weak_order</code>.</li>
</ul>
<h1 id="friendship" style="border-bottom:1px solid #cccccc"><span class="header-section-number">3</span> Friendship<a href="#friendship" class="self-link"></a></h1>
<p>LEWG’s unanimous preference was that the new <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code>s be declared as hidden friends. It would follow therefore that we would move the <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code>s to be declared the same way as well, since it would be pretty odd if the two different comparison operators had different semantics.</p>
<p>However, a few issues have come up with this approach that are worth presenting clearly here.</p>
<h2 id="was-well-formed-now-ill-formed"><span class="header-section-number">3.1</span> Was well-formed, now ill-formed<a href="#was-well-formed-now-ill-formed" class="self-link"></a></h2>
<p>Here is an example that came up while I attempted to implement these changes to measure any improvements in build time that might come up. This is a reproduction from the LLVM codebase:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">struct</span> StringRef <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>    StringRef<span class="op">(</span>std<span class="op">::</span>string <span class="kw">const</span><span class="op">&amp;)</span>; <span class="co">// NB: non-explicit</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="kw">operator</span> std<span class="op">::</span>string<span class="op">()</span> <span class="kw">const</span>;  <span class="co">// NB: non-explicit</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="op">}</span>;</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>StringRef, StringRef<span class="op">)</span>;</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="dt">bool</span> f<span class="op">(</span>StringRef a, std<span class="op">::</span>string b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>    <span class="cf">return</span> a <span class="op">==</span> b; <span class="co">// (*)</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="op">}</span></span></code></pre></div>
<p>In C++17, the marked line is well-formed. The <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> for <code class="sourceCode cpp">basic_string</code> is a non-member function template, and so would not be considered a candidate; the only viable candidate is the <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> taking two <code class="sourceCode cpp">StringRef</code>s. With the proposed changes, the <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> for <code class="sourceCode cpp">basic_string</code> becomes a non-member hidden friend, <em>non-template</em>, which makes it a candidate (converting <code class="sourceCode cpp">a</code> to a <code class="sourceCode cpp">string</code>). That candidate is ambiguous with the <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==(</span>StringRef, StringRef<span class="op">)</span></code> candidate - each requires a conversion in one argument, so the call becomes ill-formed.</p>
<p>Many people might consider such a type - implicitly convertible in both directions (note that <code class="sourceCode cpp">string</code> to <code class="sourceCode cpp">string_view</code> is implicit, but <code class="sourceCode cpp">string_view</code> to <code class="sourceCode cpp">string</code> is explicit) - questionable. But this is still a breaking change to consider.</p>
<h2 id="was-ill-formed-now-well-formed"><span class="header-section-number">3.2</span> Was ill-formed, now well-formed<a href="#was-ill-formed-now-well-formed" class="self-link"></a></h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="dt">bool</span> ref_equal<span class="op">(</span>std<span class="op">::</span>reference_wrapper<span class="op">&lt;</span>std<span class="op">::</span>string<span class="op">&gt;</span> a,</span>
<span id="cb2-2"><a href="#cb2-2"></a>               std<span class="op">::</span>reference_wrapper<span class="op">&lt;</span>std<span class="op">::</span>string<span class="op">&gt;</span> b<span class="op">)</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>    <span class="cf">return</span> a <span class="op">==</span> b;</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="op">}</span></span></code></pre></div>
<p>The comparisons for <code class="sourceCode cpp">std<span class="op">::</span>reference_wrapper<span class="op">&lt;</span>T<span class="op">&gt;</span></code> are very strange. It’s not that this type is comparable based on <em>whether</em> <code class="sourceCode cpp">T</code> is comparable. It’s actually that this type is comparable based on <em>how</em> <code class="sourceCode cpp">T</code> is comparable. We can compare <code class="sourceCode cpp">std<span class="op">::</span>reference_wrapper<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span></code>s, but we cannot compare <code class="sourceCode cpp">std<span class="op">::</span>reference_wrapper<span class="op">&lt;</span>std<span class="op">::</span>string<span class="op">&gt;</span></code>s because the comparisons for <code class="sourceCode cpp">basic_string</code> are non-member function templates. That’s just weird. This change wouldn’t actually resolve that weirdness generally (it wouldn’t affect any user types whose comparisons are non-member function templates), but it would at least reduce it for the standard library. Arguably an improvement.</p>
<p>However, the more interesting case is:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="dt">bool</span> is42<span class="op">(</span>std<span class="op">::</span>variant<span class="op">&lt;</span><span class="dt">int</span>, std<span class="op">::</span>string<span class="op">&gt;</span> <span class="kw">const</span><span class="op">&amp;</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>    <span class="cf">return</span> v <span class="op">==</span> <span class="dv">42</span>; <span class="co">// (*)</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="op">}</span></span></code></pre></div>
<p>In C++17, the <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> for <code class="sourceCode cpp">variant</code> is a non-member function template and is thus not a viable candidate for the marked line. That check is ill-formed. With the proposed changes, the <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> for <code class="sourceCode cpp">variant</code> becomes a non-member hidden friend, <em>non-template</em>, which makes it a candidate (converting <code class="sourceCode cpp"><span class="dv">42</span></code> to a <code class="sourceCode cpp">variant<span class="op">&lt;</span><span class="dt">int</span>, string<span class="op">&gt;</span></code>). Many would argue that this a fix, since both <code class="sourceCode cpp">variant<span class="op">&lt;</span><span class="dt">int</span>, string<span class="op">&gt;</span> v <span class="op">=</span> <span class="dv">42</span>;</code> and <code class="sourceCode cpp">v <span class="op">=</span> <span class="dv">42</span>;</code> are already well-formed, so it is surely reasonable that <code class="sourceCode cpp">v <span class="op">==</span> <span class="dv">42</span></code> is as well.</p>
<p>But we already had a proposal to do precisely this: <span class="citation" data-cites="P1201R0">[<a href="#ref-P1201R0" role="doc-biblioref">P1201R0</a>]</span>, which failed to gain consensus in LEWGI in San Diego (vote was 2-6-2-3-3).</p>
<h2 id="alternatives"><span class="header-section-number">3.3</span> Alternatives<a href="#alternatives" class="self-link"></a></h2>
<p>The benefit of the hidden friend technique wasn’t the only way to achieve the ultimate goal of reducing the overload candidate set. Casey Carter suggested another:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> Traits <span class="op">=</span> char_traits<span class="op">&lt;</span>T<span class="op">&gt;</span>, <span class="kw">class</span> Alloc <span class="op">=</span> allocator<span class="op">&lt;</span>T<span class="op">&gt;&gt;</span> <span class="kw">class</span> basic_string;</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="kw">namespace</span> __foo <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="kw">struct</span> __tag <span class="op">{}</span>;</span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> Traits, <span class="kw">class</span> Alloc<span class="op">&gt;</span> </span>
<span id="cb4-7"><a href="#cb4-7"></a>  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> basic_string<span class="op">&lt;</span>T, Traits, Alloc<span class="op">&gt;&amp;</span>, <span class="kw">const</span> basic_string<span class="op">&lt;</span>T, Traits, Alloc<span class="op">&gt;&amp;)</span>;</span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a>  <span class="co">/* ... */</span></span>
<span id="cb4-10"><a href="#cb4-10"></a><span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11"></a></span>
<span id="cb4-12"><a href="#cb4-12"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T, <span class="kw">class</span> Traits, <span class="kw">class</span> Alloc<span class="op">&gt;</span> <span class="kw">class</span> basic_string <span class="op">:</span> <span class="kw">private</span> __foo<span class="op">::</span>__tag <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13"></a>  <span class="co">/* ... */</span></span>
<span id="cb4-14"><a href="#cb4-14"></a><span class="op">}</span>;</span></code></pre></div>
<p>That is, we keep <code class="sourceCode cpp">basic_string</code>’s comparisons as non-member function templates – but we move them into a different namespace that is <em>only</em> associated with <code class="sourceCode cpp">basic_string</code>. This is an interesting direction to take, but is novel and has some specification burden.</p>
<h2 id="proposed-direction"><span class="header-section-number">3.4</span> Proposed Direction<a href="#proposed-direction" class="self-link"></a></h2>
<p>Ultimately, the goal here is to add <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> to all the types in the standard library. While I think the goal of reducing the candidate set for comparisons with standard library types is absolutely worth pursuing, it is a completely orthogonal goal and can be addressed by a different proposal in the future.</p>
<p>Given that we’ve said that users aren’t allowed to take the address of most standard library functions, Casey’s proposed implementation might even be valid under today’s wording for those standard library class templates whose comparisons are non-member templates, so I’d encourage implementors to experiment there.</p>
<p>The direction this paper is taking is the path of least resistance: keep all the comparison operators as they are. Add <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> in the same form that <code class="sourceCode cpp"><span class="op">&lt;</span></code> appears today. With a few exceptions: those types for which adding a defaulted <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">==</span></code> would allow them to be used as non-type template parameters after <span class="citation" data-cites="P0732R2">[<a href="#ref-P0732R2" role="doc-biblioref">P0732R2</a>]</span> (and only those types) will have their comparisons implemented as hidden friends.</p>
<h1 id="acknowledgements" style="border-bottom:1px solid #cccccc"><span class="header-section-number">4</span> Acknowledgements<a href="#acknowledgements" class="self-link"></a></h1>
<p>Thank you to all the paper authors that have committed time to making sure all this works: Gašper Ažman, Walter Brown, Lawrence Crowl, Tomasz Kamiński, Arthur O’Dwyer, Jeff Snyder, David Stone, and Herb Sutter.</p>
<p>Thank you to Casey Carter for the tremendous wording review.</p>
<h1 id="wording" style="border-bottom:1px solid #cccccc"><span class="header-section-number">5</span> Wording<a href="#wording" class="self-link"></a></h1>
<h2 id="clause-16-library-introduction"><span class="header-section-number">5.1</span> Clause 16: Library Introduction<a href="#clause-16-library-introduction" class="self-link"></a></h2>
<p>Change 16.4.2.1/2 [expos.only.func]:</p>
<blockquote>
<p>The following <span class="rm" style="color: #bf0303"><del>function is</del></span> <span class="add" style="color: #006e28"><ins>are</ins></span> defined for exposition only to aid in the specification of the library:</p>
</blockquote>
<p>and append:</p>
<blockquote>
<div class="add" style="color: #006e28">

<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1"></a>constexpr auto <em>synth-3way</em> =</span>
<span id="cb1-2"><a href="#cb1-2"></a>  []&lt;class T, class U&gt;(const T&amp; t, const U&amp; u)</span>
<span id="cb1-3"><a href="#cb1-3"></a>    requires requires {</span>
<span id="cb1-4"><a href="#cb1-4"></a>      { t &lt; u } -&gt; bool;</span>
<span id="cb1-5"><a href="#cb1-5"></a>      { u &lt; t } -&gt; bool;</span>
<span id="cb1-6"><a href="#cb1-6"></a>    }</span>
<span id="cb1-7"><a href="#cb1-7"></a>  {</span>
<span id="cb1-8"><a href="#cb1-8"></a>    if constexpr (ThreeWayComparableWith&lt;T, U&gt;) {</span>
<span id="cb1-9"><a href="#cb1-9"></a>      return t &lt;=&gt; u;</span>
<span id="cb1-10"><a href="#cb1-10"></a>    } else {</span>
<span id="cb1-11"><a href="#cb1-11"></a>      if (t &lt; u) return weak_ordering::less;</span>
<span id="cb1-12"><a href="#cb1-12"></a>      if (u &lt; t) return weak_ordering::greater;</span>
<span id="cb1-13"><a href="#cb1-13"></a>      return weak_ordering::equivalent;</span>
<span id="cb1-14"><a href="#cb1-14"></a>    }</span>
<span id="cb1-15"><a href="#cb1-15"></a>  };</span>
<span id="cb1-16"><a href="#cb1-16"></a></span>
<span id="cb1-17"><a href="#cb1-17"></a>template&lt;class T, class U=T&gt;</span>
<span id="cb1-18"><a href="#cb1-18"></a>using <em>synth-3way-result</em> = decltype(<em>synth-3way</em>(declval&lt;T&amp;&gt;(), declval&lt;U&amp;&gt;()));</span></code></pre></div>

</div>
</blockquote>
<p>Remove all of 16.4.2.3 [operators], which begins:</p>
<blockquote>
<p><span class="rm" style="color: #bf0303"><del>In this library, whenever a declaration is provided for an <span><code class="sourceCode cpp"><span class="kw">operator</span><span class="op">!=</span></code></span>, <span><code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&gt;</span></code></span>, <span><code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=</span></code></span>, or <span><code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&gt;=</span></code></span> for a type <span><code class="sourceCode cpp">T</code></span>, its requirements and semantics are as follows, unless explicitly specified otherwise.</del></span></p>
</blockquote>
<h2 id="clause-17-language-support-library"><span class="header-section-number">5.2</span> Clause 17: Language support library<a href="#clause-17-language-support-library" class="self-link"></a></h2>
<p>Added: <code class="sourceCode cpp">compare_three_way_result</code>, concepts <code class="sourceCode cpp">ThreeWayComparable</code> and <code class="sourceCode cpp">ThreeWayComparableWith</code>, <code class="sourceCode cpp">compare_three_way</code> and <code class="sourceCode cpp">compare_XXX_order_fallback</code></p>
<p>Changed operators for: <code class="sourceCode cpp">type_info</code></p>
<p>Respecified: <code class="sourceCode cpp">strong_order<span class="op">()</span></code>, <code class="sourceCode cpp">weak_order<span class="op">()</span></code>, and <code class="sourceCode cpp">partial_order<span class="op">()</span></code></p>
<p>Removed: <code class="sourceCode cpp">compare_3way<span class="op">()</span></code>, <code class="sourceCode cpp">strong_equal<span class="op">()</span></code>, and <code class="sourceCode cpp">weak_equal<span class="op">()</span></code></p>
<p>In 17.7.2 [type.info], remove <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">!=</span></code>:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb5"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb5-1"><a href="#cb5-1"></a>namespace std {</span>
<span id="cb5-2"><a href="#cb5-2"></a>  class type_info {</span>
<span id="cb5-3"><a href="#cb5-3"></a>  public:</span>
<span id="cb5-4"><a href="#cb5-4"></a>    virtual ~type_info();</span>
<span id="cb5-5"><a href="#cb5-5"></a>    bool operator==(const type_info&amp; rhs) const noexcept;</span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="st">-   bool operator!=(const type_info&amp; rhs) const noexcept;</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>    bool before(const type_info&amp; rhs) const noexcept;</span>
<span id="cb5-8"><a href="#cb5-8"></a>    size_t hash_code() const noexcept;</span>
<span id="cb5-9"><a href="#cb5-9"></a>    const char* name() const noexcept;</span>
<span id="cb5-10"><a href="#cb5-10"></a>    type_info(const type_info&amp; rhs) = delete; // cannot be copied</span>
<span id="cb5-11"><a href="#cb5-11"></a>    type_info&amp; operator=(const type_info&amp; rhs) = delete; // cannot be copied</span>
<span id="cb5-12"><a href="#cb5-12"></a>  };</span>
<span id="cb5-13"><a href="#cb5-13"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>and:</p>
<blockquote>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> type_info<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Effects</em>: Compares the current object with <code class="sourceCode cpp">rhs</code>. <span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="kw">true</span></code> if the two values describe the same type.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="rm" style="color: #bf0303"><del>bool operator!=(const type_info&amp; rhs) const noexcept;</del></span></span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <span class="rm" style="color: #bf0303"><del><em>Returns</em>: <span><code class="sourceCode cpp"><span class="op">!(*</span><span class="kw">this</span> <span class="op">==</span> rhs<span class="op">)</span></code></span>.</del></span></p>
</blockquote>
<p>Add into 17.11.1 [compare.syn]:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb1"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb1-1"><a href="#cb1-1"></a>namespace std {</span>
<span id="cb1-2"><a href="#cb1-2"></a>  // [cmp.categories], comparison category types</span>
<span id="cb1-3"><a href="#cb1-3"></a>  class weak_equality;</span>
<span id="cb1-4"><a href="#cb1-4"></a>  class strong_equality;</span>
<span id="cb1-5"><a href="#cb1-5"></a>  class partial_ordering;</span>
<span id="cb1-6"><a href="#cb1-6"></a>  class weak_ordering;</span>
<span id="cb1-7"><a href="#cb1-7"></a>  class strong_ordering;</span>
<span id="cb1-8"><a href="#cb1-8"></a></span>
<span id="cb1-9"><a href="#cb1-9"></a>  // named comparison functions</span>
<span id="cb1-10"><a href="#cb1-10"></a>  constexpr bool is_eq  (weak_equality cmp) noexcept    { return cmp == 0; }</span>
<span id="cb1-11"><a href="#cb1-11"></a>  constexpr bool is_neq (weak_equality cmp) noexcept    { return cmp != 0; }</span>
<span id="cb1-12"><a href="#cb1-12"></a>  constexpr bool is_lt  (partial_ordering cmp) noexcept { return cmp &lt; 0; }</span>
<span id="cb1-13"><a href="#cb1-13"></a>  constexpr bool is_lteq(partial_ordering cmp) noexcept { return cmp &lt;= 0; }</span>
<span id="cb1-14"><a href="#cb1-14"></a>  constexpr bool is_gt  (partial_ordering cmp) noexcept { return cmp &gt; 0; }</span>
<span id="cb1-15"><a href="#cb1-15"></a>  constexpr bool is_gteq(partial_ordering cmp) noexcept { return cmp &gt;= 0; }</span>
<span id="cb1-16"><a href="#cb1-16"></a></span>
<span id="cb1-17"><a href="#cb1-17"></a><span class="va">+ // common type specializations</span></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="va">+ template&lt;&gt; struct common_type&lt;strong_equality, partial_ordering&gt;</span></span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="va">+   { using type = weak_equality; };</span></span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="va">+ template&lt;&gt; struct common_type&lt;partial_ordering, strong_equality&gt;</span></span>
<span id="cb1-21"><a href="#cb1-21"></a><span class="va">+   { using type = weak_equality; };</span></span>
<span id="cb1-22"><a href="#cb1-22"></a><span class="va">+ template&lt;&gt; struct common_type&lt;strong_equality, weak_ordering&gt;</span></span>
<span id="cb1-23"><a href="#cb1-23"></a><span class="va">+   { using type = weak_equality; };</span></span>
<span id="cb1-24"><a href="#cb1-24"></a><span class="va">+ template&lt;&gt; struct common_type&lt;weak_ordering, strong_equality&gt;</span></span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="va">+   { using type = weak_equality; };</span></span>
<span id="cb1-26"><a href="#cb1-26"></a></span>
<span id="cb1-27"><a href="#cb1-27"></a>  // [cmp.common], common comparison category type</span>
<span id="cb1-28"><a href="#cb1-28"></a>  template&lt;class... Ts&gt;</span>
<span id="cb1-29"><a href="#cb1-29"></a>  struct common_comparison_category {</span>
<span id="cb1-30"><a href="#cb1-30"></a>    using type = <em>see below</em>;</span>
<span id="cb1-31"><a href="#cb1-31"></a>  };</span>
<span id="cb1-32"><a href="#cb1-32"></a>  template&lt;class... Ts&gt;</span>
<span id="cb1-33"><a href="#cb1-33"></a>    using common_comparison_category_t = typename common_comparison_category&lt;Ts...&gt;::type;</span>
<span id="cb1-34"><a href="#cb1-34"></a></span>
<span id="cb1-35"><a href="#cb1-35"></a><span class="va">+ // [cmp.concept], concept ThreeWayComparable</span></span>
<span id="cb1-36"><a href="#cb1-36"></a><span class="va">+ template&lt;class T, class Cat = partial_ordering&gt;</span></span>
<span id="cb1-37"><a href="#cb1-37"></a><span class="va">+   concept ThreeWayComparable = <em>see below</em>;</span></span>
<span id="cb1-38"><a href="#cb1-38"></a><span class="va">+ template&lt;class T, class U, class Cat = partial_ordering&gt;</span></span>
<span id="cb1-39"><a href="#cb1-39"></a><span class="va">+   concept ThreeWayComparableWith = <em>see below</em>;</span></span>
<span id="cb1-40"><a href="#cb1-40"></a><span class="va">+</span></span>
<span id="cb1-41"><a href="#cb1-41"></a><span class="va">+ // [cmp.result], spaceship invocation result</span></span>
<span id="cb1-42"><a href="#cb1-42"></a><span class="va">+ template&lt;class T, class U = T&gt; struct compare_three_way_result;</span></span>
<span id="cb1-43"><a href="#cb1-43"></a><span class="va">+</span></span>
<span id="cb1-44"><a href="#cb1-44"></a><span class="va">+ template&lt;class T, class U = T&gt;</span></span>
<span id="cb1-45"><a href="#cb1-45"></a><span class="va">+   using compare_three_way_result_t = typename compare_three_way_result&lt;T, U&gt;::type;</span></span>
<span id="cb1-46"><a href="#cb1-46"></a><span class="va">+</span></span>
<span id="cb1-47"><a href="#cb1-47"></a><span class="va">+ // [cmp.object], spaceship object</span></span>
<span id="cb1-48"><a href="#cb1-48"></a><span class="va">+ struct compare_three_way;</span></span>
<span id="cb1-49"><a href="#cb1-49"></a></span>
<span id="cb1-50"><a href="#cb1-50"></a>  // [cmp.alg], comparison algorithms</span>
<span id="cb1-51"><a href="#cb1-51"></a><span class="st">- template&lt;class T&gt; constexpr strong_ordering strong_order(const T&amp; a, const T&amp; b);</span></span>
<span id="cb1-52"><a href="#cb1-52"></a><span class="st">- template&lt;class T&gt; constexpr weak_ordering weak_order(const T&amp; a, const T&amp; b);</span></span>
<span id="cb1-53"><a href="#cb1-53"></a><span class="st">- template&lt;class T&gt; constexpr partial_ordering partial_order(const T&amp; a, const T&amp; b);</span></span>
<span id="cb1-54"><a href="#cb1-54"></a><span class="st">- template&lt;class T&gt; constexpr strong_equality strong_equal(const T&amp; a, const T&amp; b);</span></span>
<span id="cb1-55"><a href="#cb1-55"></a><span class="st">- template&lt;class T&gt; constexpr weak_equality weak_equal(const T&amp; a, const T&amp; b);</span></span>
<span id="cb1-56"><a href="#cb1-56"></a><span class="va">+ inline namespace <em>unspecified</em> {</span></span>
<span id="cb1-57"><a href="#cb1-57"></a><span class="va">+   inline constexpr <em>unspecified</em> strong_order = <em>unspecified</em>;</span></span>
<span id="cb1-58"><a href="#cb1-58"></a><span class="va">+   inline constexpr <em>unspecified</em> weak_order = <em>unspecified</em>;</span></span>
<span id="cb1-59"><a href="#cb1-59"></a><span class="va">+   inline constexpr <em>unspecified</em> partial_order = <em>unspecified</em>;</span></span>
<span id="cb1-60"><a href="#cb1-60"></a><span class="va">+   inline constexpr <em>unspecified</em> compare_strong_order_fallback = <em>unspecified</em>;</span></span>
<span id="cb1-61"><a href="#cb1-61"></a><span class="va">+   inline constexpr <em>unspecified</em> compare_weak_order_fallback = <em>unspecified</em>;</span></span>
<span id="cb1-62"><a href="#cb1-62"></a><span class="va">+   inline constexpr <em>unspecified</em> compare_partial_order_fallback = <em>unspecified</em>;</span></span>
<span id="cb1-63"><a href="#cb1-63"></a><span class="va">+ }</span></span>
<span id="cb1-64"><a href="#cb1-64"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>Change 17.11.2.2 [cmp.weakeq]:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb1"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb1-1"><a href="#cb1-1"></a>namespace std {</span>
<span id="cb1-2"><a href="#cb1-2"></a>  class weak_equality {</span>
<span id="cb1-3"><a href="#cb1-3"></a>    int value;  // exposition only</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a>    [...]</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a>    // comparisons</span>
<span id="cb1-8"><a href="#cb1-8"></a>    friend constexpr bool operator==(weak_equality v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="st">-   friend constexpr bool operator!=(weak_equality v, <em>unspecified</em>) noexcept;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="st">-   friend constexpr bool operator==(<em>unspecified</em>, weak_equality v) noexcept;</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="st">-   friend constexpr bool operator!=(<em>unspecified</em>, weak_equality v) noexcept;</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="va">+   friend constexpr bool operator==(weak_equality v, weak_equality w) noexcept = default;</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>    friend constexpr weak_equality operator&lt;=&gt;(weak_equality v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-14"><a href="#cb1-14"></a>    friend constexpr weak_equality operator&lt;=&gt;(<em>unspecified</em>, weak_equality v) noexcept;</span>
<span id="cb1-15"><a href="#cb1-15"></a>  };</span>
<span id="cb1-16"><a href="#cb1-16"></a></span>
<span id="cb1-17"><a href="#cb1-17"></a>  [...]</span>
<span id="cb1-18"><a href="#cb1-18"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>and remove those functions from the description:</p>
<blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>weak_equality v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="rm" style="color: #bf0303"><del>constexpr bool operator==(<em>unspecified</em>, weak_equality v) noexcept;</del></span></span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp">v<span class="op">.</span>value <span class="op">==</span> <span class="dv">0</span></code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="rm" style="color: #bf0303"><del>constexpr bool operator!=(weak_equality v, <em>unspecified</em>) noexcept;</del></span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="rm" style="color: #bf0303"><del>constexpr bool operator!=(<em>unspecified</em>, weak_equality v) noexcept;</del></span></span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <span class="rm" style="color: #bf0303"><del><em>Returns</em>: <span><code class="sourceCode cpp">v<span class="op">.</span>value <span class="op">!=</span> <span class="dv">0</span></code></span>.</del></span></p>
</blockquote>
<p>Change 17.11.2.3 [cmp.strongeq]:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb1"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb1-1"><a href="#cb1-1"></a>namespace std {</span>
<span id="cb1-2"><a href="#cb1-2"></a>  class strong_equality {</span>
<span id="cb1-3"><a href="#cb1-3"></a>    int value;  // exposition only</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a>    [...]</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a>    // comparisons</span>
<span id="cb1-8"><a href="#cb1-8"></a>    friend constexpr bool operator==(strong_equality v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="st">-   friend constexpr bool operator!=(strong_equality v, <em>unspecified</em>) noexcept;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="st">-   friend constexpr bool operator==(<em>unspecified</em>, strong_equality v) noexcept;</span></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="st">-   friend constexpr bool operator!=(<em>unspecified</em>, strong_equality v) noexcept;</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="va">+   friend constexpr bool operator==(strong_equality v, strong_equality w) noexcept = default;  </span></span>
<span id="cb1-13"><a href="#cb1-13"></a>    friend constexpr strong_equality operator&lt;=&gt;(strong_equality v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-14"><a href="#cb1-14"></a>    friend constexpr strong_equality operator&lt;=&gt;(<em>unspecified</em>, strong_equality v) noexcept;</span>
<span id="cb1-15"><a href="#cb1-15"></a>  };</span>
<span id="cb1-16"><a href="#cb1-16"></a></span>
<span id="cb1-17"><a href="#cb1-17"></a>  [...]</span>
<span id="cb1-18"><a href="#cb1-18"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>and remove those functions from the description:</p>
<blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>strong_equality v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="rm" style="color: #bf0303"><del>constexpr bool operator==(<em>unspecified</em>, strong_equality v) noexcept;</del></span></span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: <code class="sourceCode cpp">v<span class="op">.</span>value <span class="op">==</span> <span class="dv">0</span></code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="rm" style="color: #bf0303"><del>constexpr bool operator!=(strong_equality v, <em>unspecified</em>) noexcept;</del></span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="rm" style="color: #bf0303"><del>constexpr bool operator!=(<em>unspecified</em>, strong_equality v) noexcept;</del></span></span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <span class="rm" style="color: #bf0303"><del><em>Returns</em>: <span><code class="sourceCode cpp">v<span class="op">.</span>value <span class="op">!=</span> <span class="dv">0</span></code></span>.</del></span></p>
</blockquote>
<p>Change 17.11.2.4 [cmp.partialord]:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb1"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb1-1"><a href="#cb1-1"></a>namespace std {</span>
<span id="cb1-2"><a href="#cb1-2"></a>  class partial_ordering {</span>
<span id="cb1-3"><a href="#cb1-3"></a>    int value;          // exposition only</span>
<span id="cb1-4"><a href="#cb1-4"></a>    bool is_ordered;    // exposition only</span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a>    [...]</span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a>    // conversion</span>
<span id="cb1-9"><a href="#cb1-9"></a>    constexpr operator weak_equality() const noexcept;</span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a>    // comparisons</span>
<span id="cb1-12"><a href="#cb1-12"></a>    friend constexpr bool operator==(partial_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="st">-   friend constexpr bool operator!=(partial_ordering v, <em>unspecified</em>) noexcept;</span></span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="va">+   friend constexpr bool operator==(partial_ordering v, partial_ordering w) noexcept = default;</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>    friend constexpr bool operator&lt; (partial_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-16"><a href="#cb1-16"></a>    friend constexpr bool operator&gt; (partial_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-17"><a href="#cb1-17"></a>    friend constexpr bool operator&lt;=(partial_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-18"><a href="#cb1-18"></a>    friend constexpr bool operator&gt;=(partial_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-19"><a href="#cb1-19"></a><span class="st">-   friend constexpr bool operator==(<em>unspecified</em>, partial_ordering v) noexcept;</span></span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="st">-   friend constexpr bool operator!=(<em>unspecified</em>, partial_ordering v) noexcept;</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>    friend constexpr bool operator&lt; (<em>unspecified</em>, partial_ordering v) noexcept;</span>
<span id="cb1-22"><a href="#cb1-22"></a>    friend constexpr bool operator&gt; (<em>unspecified</em>, partial_ordering v) noexcept;</span>
<span id="cb1-23"><a href="#cb1-23"></a>    friend constexpr bool operator&lt;=(<em>unspecified</em>, partial_ordering v) noexcept;</span>
<span id="cb1-24"><a href="#cb1-24"></a>    friend constexpr bool operator&gt;=(<em>unspecified</em>, partial_ordering v) noexcept;</span>
<span id="cb1-25"><a href="#cb1-25"></a>    friend constexpr partial_ordering operator&lt;=&gt;(partial_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-26"><a href="#cb1-26"></a>    friend constexpr partial_ordering operator&lt;=&gt;(<em>unspecified</em>, partial_ordering v) noexcept;</span>
<span id="cb1-27"><a href="#cb1-27"></a>  };</span>
<span id="cb1-28"><a href="#cb1-28"></a></span>
<span id="cb1-29"><a href="#cb1-29"></a>  [...]</span>
<span id="cb1-30"><a href="#cb1-30"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>Remove just the extra <code class="sourceCode cpp"><span class="op">==</span></code> and <code class="sourceCode cpp"><span class="op">!=</span></code> operators in 17.11.2.4 [cmp.partialord]/4-5:</p>
<blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>partial_ordering v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;</span> <span class="op">(</span>partial_ordering v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;</span> <span class="op">(</span>partial_ordering v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span>partial_ordering v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span>partial_ordering v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: For <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>, <code class="sourceCode cpp">v<span class="op">.</span>is_ordered <span class="op">&amp;&amp;</span> v<span class="op">.</span>value <span class="op">@</span> <span class="dv">0</span></code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="rm" style="color: #bf0303"><del>constexpr bool operator==(<em>unspecified</em>, partial_ordering v) noexcept;</del></span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;</span> <span class="op">(</span><em>unspecified</em>, partial_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;</span> <span class="op">(</span><em>unspecified</em>, partial_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span><em>unspecified</em>, partial_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><em>unspecified</em>, partial_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: For <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>, <code class="sourceCode cpp">v<span class="op">.</span>is_ordered <span class="op">&amp;&amp;</span> <span class="dv">0</span> <span class="op">@</span> v<span class="op">.</span>value</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="rm" style="color: #bf0303"><del>constexpr bool operator!=(partial_ordering v, <em>unspecified</em>) noexcept;</del></span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="rm" style="color: #bf0303"><del>constexpr bool operator!=(<em>unspecified</em>, partial_ordering v) noexcept;</del></span></span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <span class="rm" style="color: #bf0303"><del><em>Returns</em>: For <span><code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code></span>, <span><code class="sourceCode cpp"><span class="op">!</span>v<span class="op">.</span>is_ordered <span class="op">||</span> v<span class="op">.</span>value <span class="op">!=</span> <span class="dv">0</span></code></span>.</del></span></p>
</blockquote>
<p>Change 17.11.2.5 [cmp.weakord]:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb1"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb1-1"><a href="#cb1-1"></a>namespace std {</span>
<span id="cb1-2"><a href="#cb1-2"></a>  class weak_ordering {</span>
<span id="cb1-3"><a href="#cb1-3"></a>    int value;  // exposition only</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a>    [...]</span>
<span id="cb1-6"><a href="#cb1-6"></a>    // comparisons</span>
<span id="cb1-7"><a href="#cb1-7"></a>    friend constexpr bool operator==(weak_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="va">+   friend constexpr bool operator==(weak_ordering v, weak_ordering w) noexcept = default;</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="st">-   friend constexpr bool operator!=(weak_ordering v, <em>unspecified</em>) noexcept;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>    friend constexpr bool operator&lt; (weak_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-11"><a href="#cb1-11"></a>    friend constexpr bool operator&gt; (weak_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-12"><a href="#cb1-12"></a>    friend constexpr bool operator&lt;=(weak_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-13"><a href="#cb1-13"></a>    friend constexpr bool operator&gt;=(weak_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-14"><a href="#cb1-14"></a><span class="st">-   friend constexpr bool operator==(<em>unspecified</em>, weak_ordering v) noexcept;</span></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="st">-   friend constexpr bool operator!=(<em>unspecified</em>, weak_ordering v) noexcept;</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>    friend constexpr bool operator&lt; (<em>unspecified</em>, weak_ordering v) noexcept;</span>
<span id="cb1-17"><a href="#cb1-17"></a>    friend constexpr bool operator&gt; (<em>unspecified</em>, weak_ordering v) noexcept;</span>
<span id="cb1-18"><a href="#cb1-18"></a>    friend constexpr bool operator&lt;=(<em>unspecified</em>, weak_ordering v) noexcept;</span>
<span id="cb1-19"><a href="#cb1-19"></a>    friend constexpr bool operator&gt;=(<em>unspecified</em>, weak_ordering v) noexcept;</span>
<span id="cb1-20"><a href="#cb1-20"></a>    friend constexpr weak_ordering operator&lt;=&gt;(weak_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-21"><a href="#cb1-21"></a>    friend constexpr weak_ordering operator&lt;=&gt;(<em>unspecified</em>, weak_ordering v) noexcept;</span>
<span id="cb1-22"><a href="#cb1-22"></a>  };</span>
<span id="cb1-23"><a href="#cb1-23"></a></span>
<span id="cb1-24"><a href="#cb1-24"></a>  [...]</span>
<span id="cb1-25"><a href="#cb1-25"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>Remove just the extra <code class="sourceCode cpp"><span class="op">==</span></code> and <code class="sourceCode cpp"><span class="op">!=</span></code> operators from 17.11.2.5 [cmp.weakord]/4 and /5:</p>
<blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>weak_ordering v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="rm" style="color: #bf0303"><del>constexpr bool operator!=(weak_ordering v, <em>unspecified</em>) noexcept;</del></span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;</span> <span class="op">(</span>weak_ordering v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;</span> <span class="op">(</span>weak_ordering v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span>weak_ordering v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span>weak_ordering v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: <code class="sourceCode cpp">v<span class="op">.</span>value <span class="op">@</span> <span class="dv">0</span></code> for <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="rm" style="color: #bf0303"><del>constexpr bool operator==(<em>unspecified</em>, weak_ordering v) noexcept;</del></span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="rm" style="color: #bf0303"><del>constexpr bool operator!=(<em>unspecified</em>, weak_ordering v) noexcept;</del></span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;</span> <span class="op">(</span><em>unspecified</em>, weak_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;</span> <span class="op">(</span><em>unspecified</em>, weak_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span><em>unspecified</em>, weak_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><em>unspecified</em>, weak_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="dv">0</span> <span class="op">@</span> v<span class="op">.</span>value</code> for <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>.</p>
</blockquote>
<p>Change 17.11.2.6 [cmp.strongord]:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb1"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb1-1"><a href="#cb1-1"></a>namespace std {</span>
<span id="cb1-2"><a href="#cb1-2"></a>  class strong_ordering {</span>
<span id="cb1-3"><a href="#cb1-3"></a>    int value;  // exposition only</span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a>    [...]</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a>    // comparisons</span>
<span id="cb1-8"><a href="#cb1-8"></a>    friend constexpr bool operator==(strong_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="va">+   friend constexpr bool operator==(strong_ordering v, strong_ordering w) noexcept = default;</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="st">-   friend constexpr bool operator!=(strong_ordering v, <em>unspecified</em>) noexcept;</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>    friend constexpr bool operator&lt; (strong_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-12"><a href="#cb1-12"></a>    friend constexpr bool operator&gt; (strong_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-13"><a href="#cb1-13"></a>    friend constexpr bool operator&lt;=(strong_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-14"><a href="#cb1-14"></a>    friend constexpr bool operator&gt;=(strong_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="st">-   friend constexpr bool operator==(<em>unspecified</em>, strong_ordering v) noexcept;</span></span>
<span id="cb1-16"><a href="#cb1-16"></a><span class="st">-   friend constexpr bool operator!=(<em>unspecified</em>, strong_ordering v) noexcept;</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>    friend constexpr bool operator&lt; (<em>unspecified</em>, strong_ordering v) noexcept;</span>
<span id="cb1-18"><a href="#cb1-18"></a>    friend constexpr bool operator&gt; (<em>unspecified</em>, strong_ordering v) noexcept;</span>
<span id="cb1-19"><a href="#cb1-19"></a>    friend constexpr bool operator&lt;=(<em>unspecified</em>, strong_ordering v) noexcept;</span>
<span id="cb1-20"><a href="#cb1-20"></a>    friend constexpr bool operator&gt;=(<em>unspecified</em>, strong_ordering v) noexcept;</span>
<span id="cb1-21"><a href="#cb1-21"></a>    friend constexpr strong_ordering operator&lt;=&gt;(strong_ordering v, <em>unspecified</em>) noexcept;</span>
<span id="cb1-22"><a href="#cb1-22"></a>    friend constexpr strong_ordering operator&lt;=&gt;(<em>unspecified</em>, strong_ordering v) noexcept;</span>
<span id="cb1-23"><a href="#cb1-23"></a>  };</span>
<span id="cb1-24"><a href="#cb1-24"></a></span>
<span id="cb1-25"><a href="#cb1-25"></a>  [...]</span>
<span id="cb1-26"><a href="#cb1-26"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>Remove just the extra <code class="sourceCode cpp"><span class="op">==</span></code> and <code class="sourceCode cpp"><span class="op">!=</span></code> operators from 17.11.2.6 [cmp.strongord]/6 and /7:</p>
<blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>strong_ordering v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="rm" style="color: #bf0303"><del>constexpr bool operator!=(strong_ordering v, <em>unspecified</em>) noexcept;</del></span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;</span> <span class="op">(</span>strong_ordering v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;</span> <span class="op">(</span>strong_ordering v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span>strong_ordering v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span>strong_ordering v, <em>unspecified</em><span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Returns</em>: <code class="sourceCode cpp">v<span class="op">.</span>value <span class="op">@</span> <span class="dv">0</span></code> for <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1"></a><span class="rm" style="color: #bf0303"><del>constexpr bool operator==(<em>unspecified</em>, strong_ordering v) noexcept;</del></span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="rm" style="color: #bf0303"><del>constexpr bool operator!=(<em>unspecified</em>, strong_ordering v) noexcept;</del></span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;</span> <span class="op">(</span><em>unspecified</em>, strong_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;</span> <span class="op">(</span><em>unspecified</em>, strong_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;=(</span><em>unspecified</em>, strong_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&gt;=(</span><em>unspecified</em>, strong_ordering v<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="dv">0</span> <span class="op">@</span> v<span class="op">.</span>value</code> for <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">@</span></code>.</p>
</blockquote>
<p>Add a new subclause [cmp.concept] “concept ThreeWayComparable”:</p>
<blockquote>
<div class="add" style="color: #006e28">

<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1"></a>template &lt;typename T, typename Cat&gt;</span>
<span id="cb1-2"><a href="#cb1-2"></a>  concept <em>compares-as</em> = // exposition only</span>
<span id="cb1-3"><a href="#cb1-3"></a>    Same&lt;common_comparison_category_t&lt;T, Cat&gt;, Cat&gt;;</span></code></pre></div>
<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1"></a>template&lt;class T, class U&gt;</span>
<span id="cb1-2"><a href="#cb1-2"></a>  concept <em>partially-ordered-with</em> = // exposition only</span>
<span id="cb1-3"><a href="#cb1-3"></a>    requires(const remove_reference_t&lt;T&gt;&amp; t,</span>
<span id="cb1-4"><a href="#cb1-4"></a>             const remove_reference_t&lt;U&gt;&amp; u) {</span>
<span id="cb1-5"><a href="#cb1-5"></a>      { t &lt; u } -&gt; Boolean;</span>
<span id="cb1-6"><a href="#cb1-6"></a>      { t &gt; u } -&gt; Boolean;</span>
<span id="cb1-7"><a href="#cb1-7"></a>      { t &lt;= u } -&gt; Boolean;</span>
<span id="cb1-8"><a href="#cb1-8"></a>      { t &gt;= u } -&gt; Boolean;</span>
<span id="cb1-9"><a href="#cb1-9"></a>      { u &lt; t } -&gt; Boolean;</span>
<span id="cb1-10"><a href="#cb1-10"></a>      { u &gt; t } -&gt; Boolean;</span>
<span id="cb1-11"><a href="#cb1-11"></a>      { u &lt;= t } -&gt; Boolean;</span>
<span id="cb1-12"><a href="#cb1-12"></a>      { u &gt;= t } -&gt; Boolean;    </span>
<span id="cb1-13"><a href="#cb1-13"></a>    };</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> Let <code class="sourceCode cpp">t</code> and <code class="sourceCode cpp">u</code> be lvalues of types <code class="sourceCode cpp"><span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp"><span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>U<span class="op">&gt;</span></code> respectively. <em><code class="sourceCode cpp">partially<span class="op">-</span>ordered<span class="op">-</span>with</code></em><code class="sourceCode cpp"><span class="op">&lt;</span>T, U<span class="op">&gt;</span></code> is satisfied only if:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(1.1)</a></span> <code class="sourceCode cpp">t <span class="op">&lt;</span> u</code>, <code class="sourceCode cpp">t <span class="op">&lt;=</span> u</code>, <code class="sourceCode cpp">t <span class="op">&gt;</span> u</code>, <code class="sourceCode cpp">t <span class="op">&gt;=</span> u</code>, <code class="sourceCode cpp">u <span class="op">&lt;</span> t</code>, <code class="sourceCode cpp">u <span class="op">&lt;=</span> t</code>, <code class="sourceCode cpp">u <span class="op">&gt;</span> t</code>, and <code class="sourceCode cpp">u <span class="op">&gt;=</span> t</code> have the same domain.</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.2)</a></span> <code class="sourceCode cpp"><span class="dt">bool</span><span class="op">(</span>t <span class="op">&lt;</span> u<span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>u <span class="op">&gt;</span> t<span class="op">)</span></code></li>
<li><span class="marginalizedparent"><a class="marginalized">(1.3)</a></span> <code class="sourceCode cpp"><span class="dt">bool</span><span class="op">(</span>u <span class="op">&lt;</span> t<span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>t <span class="op">&gt;</span> u<span class="op">)</span></code></li>
<li><span class="marginalizedparent"><a class="marginalized">(1.4)</a></span> <code class="sourceCode cpp"><span class="dt">bool</span><span class="op">(</span>t <span class="op">&lt;=</span> u<span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>u <span class="op">&gt;=</span> t<span class="op">)</span></code></li>
<li><span class="marginalizedparent"><a class="marginalized">(1.5)</a></span> <code class="sourceCode cpp"><span class="dt">bool</span><span class="op">(</span>u <span class="op">&lt;=</span> t<span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>t <span class="op">&gt;=</span> u<span class="op">)</span></code></li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1"></a>template &lt;typename T, typename Cat = partial_ordering&gt;</span>
<span id="cb1-2"><a href="#cb1-2"></a>  concept ThreeWayComparable =</span>
<span id="cb1-3"><a href="#cb1-3"></a>    <em>weakly-equality-comparable-with</em>&lt;T, T&gt; &amp;&amp;</span>
<span id="cb1-4"><a href="#cb1-4"></a>    (!ConvertibleTo&lt;Cat, partial_ordering&gt; || <em>partially-ordered-with</em>&lt;T, T&gt;) &amp;&amp;</span>
<span id="cb1-5"><a href="#cb1-5"></a>    requires(const remove_reference_t&lt;T&gt;&amp; a,</span>
<span id="cb1-6"><a href="#cb1-6"></a>             const remove_reference_t&lt;T&gt;&amp; b) {</span>
<span id="cb1-7"><a href="#cb1-7"></a>      { a &lt;=&gt; b } -&gt; <em>compares-as</em>&lt;Cat&gt;;</span>
<span id="cb1-8"><a href="#cb1-8"></a>    };</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> Let <code class="sourceCode cpp">a</code> and <code class="sourceCode cpp">b</code> be lvalues of type <code class="sourceCode cpp"><span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>T<span class="op">&gt;</span></code>. <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp">Cat</code> model <code class="sourceCode cpp">ThreeWayComparable<span class="op">&lt;</span>T, Cat<span class="op">&gt;</span></code> only if:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(2.1)</a></span> <code class="sourceCode cpp"><span class="op">(</span>a <span class="op">&lt;=&gt;</span> b <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>a <span class="op">==</span> b<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.2)</a></span> <code class="sourceCode cpp"><span class="op">(</span>a <span class="op">&lt;=&gt;</span> b <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>a <span class="op">!=</span> b<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3)</a></span> <code class="sourceCode cpp"><span class="op">((</span>a <span class="op">&lt;=&gt;</span> b<span class="op">)</span> <span class="op">&lt;=&gt;</span> <span class="dv">0</span><span class="op">)</span></code> and <code class="sourceCode cpp"><span class="op">(</span><span class="dv">0</span> <span class="op">&lt;=&gt;</span> <span class="op">(</span>b <span class="op">&lt;=&gt;</span> a<span class="op">))</span></code> are equal</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.4)</a></span> If <code class="sourceCode cpp">Cat</code> is convertible to <code class="sourceCode cpp">strong_equality</code>, <code class="sourceCode cpp">T</code> models <code class="sourceCode cpp">EqualityComparable</code> ([concept.equalitycomparable]).</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.5)</a></span> If <code class="sourceCode cpp">Cat</code> is convertible to <code class="sourceCode cpp">partial_ordering</code>:
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(2.5.1)</a></span> <code class="sourceCode cpp"><span class="op">(</span>a <span class="op">&lt;=&gt;</span> b <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>a <span class="op">&lt;</span> b<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.5.2)</a></span> <code class="sourceCode cpp"><span class="op">(</span>a <span class="op">&lt;=&gt;</span> b <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>a <span class="op">&gt;</span> b<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.5.3)</a></span> <code class="sourceCode cpp"><span class="op">(</span>a <span class="op">&lt;=&gt;</span> b <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>a <span class="op">&lt;=</span> b<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.5.4)</a></span> <code class="sourceCode cpp"><span class="op">(</span>a <span class="op">&lt;=&gt;</span> b <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>a <span class="op">&gt;=</span> b<span class="op">)</span></code>.</li>
</ul></li>
<li><span class="marginalizedparent"><a class="marginalized">(2.5.5)</a></span> If <code class="sourceCode cpp">Cat</code> is convertible to <code class="sourceCode cpp">strong_ordering</code>, <code class="sourceCode cpp">T</code> models <code class="sourceCode cpp">StrictTotallyOrdered</code> ([concept.stricttotallyordered]).</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1"></a>template &lt;typename T, typename U,</span>
<span id="cb1-2"><a href="#cb1-2"></a>          typename Cat = partial_ordering&gt;</span>
<span id="cb1-3"><a href="#cb1-3"></a>  concept ThreeWayComparableWith = </span>
<span id="cb1-4"><a href="#cb1-4"></a>    <em>weakly-equality-comparable-with</em>&lt;T, U&gt; &amp;&amp;</span>
<span id="cb1-5"><a href="#cb1-5"></a>    (!ConvertibleTo&lt;Cat, partial_ordering&gt; || <em>partially-ordered-with</em>&lt;T, U&gt;) &amp;&amp;</span>
<span id="cb1-6"><a href="#cb1-6"></a>    ThreeWayComparable&lt;T, Cat&gt; &amp;&amp;</span>
<span id="cb1-7"><a href="#cb1-7"></a>    ThreeWayComparable&lt;U, Cat&gt; &amp;&amp;</span>
<span id="cb1-8"><a href="#cb1-8"></a>    CommonReference&lt;const remove_reference_t&lt;T&gt;&amp;, const remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;</span>
<span id="cb1-9"><a href="#cb1-9"></a>    ThreeWayComparable&lt;</span>
<span id="cb1-10"><a href="#cb1-10"></a>      common_reference_t&lt;const remove_reference_t&lt;T&gt;&amp;, const remove_reference_t&lt;U&gt;&amp;&gt;,</span>
<span id="cb1-11"><a href="#cb1-11"></a>      Cat&gt; &amp;&amp;</span>
<span id="cb1-12"><a href="#cb1-12"></a>    requires(const remove_reference_t&lt;T&gt;&amp; t,</span>
<span id="cb1-13"><a href="#cb1-13"></a>             const remove_reference_t&lt;U&gt;&amp; u) {</span>
<span id="cb1-14"><a href="#cb1-14"></a>      { t &lt;=&gt; u } -&gt; <em>compares-as</em>&lt;Cat&gt;;</span>
<span id="cb1-15"><a href="#cb1-15"></a>      { u &lt;=&gt; t } -&gt; <em>compares-as</em>&lt;Cat&gt;;</span>
<span id="cb1-16"><a href="#cb1-16"></a>    };</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> Let <code class="sourceCode cpp">t</code> and <code class="sourceCode cpp">u</code> be lvalues of types <code class="sourceCode cpp"><span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp"><span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>U<span class="op">&gt;</span></code>, respectively. Let <code class="sourceCode cpp">C</code> be <code class="sourceCode cpp">common_reference_t<span class="op">&lt;</span><span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>T<span class="op">&gt;&amp;</span>, <span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>U<span class="op">&gt;&amp;&gt;</span></code>. <code class="sourceCode cpp">T</code>, <code class="sourceCode cpp">U</code>, and <code class="sourceCode cpp">Cat</code> model <code class="sourceCode cpp">ThreeWayComparableWith<span class="op">&lt;</span>T, U, Cat<span class="op">&gt;</span></code> only if:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(3.1)</a></span> <code class="sourceCode cpp">t <span class="op">&lt;=&gt;</span> u</code> and <code class="sourceCode cpp">u <span class="op">&lt;=&gt;</span> t</code> have the same domain.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.2)</a></span> <code class="sourceCode cpp"><span class="op">((</span>t <span class="op">&lt;=&gt;</span> u<span class="op">)</span> <span class="op">&lt;=&gt;</span> <span class="dv">0</span><span class="op">)</span></code> and <code class="sourceCode cpp"><span class="op">(</span><span class="dv">0</span> <span class="op">&lt;=&gt;</span> <span class="op">(</span>u <span class="op">&lt;=&gt;</span> t<span class="op">))</span></code> are equal</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.3)</a></span> <code class="sourceCode cpp"><span class="op">(</span>t <span class="op">&lt;=&gt;</span> u <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>t <span class="op">==</span> u<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.4)</a></span> <code class="sourceCode cpp"><span class="op">(</span>t <span class="op">&lt;=&gt;</span> u <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>t <span class="op">!=</span> u<span class="op">)</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.5)</a></span> <code class="sourceCode cpp">Cat<span class="op">(</span>t <span class="op">&lt;=&gt;</span> u<span class="op">)</span> <span class="op">==</span> Cat<span class="op">(</span>C<span class="op">(</span>t<span class="op">)</span> <span class="op">&lt;=&gt;</span> C<span class="op">(</span>u<span class="op">))</span></code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.6)</a></span> If <code class="sourceCode cpp">Cat</code> is convertible to <code class="sourceCode cpp">strong_equality</code>, <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp">U</code> model <code class="sourceCode cpp">EqualityComparableWith<span class="op">&lt;</span>T, U<span class="op">&gt;</span></code> ([concepts.equalitycomparable]).</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.7)</a></span> If <code class="sourceCode cpp">Cat</code> is convertible to <code class="sourceCode cpp">partial_ordering</code>:
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(3.7.1)</a></span> <code class="sourceCode cpp"><span class="op">(</span>t <span class="op">&lt;=&gt;</span> u <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>t <span class="op">&lt;</span> u<span class="op">)</span></code></li>
<li><span class="marginalizedparent"><a class="marginalized">(3.7.2)</a></span> <code class="sourceCode cpp"><span class="op">(</span>t <span class="op">&lt;=&gt;</span> u <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>t <span class="op">&gt;</span> u<span class="op">)</span></code></li>
<li><span class="marginalizedparent"><a class="marginalized">(3.7.3)</a></span> <code class="sourceCode cpp"><span class="op">(</span>t <span class="op">&lt;=&gt;</span> u <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>t <span class="op">&lt;=</span> u<span class="op">)</span></code></li>
<li><span class="marginalizedparent"><a class="marginalized">(3.7.4)</a></span> <code class="sourceCode cpp"><span class="op">(</span>t <span class="op">&lt;=&gt;</span> u <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">==</span> <span class="dt">bool</span><span class="op">(</span>t <span class="op">&gt;=</span> u<span class="op">)</span></code></li>
</ul></li>
<li><span class="marginalizedparent"><a class="marginalized">(3.8)</a></span> If <code class="sourceCode cpp">Cat</code> is convertible to <code class="sourceCode cpp">strong_ordering</code>, <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp">U</code> model <code class="sourceCode cpp">StrictTotallyOrderedWith<span class="op">&lt;</span>T, U<span class="op">&gt;</span></code> ([concepts.stricttotallyordered]).</li>
</ul>

</div>
</blockquote>
<p>Add a new subclause [cmp.result] “spaceship invocation result”:</p>
<div class="add" style="color: #006e28">

<blockquote>
<p>The behavior of a program that adds specializations for the <code class="sourceCode cpp">compare_three_way_result</code> template defined in this subclause is undefined.</p>
</blockquote>
<blockquote>
<p>For the <code class="sourceCode cpp">compare_three_way_result</code> type trait applied to the types <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp">U</code>, let <code class="sourceCode cpp">t</code> and <code class="sourceCode cpp">u</code> denote lvalues of types <code class="sourceCode cpp"><span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>T<span class="op">&gt;</span></code> and <code class="sourceCode cpp"><span class="kw">const</span> remove_reference_t<span class="op">&lt;</span>U<span class="op">&gt;</span></code>, respectively. If the expression <code class="sourceCode cpp">t <span class="op">&lt;=&gt;</span> u</code> is well-formed when treated as an unevaluted operand ([expr.context]), the member <em>typedef-name</em> <code class="sourceCode cpp">type</code> denotes the type <code class="sourceCode cpp"><span class="kw">decltype</span><span class="op">(</span>t <span class="op">&lt;=&gt;</span> u<span class="op">)</span></code>. Otherwise, there is no member <code class="sourceCode cpp">type</code>.</p>
</blockquote>

</div>
<p>Add a new subclause [cmp.object] “spaceship object”:</p>
<div class="add" style="color: #006e28">

<blockquote>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> In this subclause, <code class="sourceCode cpp">BUILTIN_PTR_3WAY<span class="op">(</span>T, U<span class="op">)</span></code> for types <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp">U</code> is a boolean constant expression. <code class="sourceCode cpp">BUILTIN_PTR_3WAY<span class="op">(</span>T, U<span class="op">)</span></code> is <code class="sourceCode cpp"><span class="kw">true</span></code> if and only if <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> in the expression <code class="sourceCode cpp">declval<span class="op">&lt;</span>T<span class="op">&gt;()</span> <span class="op">&lt;=&gt;</span> declval<span class="op">&lt;</span>U<span class="op">&gt;()</span></code> resolves to a built-in operator comparing pointers.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb1-1"><a href="#cb1-1"></a>struct compare_three_way {</span>
<span id="cb1-2"><a href="#cb1-2"></a>  template&lt;class T, class U&gt;</span>
<span id="cb1-3"><a href="#cb1-3"></a>    requires ThreeWayComparableWith&lt;T,U&gt; || BUILTIN_PTR_3WAY(T, U)</span>
<span id="cb1-4"><a href="#cb1-4"></a>  constexpr auto operator()(T&amp;&amp; t, U&amp;&amp; u) const;</span>
<span id="cb1-5"><a href="#cb1-5"></a>  </span>
<span id="cb1-6"><a href="#cb1-6"></a>  using is_transparent = <em>unspecified</em>;</span>
<span id="cb1-7"><a href="#cb1-7"></a>};</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Expects</em>: If the expression <code class="sourceCode cpp">std<span class="op">::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>t<span class="op">)</span> <span class="op">&lt;=&gt;</span> std<span class="op">::</span>forward<span class="op">&lt;</span>U<span class="op">&gt;(</span>u<span class="op">)</span></code> results in a call to a built-in operator <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> comparing pointers of type <code class="sourceCode cpp">P</code>, the conversion sequences from both <code class="sourceCode cpp">T</code> and <code class="sourceCode cpp">U</code> to <code class="sourceCode cpp">P</code> are equality-preserving ([concepts.equality]).</p>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Effects</em>:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(3.1)</a></span> If the expression <code class="sourceCode cpp">std<span class="op">::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>t<span class="op">)</span> <span class="op">&lt;=&gt;</span> std<span class="op">::</span>forward<span class="op">&lt;</span>U<span class="op">&gt;(</span>u<span class="op">)</span></code> results in a call to a built-in operator <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> comparing pointers of type <code class="sourceCode cpp">P</code>: returns <code class="sourceCode cpp">strong_ordering<span class="op">::</span>less</code> if (the converted value of) <code class="sourceCode cpp">t</code> precedes <code class="sourceCode cpp">u</code> in the implementation-defined strict total order ([range.cmp]) over pointers of type <code class="sourceCode cpp">P</code>, <code class="sourceCode cpp">strong_ordering<span class="op">::</span>greater</code> if <code class="sourceCode cpp">u</code> precedes <code class="sourceCode cpp">t</code>, and otherwise <code class="sourceCode cpp">strong_ordering<span class="op">::</span>equal</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.2)</a></span> Otherwise, equivalent to: <code class="sourceCode cpp"><span class="cf">return</span> std<span class="op">::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>t<span class="op">)</span> <span class="op">&lt;=&gt;</span> std<span class="op">::</span>forward<span class="op">&lt;</span>U<span class="op">&gt;(</span>u<span class="op">)</span>;</code></li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> In addition to being available via inclusion of the <code class="sourceCode cpp"><span class="op">&lt;</span>compare<span class="op">&gt;</span></code> header, the class <code class="sourceCode cpp">compare_three_way</code> is available when the header <code class="sourceCode cpp"><span class="op">&lt;</span>functional<span class="op">&gt;</span></code> is included.</p>
</blockquote>

</div>
<p>Replace the entirety of 17.11.4 [cmp.alg]. This section had the original design for <code class="sourceCode cpp">strong_order<span class="op">()</span></code>, <code class="sourceCode cpp">weak_order<span class="op">()</span></code>, <code class="sourceCode cpp">partial_order<span class="op">()</span></code>, <code class="sourceCode cpp">strong_equal<span class="op">()</span></code>, and <code class="sourceCode cpp">weak_equal<span class="op">()</span></code>. The new wording makes them CPOs.</p>
<blockquote>
<div class="add" style="color: #006e28">
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> The name <code class="sourceCode cpp">strong_order</code> denotes a customization point object ([customization.point.object]). The expression <code class="sourceCode cpp">strong_order<span class="op">(</span>E, F<span class="op">)</span></code> for some subexpressions <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> is expression-equivalent ([defns.expression-equivalent]) to the following:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(1.1)</a></span> If the decayed types of <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> differ, <code class="sourceCode cpp">strong_order<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.2)</a></span> Otherwise, <code class="sourceCode cpp">strong_ordering<span class="op">(</span>strong_order<span class="op">(</span>E, F<span class="op">))</span></code> if it is a well-formed expression with overload resolution performed in a context that does not include a declaration of <code class="sourceCode cpp">std<span class="op">::</span>strong_order</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.3)</a></span> Otherwise, if the decayed type <code class="sourceCode cpp">T</code> of <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> is a floating point type, yields a value of type <code class="sourceCode cpp">strong_ordering</code> that is consistent with the ordering observed by <code class="sourceCode cpp">T</code>’s comparison operators, and if <code class="sourceCode cpp">numeric_limits<span class="op">&lt;</span>T<span class="op">&gt;::</span>is_iec559</code> is <code class="sourceCode cpp"><span class="kw">true</span></code> is additionally consistent with the totalOrder operation as specified in ISO/IEC/IEEE 60599.</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.4)</a></span> Otherwise, <code class="sourceCode cpp">strong_ordering<span class="op">(</span>E <span class="op">&lt;=&gt;</span> F<span class="op">)</span></code> if it is a well-formed expression.</li>
<li><span class="marginalizedparent"><a class="marginalized">(1.5)</a></span> Otherwise, <code class="sourceCode cpp">strong_order<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed. [<em>Note</em>: This case can result in substitution failure when <code class="sourceCode cpp">strong_order<span class="op">(</span>E, F<span class="op">)</span></code> appears in the immediate context of a template instantiation. —<em>end note</em>]</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> The name <code class="sourceCode cpp">weak_order</code> denotes a customization point object ([customization.point.object]). The expression <code class="sourceCode cpp">weak_order<span class="op">(</span>E, F<span class="op">)</span></code> for some subexpressions <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> is expression-equivalent ([defns.expression-equivalent]) to the following:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(2.1)</a></span> If the decayed types of <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> differ, <code class="sourceCode cpp">weak_order<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.2)</a></span> Otherwise, <code class="sourceCode cpp">weak_ordering<span class="op">(</span>weak_order<span class="op">(</span>E, F<span class="op">))</span></code> if it is a well-formed expression with overload resolution performed in a context that does not include a declaration of <code class="sourceCode cpp">std<span class="op">::</span>weak_order</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3)</a></span> Otherwise, if the decayed type <code class="sourceCode cpp">T</code> of <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> is a floating point type, yields a value of type <code class="sourceCode cpp">weak_ordering</code> that is consistent with the ordering observed by <code class="sourceCode cpp">T</code>’s comparison operators and <code class="sourceCode cpp">strong_order</code>, and if <code class="sourceCode cpp">numeric_liits<span class="op">&lt;</span>T<span class="op">&gt;::</span>is_iec559</code> is <code class="sourceCode cpp"><span class="kw">true</span></code> is additionally consistent with the following equivalence classes, ordered from lesser to greater:
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.1)</a></span> Together, all negative NaN values</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.2)</a></span> Negative infinity</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.3)</a></span> Each normal negative value</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.4)</a></span> Each subnormal negative value</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.5)</a></span> Together, both zero values</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.6)</a></span> Each subnormal positive value</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.7)</a></span> Each normal positive value</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.8)</a></span> Positive infinity</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.3.9)</a></span> Together, all positive NaN values</li>
</ul></li>
<li><span class="marginalizedparent"><a class="marginalized">(2.4)</a></span> Otherwise, <code class="sourceCode cpp">weak_ordering<span class="op">(</span>strong_order<span class="op">(</span>E, F<span class="op">))</span></code> if it is a well-formed expression.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.5)</a></span> Otherwise, <code class="sourceCode cpp">weak_ordering<span class="op">(</span>E <span class="op">&lt;=&gt;</span> F<span class="op">)</span></code> if it is a well-formed expression.</li>
<li><span class="marginalizedparent"><a class="marginalized">(2.6)</a></span> Otherwise, <code class="sourceCode cpp">weak_order<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed. [<em>Note</em>: This case can result in substitution failure when <code class="sourceCode cpp">std<span class="op">::</span>weak_order<span class="op">(</span>E, F<span class="op">)</span></code> appears in the immediate context of a template instantiation. —<em>end note</em>]</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> The name <code class="sourceCode cpp">partial_order</code> denotes a customization point object ([customization.point.object]). The expression <code class="sourceCode cpp">partial_order<span class="op">(</span>E, F<span class="op">)</span></code> for some subexpressions <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> is expression-equivalent ([defns.expression-equivalent]) to the following:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(3.1)</a></span> If the decayed types of <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> differ, <code class="sourceCode cpp">partial_order<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.2)</a></span> Otherwise, <code class="sourceCode cpp">partial_ordering<span class="op">(</span>partial_order<span class="op">(</span>E, F<span class="op">))</span></code> if it is a well-formed expression with overload resolution performed in a context that does not include a declaration of <code class="sourceCode cpp">std<span class="op">::</span>partial_order</code>.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.3)</a></span> Otherwise, <code class="sourceCode cpp">partial_ordering<span class="op">(</span>weak_order<span class="op">(</span>E, F<span class="op">))</span></code> if it is a well-formed expression.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.4)</a></span> Otherwise, <code class="sourceCode cpp">partial_ordering<span class="op">(</span>E <span class="op">&lt;=&gt;</span> F<span class="op">)</span></code> if it is a well-formed expression.</li>
<li><span class="marginalizedparent"><a class="marginalized">(3.5)</a></span> Otherwise, <code class="sourceCode cpp">partial_order<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed. [<em>Note</em>: This case can result in substitution failure when <code class="sourceCode cpp">std<span class="op">::</span>partial_order<span class="op">(</span>E, F<span class="op">)</span></code> appears in the immediate context of a template instantiation. —<em>end note</em>]</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> The name <code class="sourceCode cpp">compare_strong_order_fallback</code> denotes a comparison customization point ([customization.point.object]) object. The expression <code class="sourceCode cpp">compare_strong_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> for some subexpressions <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> is expression-equivalent ([defns.expression-equivalent]) to:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(4.1)</a></span> If the decayed types of <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> differ, <code class="sourceCode cpp">compare_strong_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized">(4.2)</a></span> Otherwise, <code class="sourceCode cpp">strong_order<span class="op">(</span>E, F<span class="op">)</span></code> if it is a well-formed expression.</li>
<li><span class="marginalizedparent"><a class="marginalized">(4.3)</a></span> Otherwise, if the expressions <code class="sourceCode cpp">E <span class="op">==</span> F</code> and <code class="sourceCode cpp">E <span class="op">&lt;</span> F</code> are each well-formed and convertible to bool, <code class="sourceCode cpp"><span class="op">(</span>E <span class="op">==</span> F<span class="op">)</span> <span class="op">?</span> strong_ordering<span class="op">::</span>equal <span class="op">:</span> <span class="op">((</span>E <span class="op">&lt;</span> F<span class="op">)</span> <span class="op">?</span> strong_ordering<span class="op">::</span>less <span class="op">:</span> strong_ordering<span class="op">::</span>greater</code> except that <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> are only evaluated once.</li>
<li><span class="marginalizedparent"><a class="marginalized">(4.4)</a></span> Otherwise, <code class="sourceCode cpp">compare_strong_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> The name <code class="sourceCode cpp">compare_weak_order_fallback</code> denotes a customization point object ([customization.point.object]). The expression <code class="sourceCode cpp">compare_weak_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> for some subexpressions <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> is expression-equivalent ([defns.expression-equivalent]) to:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(5.1)</a></span> If the decayed types of <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> differ, <code class="sourceCode cpp">compare_weak_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized">(5.2)</a></span> Otherwise, <code class="sourceCode cpp">weak_order<span class="op">(</span>E, F<span class="op">)</span></code> if it is a well-formed expression.</li>
<li><span class="marginalizedparent"><a class="marginalized">(5.3)</a></span> Otherwise, if the expressions <code class="sourceCode cpp">E <span class="op">==</span> F</code> and <code class="sourceCode cpp">E <span class="op">&lt;</span> F</code> are each well-formed and convertible to bool, <code class="sourceCode cpp"><span class="op">(</span>E <span class="op">==</span> F<span class="op">)</span> <span class="op">?</span> weak_ordering<span class="op">::</span>equal <span class="op">:</span> <span class="op">((</span>E <span class="op">&lt;</span> F<span class="op">)</span> <span class="op">?</span> weak_ordering<span class="op">::</span>less <span class="op">:</span> weak_ordering<span class="op">::</span>greater</code> except that <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> are only evaluated once.</li>
<li><span class="marginalizedparent"><a class="marginalized">(5.4)</a></span> Otherwise, <code class="sourceCode cpp">compare_weak_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
</ul>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> The name <code class="sourceCode cpp">compare_partial_order_fallback</code> denotes a customization point object ([customization.point.object]). The expression <code class="sourceCode cpp">compare_partial_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> for some subexpressions <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> is expression-equivalent ([defns.expression-equivalent]) to:</p>
<ul>
<li><span class="marginalizedparent"><a class="marginalized">(6.1)</a></span> If the decayed types of <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> differ, <code class="sourceCode cpp">compare_partial_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
<li><span class="marginalizedparent"><a class="marginalized">(6.2)</a></span> Otherwise, <code class="sourceCode cpp">partial_order<span class="op">(</span>E, F<span class="op">)</span></code> if it is a well-formed expression.</li>
<li><span class="marginalizedparent"><a class="marginalized">(6.3)</a></span> Otherwise, if the expressions <code class="sourceCode cpp">E <span class="op">==</span> F</code> and <code class="sourceCode cpp">E <span class="op">&lt;</span> F</code> are each well-formed and convertible to bool, <code class="sourceCode cpp"><span class="op">(</span>E <span class="op">==</span> F<span class="op">)</span> <span class="op">?</span> partial_ordering<span class="op">::</span>equivalent <span class="op">:</span> <span class="op">((</span>E <span class="op">&lt;</span> F<span class="op">)</span> <span class="op">?</span> partial_ordering<span class="op">::</span>less <span class="op">:</span> <span class="op">((</span>F <span class="op">&lt;</span> E<span class="op">)</span> <span class="op">?</span> weak_ordering<span class="op">::</span>greater <span class="op">:</span> weak_ordering<span class="op">::</span>unordered<span class="op">))</span></code> except that <code class="sourceCode cpp">E</code> and <code class="sourceCode cpp">F</code> are only evaluated once.</li>
<li><span class="marginalizedparent"><a class="marginalized">(6.4)</a></span> Otherwise, <code class="sourceCode cpp">compare_partial_order_fallback<span class="op">(</span>E, F<span class="op">)</span></code> is ill-formed.</li>
</ul>

</div>
</blockquote>
<p>Change 17.13.1 [coroutine.syn]:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb7"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb7-1"><a href="#cb7-1"></a>namespace std {</span>
<span id="cb7-2"><a href="#cb7-2"></a>  [...]</span>
<span id="cb7-3"><a href="#cb7-3"></a>  // 17.13.5 noop coroutine</span>
<span id="cb7-4"><a href="#cb7-4"></a>  noop_coroutine_handle noop_coroutine() noexcept;</span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a>  // 17.13.3.6 comparison operators:</span>
<span id="cb7-7"><a href="#cb7-7"></a>  constexpr bool operator==(coroutine_handle&lt;&gt; x, coroutine_handle&lt;&gt; y) noexcept;</span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="st">- constexpr bool operator!=(coroutine_handle&lt;&gt; x, coroutine_handle&lt;&gt; y) noexcept;</span></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="st">- constexpr bool operator&lt;(coroutine_handle&lt;&gt; x, coroutine_handle&lt;&gt; y) noexcept;</span></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="st">- constexpr bool operator&gt;(coroutine_handle&lt;&gt; x, coroutine_handle&lt;&gt; y) noexcept;</span></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="st">- constexpr bool operator&lt;=(coroutine_handle&lt;&gt; x, coroutine_handle&lt;&gt; y) noexcept;</span></span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="st">- constexpr bool operator&gt;=(coroutine_handle&lt;&gt; x, coroutine_handle&lt;&gt; y) noexcept;</span></span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="va">+ constexpr strong_ordering operator&lt;=&gt;(coroutine_handle x, coroutine_handle y) noexcept;</span></span>
<span id="cb7-14"><a href="#cb7-14"></a></span>
<span id="cb7-15"><a href="#cb7-15"></a>  // 17.13.6 trivial awaitables</span>
<span id="cb7-16"><a href="#cb7-16"></a>  [...]</span>
<span id="cb7-17"><a href="#cb7-17"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>Replace the <code class="sourceCode cpp"><span class="op">&lt;</span></code> in 17.13.3.6 [coroutine.handle.compare] with the new <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code>:</p>
<blockquote>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span>coroutine_handle<span class="op">&lt;&gt;</span> x, coroutine_handle<span class="op">&lt;&gt;</span> y<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Returns</em>: <code class="sourceCode cpp">x<span class="op">.</span>address<span class="op">()</span> <span class="op">==</span> y<span class="op">.</span>address<span class="op">()</span></code>.</p>
<div class="rm" style="color: #bf0303">

<div class="sourceCode" id="cb9"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb9-1"><a href="#cb9-1"></a>constexpr bool operator&lt;(coroutine_handle&lt;&gt; x, coroutine_handle&lt;&gt; y) noexcept;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp">less<span class="op">&lt;&gt;()(</span>x<span class="op">.</span>address<span class="op">()</span>, y<span class="op">.</span>address<span class="op">())</span></code>.</p>
</div>
<div class="addu">
<div class="sourceCode" id="cb10"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb10-1"><a href="#cb10-1"></a>constexpr strong_ordering operator&lt;=&gt;(coroutine_handle x, coroutine_handle y) noexcept;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: <code class="sourceCode cpp">compare_three_way<span class="op">()(</span>x<span class="op">.</span>address<span class="op">()</span>, y<span class="op">.</span>address<span class="op">())</span></code>.</p>
</div>
</blockquote>
<h2 id="clause-18-concepts-library"><span class="header-section-number">5.3</span> Clause 18: Concepts Library<a href="#clause-18-concepts-library" class="self-link"></a></h2>
<p>No changes.</p>
<h2 id="clause-19-diagnostics-library"><span class="header-section-number">5.4</span> Clause 19: Diagnostics Library<a href="#clause-19-diagnostics-library" class="self-link"></a></h2>
<p>Changed operators for: <code class="sourceCode cpp">error_category</code>, <code class="sourceCode cpp">error_code</code>, and <code class="sourceCode cpp">error_condition</code></p>
<p>Change 19.5.1 [system.error.syn]:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb11"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb11-1"><a href="#cb11-1"></a>namespace std {</span>
<span id="cb11-2"><a href="#cb11-2"></a>  [...]</span>
<span id="cb11-3"><a href="#cb11-3"></a>  // [syserr.compare], comparison functions</span>
<span id="cb11-4"><a href="#cb11-4"></a>  bool operator==(const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</span>
<span id="cb11-5"><a href="#cb11-5"></a>  bool operator==(const error_code&amp; lhs, const error_condition&amp; rhs) noexcept;</span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="st">- bool operator==(const error_condition&amp; lhs, const error_code&amp; rhs) noexcept;</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>  bool operator==(const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="st">- bool operator!=(const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</span></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="st">- bool operator!=(const error_code&amp; lhs, const error_condition&amp; rhs) noexcept;</span></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="st">- bool operator!=(const error_condition&amp; lhs, const error_code&amp; rhs) noexcept;</span></span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="st">- bool operator!=(const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</span></span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="st">- bool operator&lt; (const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</span></span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="st">- bool operator&lt; (const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</span></span>
<span id="cb11-14"><a href="#cb11-14"></a><span class="va">+ strong_ordering operator&lt;=&gt;(const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</span></span>
<span id="cb11-15"><a href="#cb11-15"></a><span class="va">+ strong_ordering operator&lt;=&gt;(const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</span></span>
<span id="cb11-16"><a href="#cb11-16"></a>  [...]  </span>
<span id="cb11-17"><a href="#cb11-17"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>Change 19.5.2.1 [syserr.errcat.overview]:</p>
<blockquote>
<div>
<div class="sourceCode" id="cb12"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb12-1"><a href="#cb12-1"></a>namespace std {</span>
<span id="cb12-2"><a href="#cb12-2"></a>  class error_category {</span>
<span id="cb12-3"><a href="#cb12-3"></a>  public:</span>
<span id="cb12-4"><a href="#cb12-4"></a>    [...]</span>
<span id="cb12-5"><a href="#cb12-5"></a></span>
<span id="cb12-6"><a href="#cb12-6"></a>    bool operator==(const error_category&amp; rhs) const noexcept;</span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="st">-   bool operator!=(const error_category&amp; rhs) const noexcept;</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="st">-   bool operator&lt; (const error_category&amp; rhs) const noexcept;</span></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="va">+   strong_ordering operator&lt;=&gt;(const error_category&amp; rhs) const noexcept;</span></span>
<span id="cb12-10"><a href="#cb12-10"></a>  };</span>
<span id="cb12-11"><a href="#cb12-11"></a></span>
<span id="cb12-12"><a href="#cb12-12"></a>  const error_category&amp; generic_category() noexcept;</span>
<span id="cb12-13"><a href="#cb12-13"></a>  const error_category&amp; system_category() noexcept;</span>
<span id="cb12-14"><a href="#cb12-14"></a>}</span></code></pre></div>
</div>
</blockquote>
<p>Change 19.5.2.3 [syserr.errcat.nonvirtuals]:</p>
<blockquote>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> error_category<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">const</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="kw">this</span> <span class="op">==</span> <span class="op">&amp;</span>rhs</code>.</p>
<div class="rm" style="color: #bf0303">

<div class="sourceCode" id="cb14"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb14-1"><a href="#cb14-1"></a>bool operator!=(const error_category&amp; rhs) const noexcept;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(*</span><span class="kw">this</span> <span class="op">==</span> rhs<span class="op">)</span></code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb15-1"><a href="#cb15-1"></a>bool operator&lt;(const error_category&amp; rhs) const noexcept;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: <code class="sourceCode cpp">less<span class="op">&lt;</span><span class="kw">const</span> error_category<span class="op">*&gt;()(</span><span class="kw">this</span>, <span class="op">&amp;</span>rhs<span class="op">)</span></code>.</p>
</div>
<div class="addu">
<div class="sourceCode" id="cb16"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb16-1"><a href="#cb16-1"></a>strong_ordering operator&lt;=&gt;(const error_category&amp; rhs) const noexcept;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: <code class="sourceCode cpp">compare_three_way<span class="op">()(</span><span class="kw">this</span>, <span class="op">&amp;</span>rhs<span class="op">)</span></code>.</p>
</div>
<p>[<em>Note</em>: <span class="rm" style="color: #bf0303"><del><span><code class="sourceCode cpp">less</code></span></del></span> <span class="add" style="color: #006e28"><ins><span><code class="sourceCode cpp">compare_three_way</code></span> ([cmp.object])</ins></span> provides a total ordering for pointers. —<em>end note</em>]</p>
</blockquote>
<p>Change 19.5.5 [syserr.compare]:</p>
<blockquote>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> error_code<span class="op">&amp;</span> lhs, <span class="kw">const</span> error_code<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">1</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>category<span class="op">()</span> <span class="op">==</span> rhs<span class="op">.</span>category<span class="op">()</span> <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>value<span class="op">()</span> <span class="op">==</span> rhs<span class="op">.</span>value<span class="op">()</span></code></p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> error_code<span class="op">&amp;</span> lhs, <span class="kw">const</span> error_condition<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">2</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>category<span class="op">().</span>equivalent<span class="op">(</span>lhs<span class="op">.</span>value<span class="op">()</span>, rhs<span class="op">)</span> <span class="op">||</span> rhs<span class="op">.</span>category<span class="op">().</span>equivalent<span class="op">(</span>lhs, rhs<span class="op">.</span>value<span class="op">())</span></code></p>
<div class="rm" style="color: #bf0303">

<div class="sourceCode" id="cb19"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb19-1"><a href="#cb19-1"></a>bool operator==(const error_condition&amp; lhs, const error_code&amp; rhs) noexcept;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">3</a></span> <em>Returns</em>: <code class="sourceCode cpp">rhs<span class="op">.</span>category<span class="op">().</span>equivalent<span class="op">(</span>rhs<span class="op">.</span>value<span class="op">()</span>, lhs<span class="op">)</span> <span class="op">||</span> lhs<span class="op">.</span>category<span class="op">().</span>equivalent<span class="op">(</span>rhs, lhs<span class="op">.</span>value<span class="op">())</span></code></p>
</div>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="kw">const</span> error_condition<span class="op">&amp;</span> lhs, <span class="kw">const</span> error_condition<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span>;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">4</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>category<span class="op">()</span> <span class="op">==</span> rhs<span class="op">.</span>category<span class="op">()</span> <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>value<span class="op">()</span> <span class="op">==</span> rhs<span class="op">.</span>value<span class="op">()</span></code></p>
<div class="rm" style="color: #bf0303">

<div class="sourceCode" id="cb21"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb21-1"><a href="#cb21-1"></a>bool operator!=(const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</span>
<span id="cb21-2"><a href="#cb21-2"></a>bool operator!=(const error_code&amp; lhs, const error_condition&amp; rhs) noexcept;</span>
<span id="cb21-3"><a href="#cb21-3"></a>bool operator!=(const error_condition&amp; lhs, const error_code&amp; rhs) noexcept;</span>
<span id="cb21-4"><a href="#cb21-4"></a>bool operator!=(const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">5</a></span> <em>Returns</em>: <code class="sourceCode cpp"><span class="op">!(</span>lhs <span class="op">==</span> rhs<span class="op">)</span></code>.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb22-1"><a href="#cb22-1"></a>bool operator&lt;(const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">6</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>category<span class="op">()</span> <span class="op">&lt;</span> rhs<span class="op">.</span>category<span class="op">()</span> <span class="op">||</span> <span class="op">(</span>lhs<span class="op">.</span>category<span class="op">()</span> <span class="op">==</span> rhs<span class="op">.</span>category<span class="op">()</span> <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>value<span class="op">()</span> <span class="op">&lt;</span> rhs<span class="op">.</span>value<span class="op">())</span></code></p>
<div class="sourceCode" id="cb23"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb23-1"><a href="#cb23-1"></a>bool operator&lt;(const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">7</a></span> <em>Returns</em>: <code class="sourceCode cpp">lhs<span class="op">.</span>category<span class="op">()</span> <span class="op">&lt;</span> rhs<span class="op">.</span>category<span class="op">()</span> <span class="op">||</span> <span class="op">(</span>lhs<span class="op">.</span>category<span class="op">()</span> <span class="op">==</span> rhs<span class="op">.</span>category<span class="op">()</span> <span class="op">&amp;&amp;</span> lhs<span class="op">.</span>value<span class="op">()</span> <span class="op">&lt;</span> rhs<span class="op">.</span>value<span class="op">())</span></code></p>
</div>
<div class="addu">
<div class="sourceCode" id="cb24"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb24-1"><a href="#cb24-1"></a>strong_ordering operator&lt;=&gt;(const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">8</a></span> <em>Effects</em>: Equivalent to:</p>
<blockquote>
<div class="sourceCode" id="cb25"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb25-1"><a href="#cb25-1"></a>if (auto c = lhs.category() &lt;=&gt; rhs.category(); c != 0) return c;</span>
<span id="cb25-2"><a href="#cb25-2"></a>return lhs.value() &lt;=&gt; rhs.value();</span></code></pre></div>
</blockquote>
<div class="sourceCode" id="cb26"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb26-1"><a href="#cb26-1"></a>strong_ordering operator&lt;=&gt;(const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</span></code></pre></div>
<p><span class="marginalizedparent"><a class="marginalized">9</a></span> <em>Effects</em>: Equivalent to:</p>
<blockquote>
<div class="sourceCode" id="cb27"><pre class="sourceCode default"><code class="sourceCode default"><span id="cb27-1"><a href="#cb27-1"></a>if (auto c = lhs.category() &lt;=&gt; rhs.category(); c != 0) return c;</span>
<span id="cb27-2"><a href="#cb27-2"></a>return lhs.value() &lt;=&gt; rhs.value();</span></code></pre></div>
</blockquote>
</div>
</blockquote>
<h2 id="clause-20-general-utilities-library"><span class="header-section-number">5.5</span> Clause 20: General utilities library<a href="#clause-20-general-utilities-library" class="self-link"></a></h2>
<p>TBD.</p>
<h1 id="references" style="border-bottom:1px solid #cccccc"><span class="header-section-number">6</span> References<a href="#references" class="self-link"></a></h1>

<div id="refs" role="doc-bibliography">
<div id="ref-D1186R2">
<p>[D1186R2] Barry Revzin. 2019. When do you actually use <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code>? <br />
<a href="https://brevzin.github.io/cpp_proposals/118x_spaceship/d1186r2.html">https://brevzin.github.io/cpp_proposals/118x_spaceship/d1186r2.html</a></p>
</div>
<div id="ref-P0732R2">
<p>[P0732R2] Jeff Snyder, Louis Dionne. 2018. Class Types in Non-Type Template Parameters. <br />
<a href="https://wg21.link/p0732r2">https://wg21.link/p0732r2</a></p>
</div>
<div id="ref-P0790R2">
<p>[P0790R2] David Stone. 2019. Effect of operator&lt;=&gt; on the C++ Standard Library. <br />
<a href="https://wg21.link/p0790r2">https://wg21.link/p0790r2</a></p>
</div>
<div id="ref-P0891R2">
<p>[P0891R2] Gašper Ažman, Jeff Snyder. 2019. Make <code class="sourceCode cpp">strong_order</code> a Customization Point! <br />
<a href="https://wg21.link/p0891r2">https://wg21.link/p0891r2</a></p>
</div>
<div id="ref-P1154R1">
<p>[P1154R1] Arthur O’Dwyer, Jeff Snyder. 2019. Type traits for structural comparison. <br />
<a href="https://wg21.link/p1154r1">https://wg21.link/p1154r1</a></p>
</div>
<div id="ref-P1185R2">
<p>[P1185R2] Barry Revzin. 2019. <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span> <span class="op">!=</span> <span class="op">==</span></code>. <br />
<a href="https://wg21.link/p1185r2">https://wg21.link/p1185r2</a></p>
</div>
<div id="ref-P1186R1">
<p>[P1186R1] Barry Revzin. 2019. When do you actually use <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code>? <br />
<a href="https://wg21.link/p1186r1">https://wg21.link/p1186r1</a></p>
</div>
<div id="ref-P1188R0">
<p>[P1188R0] Barry Revzin. 2019. Library utilities for <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code>. <br />
<a href="https://wg21.link/p1188r0">https://wg21.link/p1188r0</a></p>
</div>
<div id="ref-P1189R0">
<p>[P1189R0] Barry Revzin. 2019. Adding <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> to library. <br />
<a href="https://wg21.link/p1189r0">https://wg21.link/p1189r0</a></p>
</div>
<div id="ref-P1191R0">
<p>[P1191R0] David Stone. 2018. Adding <code class="sourceCode cpp"><span class="kw">operator</span><span class="op">&lt;=&gt;</span></code> to types that are not currently comparable. <br />
<a href="https://wg21.link/p1191r0">https://wg21.link/p1191r0</a></p>
</div>
<div id="ref-P1201R0">
<p>[P1201R0] Oleg Fatkhiev, Antony Polukhin. 2018. Variant direct comparisons. <br />
<a href="https://wg21.link/p1201r0">https://wg21.link/p1201r0</a></p>
</div>
<div id="ref-P1295R0">
<p>[P1295R0] Tomasz Kamiński. 2018. Spaceship library update. <br />
<a href="https://wg21.link/p1295r0">https://wg21.link/p1295r0</a></p>
</div>
<div id="ref-P1380R1">
<p>[P1380R1] Lawrence Crowl. 2019. Ambiguity and Insecurities with Three-Way Comparison. <br />
<a href="https://wg21.link/p1380r1">https://wg21.link/p1380r1</a></p>
</div>
<div id="ref-P1614R0">
<p>[P1614R0] Barry Revzin. 2019. The Mothership Has Landed: Adding <code class="sourceCode cpp"><span class="op">&lt;=&gt;</span></code> to the Library. <br />
<a href="https://wg21.link/p1614r0">https://wg21.link/p1614r0</a></p>
</div>
</div>
</div>
</div>
</body>
</html>
