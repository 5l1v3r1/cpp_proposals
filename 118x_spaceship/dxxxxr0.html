<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>The Mothership Has Landed - Adding <=> to library</title>
<style type="text/css">html {
	position: relative;
	max-width: 1024px;
	height: 100%;
}
body {
	font-family: Helvetica, arial, sans-serif;
	font-size: 14px;
	line-height: 1.6;
	padding-top: 10px;
	padding-bottom: 10px;
	background-color: white;
	padding: 30px;
}
body>*:first-child {
	margin-top: 0 !important;
}
body>*:last-child {
	margin-bottom: 0 !important;
}
a {
	color: #4183C4;
}
a.absent {
	color: #cc0000;
}
a.anchor {
	display: block;
	padding-left: 30px;
	margin-left: -30px;
	cursor: pointer;
	position: absolute;
	top: 0;
	left: 0;
	bottom: 0;
}
h1, h2, h3, h4, h5, h6 {
	margin: 20px 0 10px;
	padding: 0;
	font-weight: bold;
	-webkit-font-smoothing: antialiased;
	cursor: text;
	position: relative;
}
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
	background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
	text-decoration: none;
}
h1 tt, h1 code {
	font-size: inherit;
}
h2 tt, h2 code {
	font-size: inherit;
}
h3 tt, h3 code {
	font-size: inherit;
}
h4 tt, h4 code {
	font-size: inherit;
}
h5 tt, h5 code {
	font-size: inherit;
}
h6 tt, h6 code {
	font-size: inherit;
}
h1 {
	font-size: 28px;
	color: black;
}
h2 {
	font-size: 24px;
	border-bottom: 1px solid #cccccc;
	color: black;
}
h3 {
	font-size: 18px;
}
h4 {
	font-size: 16px;
}
h5 {
	font-size: 14px;
}
h6 {
	color: #777777;
	font-size: 14px;
}
p, blockquote, ol, dl, li, table, pre {
	margin: 15px 0;
}
hr {
	background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
	border: 0 none;
	color: #cccccc;
	height: 4px;
	padding: 0;
}
body>h2:first-child {
	margin-top: 0;
	padding-top: 0;
}
body>h1:first-child {
	margin-top: 0;
	padding-top: 0;
}
body>h1:first-child+h2 {
	margin-top: 0;
	padding-top: 0;
}
body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
	margin-top: 0;
	padding-top: 0;
}
a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
	margin-top: 0;
	padding-top: 0;
}
h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
	margin-top: 0;
}
li p.first {
	display: inline-block;
}
li {
	margin: 0;
}
ol {
	padding-left: 30px;
    margin: 5px;
    counter-reset: item;
    margin-left: -1px;
    margin-bottom: -1px;
    margin-top: -1px;
}
ol > li {
    counter-increment: item;
    margin-bottom: -1px;
    margin-top: -1px;    
}
ol ol > li {
    display: block;
    margin-bottom: -1px;
    margin-top: -1px;    
}
ol ol > li:before {
    content: counters(item, ".") ". ";
    margin-left: -30px;
    margin-bottom: -1px;
    margin-top: -1px;    
}
ul :first-child, ol :first-child {
	margin-top: 0;
}
ul ul { 
    margin-left: -15px;
}
dl {
	padding: 0;
}
dl dt {
	font-size: 14px;
	font-weight: bold;
	font-style: italic;
	padding: 0;
	margin: 15px 0 5px;
}
dl dt:first-child {
	padding: 0;
}
dl dt> :first-child {
	margin-top: 0;
}
dl dt> :last-child {
	margin-bottom: 0;
}
dl dd {
	margin: 0 0 15px;
	padding: 0 15px;
}
dl dd> :first-child {
	margin-top: 0;
}
dl dd> :last-child {
	margin-bottom: 0;
}
blockquote {
	border-left: 4px solid #dddddd;
	padding: 0 15px;
	color: #777777;
}
blockquote.ins {
	border-left: 4px solid #00a000;
	padding: 0 15px;
	color: #00a000;
}
blockquote> :first-child {
	margin-top: 0;
}
blockquote> :last-child {
	margin-bottom: 0;
}
table {
	padding: 0;
	border-collapse: collapse;
}
table tr {
	border-top: 1px solid #cccccc;
	background-color: white;
	margin: 0;
	padding: 0;
}
table tr:nth-child(2n) {
	background-color: #f8f8f8;
}
table tr th {
	font-weight: bold;
	border: 1px solid #cccccc;
	margin: 0;
	padding: 6px 13px;
}
table tr td {
	border: 1px solid #cccccc;
	margin: 0;
	padding: 6px 13px;
}
table tr th :first-child, table tr td :first-child {
	margin-top: 0;
}
table tr th :last-child, table tr td :last-child {
	margin-bottom: 0;
}
td {
	vertical-align: top;
}
img {
	max-width: 100%;
}
span.frame {
	display: block;
	overflow: hidden;
}
span.frame>span {
	border: 1px solid #dddddd;
	display: block;
	float: left;
	overflow: hidden;
	margin: 13px 0 0;
	padding: 7px;
	width: auto;
}
span.frame span img {
	display: block;
	float: left;
}
span.frame span span {
	clear: both;
	color: #333333;
	display: block;
	padding: 5px 0 0;
}
span.align-center {
	display: block;
	overflow: hidden;
	clear: both;
}
span.align-center>span {
	display: block;
	overflow: hidden;
	margin: 13px auto 0;
	text-align: center;
}
span.align-center span img {
	margin: 0 auto;
	text-align: center;
}
span.align-right {
	display: block;
	overflow: hidden;
	clear: both;
}
span.align-right>span {
	display: block;
	overflow: hidden;
	margin: 13px 0 0;
	text-align: right;
}
span.align-right span img {
	margin: 0;
	text-align: right;
}
span.float-left {
	display: block;
	margin-right: 13px;
	overflow: hidden;
	float: left;
}
span.float-left span {
	margin: 13px 0 0;
}
span.float-right {
	display: block;
	margin-left: 13px;
	overflow: hidden;
	float: right;
}
span.float-right>span {
	display: block;
	overflow: hidden;
	margin: 13px auto 0;
	text-align: right;
}
code, tt {
	margin: 0 2px;
	padding: 0 5px;
	white-space: nowrap;
	border: 1px solid #eaeaea;
	background-color: #f8f8f8;
	border-radius: 3px;
}
pre code {
	margin: 0;
	padding: 0;
	white-space: pre;
	border: none;
	background: transparent;
}
.highlight pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	font-size: 13px;
	line-height: 19px;
	overflow: auto;
	padding: 6px 10px;
	border-radius: 3px;
}
pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	font-size: 13px;
	line-height: 19px;
	overflow: auto;
    overflow-x: hidden;
    overflow-y: hidden;
    padding: 6px 10px;
	border-radius: 3px;
}
pre code, pre tt {
	background-color: transparent;
	border: none;
}
sup {
	font-size: 0.83em;
	vertical-align: super;
	line-height: 0;
}
kbd {
	display: inline-block;
	padding: 3px 5px;
	font-size: 11px;
	line-height: 10px;
	color: #555;
	vertical-align: middle;
	background-color: #fcfcfc;
	border: solid 1px #ccc;
	border-bottom-color: #bbb;
	border-radius: 3px;
	box-shadow: inset 0 -1px 0 #bbb
}
* {
	-webkit-print-color-adjust: exact;
}
ins {
	color: #00A000
}
del {
	color: #A00000
}
a.self-link {
    position: absolute;
    top: 0;
    left: calc(-1 * (3.5rem - 26px));
    width: calc(3.5rem - 26px);
    height: 2em;
    text-align: center;
    border: none;
    transition: opacity .2s;
    opacity: .5;
    font-size: 83%;
}
a.self-link:hover {
    opacity: 1;
}
a.self-link::before {
    content: "ยง";
}
</style>
<style type="text/css">/* PrismJS 1.15.0
https://prismjs.com/download.html#themes=prism&languages=markup+css+clike+c+cpp&plugins=line-highlight */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f8f8f8;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #9a6e3a;
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function,
.token.class-name {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}

pre[data-line] {
	position: relative;
	padding: 1em 0 1em 3em;
}

.line-highlight {
	position: absolute;
	left: 0;
	right: 0;
	padding: inherit 0;
	margin-top: 1em; /* Same as .prismโs padding-top */

	background: hsla(24, 20%, 50%,.08);
	background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));

	pointer-events: none;

	line-height: inherit;
	white-space: pre;
}

	.line-highlight:before,
	.line-highlight[data-end]:after {
		content: attr(data-start);
		position: absolute;
		top: .4em;
		left: .6em;
		min-width: 1em;
		padding: 0 .5em;
		background-color: hsla(24, 20%, 50%,.4);
		color: hsl(24, 20%, 95%);
		font: bold 65%/1.5 sans-serif;
		text-align: center;
		vertical-align: .3em;
		border-radius: 999px;
		text-shadow: none;
		box-shadow: 0 1px white;
	}

	.line-highlight[data-end]:after {
		content: attr(data-end);
		top: auto;
		bottom: .4em;
	}

.line-numbers .line-highlight:before,
.line-numbers .line-highlight:after {
	content: none;
}

</style>
<script type="text/javascript">/* PrismJS 1.15.0
https://prismjs.com/download.html#themes=prism&languages=markup+css+clike+c+cpp+nasm+rust&plugins=line-highlight */
var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-([\w-]+)\b/i,t=0,n=_self.Prism={manual:_self.Prism&&_self.Prism.manual,disableWorkerMessageHandler:_self.Prism&&_self.Prism.disableWorkerMessageHandler,util:{encode:function(e){return e instanceof r?new r(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e,t){var r=n.util.type(e);switch(t=t||{},r){case"Object":if(t[n.util.objId(e)])return t[n.util.objId(e)];var a={};t[n.util.objId(e)]=a;for(var l in e)e.hasOwnProperty(l)&&(a[l]=n.util.clone(e[l],t));return a;case"Array":if(t[n.util.objId(e)])return t[n.util.objId(e)];var a=[];return t[n.util.objId(e)]=a,e.forEach(function(e,r){a[r]=n.util.clone(e,t)}),a}return e}},languages:{extend:function(e,t){var r=n.util.clone(n.languages[e]);for(var a in t)r[a]=t[a];return r},insertBefore:function(e,t,r,a){a=a||n.languages;var l=a[e];if(2==arguments.length){r=arguments[1];for(var i in r)r.hasOwnProperty(i)&&(l[i]=r[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in r)r.hasOwnProperty(i)&&(o[i]=r[i]);o[s]=l[s]}var u=a[e];return a[e]=o,n.languages.DFS(n.languages,function(t,n){n===u&&t!=e&&(this[t]=o)}),o},DFS:function(e,t,r,a){a=a||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],r||l),"Object"!==n.util.type(e[l])||a[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||a[n.util.objId(e[l])]||(a[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,a)):(a[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,a)))}},plugins:{},highlightAll:function(e,t){n.highlightAllUnder(document,e,t)},highlightAllUnder:function(e,t,r){var a={callback:r,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var l,i=a.elements||e.querySelectorAll(a.selector),o=0;l=i[o++];)n.highlightElement(l,t===!0,a.callback)},highlightElement:function(t,r,a){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1].toLowerCase(),i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,t.parentNode&&(o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l));var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(n.hooks.run("before-sanity-check",u),!u.code||!u.grammar)return u.code&&(n.hooks.run("before-highlight",u),u.element.textContent=u.code,n.hooks.run("after-highlight",u)),n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),r&&_self.Worker){var g=new Worker(n.filename);g.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,a&&a.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},g.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,a&&a.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,a){var l={code:e,grammar:t,language:a};return n.hooks.run("before-tokenize",l),l.tokens=n.tokenize(l.code,l.grammar),n.hooks.run("after-tokenize",l),r.stringify(n.util.encode(l.tokens),l.language)},matchGrammar:function(e,t,r,a,l,i,o){var s=n.Token;for(var u in r)if(r.hasOwnProperty(u)&&r[u]){if(u==o)return;var g=r[u];g="Array"===n.util.type(g)?g:[g];for(var c=0;c<g.length;++c){var h=g[c],f=h.inside,d=!!h.lookbehind,m=!!h.greedy,p=0,y=h.alias;if(m&&!h.pattern.global){var v=h.pattern.toString().match(/[imuy]*$/)[0];h.pattern=RegExp(h.pattern.source,v+"g")}h=h.pattern||h;for(var b=a,k=l;b<t.length;k+=t[b].length,++b){var w=t[b];if(t.length>e.length)return;if(!(w instanceof s)){if(m&&b!=t.length-1){h.lastIndex=k;var _=h.exec(e);if(!_)break;for(var j=_.index+(d?_[1].length:0),P=_.index+_[0].length,A=b,x=k,O=t.length;O>A&&(P>x||!t[A].type&&!t[A-1].greedy);++A)x+=t[A].length,j>=x&&(++b,k=x);if(t[b]instanceof s)continue;I=A-b,w=e.slice(k,x),_.index-=k}else{h.lastIndex=0;var _=h.exec(w),I=1}if(_){d&&(p=_[1]?_[1].length:0);var j=_.index+p,_=_[0].slice(p),P=j+_.length,N=w.slice(0,j),S=w.slice(P),C=[b,I];N&&(++b,k+=N.length,C.push(N));var E=new s(u,f?n.tokenize(_,f):_,y,_,m);if(C.push(E),S&&C.push(S),Array.prototype.splice.apply(t,C),1!=I&&n.matchGrammar(e,t,r,b,k,!0,u),i)break}else if(i)break}}}}},tokenize:function(e,t){var r=[e],a=t.rest;if(a){for(var l in a)t[l]=a[l];delete t.rest}return n.matchGrammar(e,r,t,0,0,!1),r},hooks:{all:{},add:function(e,t){var r=n.hooks.all;r[e]=r[e]||[],r[e].push(t)},run:function(e,t){var r=n.hooks.all[e];if(r&&r.length)for(var a,l=0;a=r[l++];)a(t)}}},r=n.Token=function(e,t,n,r,a){this.type=e,this.content=t,this.alias=n,this.length=0|(r||"").length,this.greedy=!!a};if(r.stringify=function(e,t,a){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return r.stringify(n,t,e)}).join("");var l={type:e.type,content:r.stringify(e.content,t,a),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:a};if(e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o=Object.keys(l.attributes).map(function(e){return e+'="'+(l.attributes[e]||"").replace(/"/g,"&quot;")+'"'}).join(" ");return"<"+l.tag+' class="'+l.classes.join(" ")+'"'+(o?" "+o:"")+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(n.disableWorkerMessageHandler||_self.addEventListener("message",function(e){var t=JSON.parse(e.data),r=t.language,a=t.code,l=t.immediateClose;_self.postMessage(n.highlight(a,n.languages[r],r)),l&&_self.close()},!1),_self.Prism):_self.Prism;var a=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return a&&(n.filename=a.src,n.manual||a.hasAttribute("data-manual")||("loading"!==document.readyState?window.requestAnimationFrame?window.requestAnimationFrame(n.highlightAll):window.setTimeout(n.highlightAll,16):document.addEventListener("DOMContentLoaded",n.highlightAll))),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
Prism.languages.markup={comment:/<!--[\s\S]*?-->/,prolog:/<\?[\s\S]+?\?>/,doctype:/<!DOCTYPE[\s\S]+?>/i,cdata:/<!\[CDATA\[[\s\S]*?]]>/i,tag:{pattern:/<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i,greedy:!0,inside:{tag:{pattern:/^<\/?[^\s>\/]+/i,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"attr-value":{pattern:/=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/i,inside:{punctuation:[/^=/,{pattern:/(^|[^\\])["']/,lookbehind:!0}]}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:/&#?[\da-z]{1,8};/i},Prism.languages.markup.tag.inside["attr-value"].inside.entity=Prism.languages.markup.entity,Prism.hooks.add("wrap",function(a){"entity"===a.type&&(a.attributes.title=a.content.replace(/&amp;/,"&"))}),Prism.languages.xml=Prism.languages.markup,Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup;
Prism.languages.css={comment:/\/\*[\s\S]*?\*\//,atrule:{pattern:/@[\w-]+?.*?(?:;|(?=\s*\{))/i,inside:{rule:/@[\w-]+/}},url:/url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,selector:/[^{}\s][^{};]*?(?=\s*\{)/,string:{pattern:/("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},property:/[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,important:/\B!important\b/i,"function":/[-a-z0-9]+(?=\()/i,punctuation:/[(){};:]/},Prism.languages.css.atrule.inside.rest=Prism.languages.css,Prism.languages.markup&&(Prism.languages.insertBefore("markup","tag",{style:{pattern:/(<style[\s\S]*?>)[\s\S]*?(?=<\/style>)/i,lookbehind:!0,inside:Prism.languages.css,alias:"language-css",greedy:!0}}),Prism.languages.insertBefore("inside","attr-value",{"style-attr":{pattern:/\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,inside:{"attr-name":{pattern:/^\s*style/i,inside:Prism.languages.markup.tag.inside},punctuation:/^\s*=\s*['"]|['"]\s*$/,"attr-value":{pattern:/.+/i,inside:Prism.languages.css}},alias:"language-css"}},Prism.languages.markup.tag));
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(?:true|false)\b/,"function":/\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};
Prism.languages.c=Prism.languages.extend("clike",{keyword:/\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,operator:/>>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*\/%&|^!=<>]=?/,number:/(?:\b0x[\da-f]+|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?)[ful]*/i}),Prism.languages.insertBefore("c","string",{macro:{pattern:/(^\s*)#\s*[a-z]+(?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im,lookbehind:!0,alias:"property",inside:{string:{pattern:/(#\s*include\s*)(?:<.+?>|("|')(?:\\?.)+?\2)/,lookbehind:!0},directive:{pattern:/(#\s*)\b(?:define|defined|elif|else|endif|error|ifdef|ifndef|if|import|include|line|pragma|undef|using)\b/,lookbehind:!0,alias:"keyword"}}},constant:/\b(?:__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|stdin|stdout|stderr)\b/}),delete Prism.languages.c["class-name"],delete Prism.languages.c["boolean"];
Prism.languages.cpp=Prism.languages.extend("c",{keyword:/\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|concept|const|constexpr|const_cast|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,"boolean":/\b(?:true|false)\b/,operator:/>>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*\/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/}),Prism.languages.insertBefore("cpp","keyword",{"class-name":{pattern:/(class\s+)\w+/i,lookbehind:!0}}),Prism.languages.insertBefore("cpp","string",{"raw-string":{pattern:/R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,alias:"string",greedy:!0}});
Prism.languages.nasm={comment:/;.*$/m,string:/(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,label:{pattern:/(^\s*)[A-Za-z._?$][\w.?$@~#]*:/m,lookbehind:!0,alias:"function"},keyword:[/\[?BITS (?:16|32|64)\]?/,{pattern:/(^\s*)section\s*[a-zA-Z.]+:?/im,lookbehind:!0},/(?:extern|global)[^;\r\n]*/i,/(?:CPU|FLOAT|DEFAULT).*$/m],register:{pattern:/\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|sp|si|di)|[cdefgs]s)\b/i,alias:"variable"},number:/(?:\b|(?=\$))(?:0[hx][\da-f]*\.?[\da-f]+(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|\d*\.?\d+(?:\.?e[+-]?\d+)?[dt]?)\b/i,operator:/[\[\]*+\-\/%<>=&|$!]/};
Prism.languages.rust={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?\*\//,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0}],string:[{pattern:/b?r(#*)"(?:\\.|(?!"\1)[^\\\r\n])*"\1/,greedy:!0},{pattern:/b?"(?:\\.|[^\\\r\n"])*"/,greedy:!0}],"char":{pattern:/b?'(?:\\(?:x[0-7][\da-fA-F]|u{(?:[\da-fA-F]_*){1,6}|.)|[^\\\r\n\t'])'/,alias:"string"},"lifetime-annotation":{pattern:/'[^\s>']+/,alias:"symbol"},keyword:/\b(?:abstract|alignof|as|be|box|break|const|continue|crate|do|else|enum|extern|false|final|fn|for|if|impl|in|let|loop|match|mod|move|mut|offsetof|once|override|priv|pub|pure|ref|return|sizeof|static|self|struct|super|true|trait|type|typeof|unsafe|unsized|use|virtual|where|while|yield)\b/,attribute:{pattern:/#!?\[.+?\]/,greedy:!0,alias:"attr-name"},"function":[/\w+(?=\s*\()/,/\w+!(?=\s*\(|\[)/],"macro-rules":{pattern:/\w+!/,alias:"function"},number:/\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(\d(?:_?\d)*)?\.?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:[iu](?:8|16|32|64)?|f32|f64))?\b/,"closure-params":{pattern:/\|[^|]*\|(?=\s*[{-])/,inside:{punctuation:/[|:,]/,operator:/[&*]/}},punctuation:/[{}[\];(),:]|\.+|->/,operator:/[-+*\/%!^]=?|=[=>]?|@|&[&=]?|\|[|=]?|<<?=?|>>?=?/};
!function(){function e(e,t){return Array.prototype.slice.call((t||document).querySelectorAll(e))}function t(e,t){return t=" "+t+" ",(" "+e.className+" ").replace(/[\n\t]/g," ").indexOf(t)>-1}function n(e,n,i){n="string"==typeof n?n:e.getAttribute("data-line");for(var o,l=n.replace(/\s+/g,"").split(","),a=+e.getAttribute("data-line-offset")||0,s=r()?parseInt:parseFloat,d=s(getComputedStyle(e).lineHeight),u=t(e,"line-numbers"),c=0;o=l[c++];){var p=o.split("-"),m=+p[0],f=+p[1]||m,h=e.querySelector('.line-highlight[data-range="'+o+'"]')||document.createElement("div");if(h.setAttribute("aria-hidden","true"),h.setAttribute("data-range",o),h.className=(i||"")+" line-highlight",u&&Prism.plugins.lineNumbers){var g=Prism.plugins.lineNumbers.getLine(e,m),y=Prism.plugins.lineNumbers.getLine(e,f);g&&(h.style.top=g.offsetTop+"px"),y&&(h.style.height=y.offsetTop-g.offsetTop+y.offsetHeight+"px")}else h.setAttribute("data-start",m),f>m&&h.setAttribute("data-end",f),h.style.top=(m-a-1)*d+"px",h.textContent=new Array(f-m+2).join(" \n");u?e.appendChild(h):(e.querySelector("code")||e).appendChild(h)}}function i(){var t=location.hash.slice(1);e(".temporary.line-highlight").forEach(function(e){e.parentNode.removeChild(e)});var i=(t.match(/\.([\d,-]+)$/)||[,""])[1];if(i&&!document.getElementById(t)){var r=t.slice(0,t.lastIndexOf(".")),o=document.getElementById(r);o&&(o.hasAttribute("data-line")||o.setAttribute("data-line",""),n(o,i,"temporary "),document.querySelector(".temporary.line-highlight").scrollIntoView())}}if("undefined"!=typeof self&&self.Prism&&self.document&&document.querySelector){var r=function(){var e;return function(){if("undefined"==typeof e){var t=document.createElement("div");t.style.fontSize="13px",t.style.lineHeight="1.5",t.style.padding=0,t.style.border=0,t.innerHTML="&nbsp;<br />&nbsp;",document.body.appendChild(t),e=38===t.offsetHeight,document.body.removeChild(t)}return e}}(),o=0;Prism.hooks.add("before-sanity-check",function(t){var n=t.element.parentNode,i=n&&n.getAttribute("data-line");if(n&&i&&/pre/i.test(n.nodeName)){var r=0;e(".line-highlight",n).forEach(function(e){r+=e.textContent.length,e.parentNode.removeChild(e)}),r&&/^( \n)+$/.test(t.code.slice(-r))&&(t.code=t.code.slice(0,-r))}}),Prism.hooks.add("complete",function l(e){var r=e.element.parentNode,a=r&&r.getAttribute("data-line");if(r&&a&&/pre/i.test(r.nodeName)){clearTimeout(o);var s=Prism.plugins.lineNumbers,d=e.plugins&&e.plugins.lineNumbers;t(r,"line-numbers")&&s&&!d?Prism.hooks.add("line-numbers",l):(n(r,a),o=setTimeout(i,1))}}),window.addEventListener("hashchange",i),window.addEventListener("resize",function(){var e=document.querySelectorAll("pre[data-line]");Array.prototype.forEach.call(e,function(e){n(e)})})}}();
</script>

</head>
<body>
<address align=right>
Document Number: DxxxxR0 <br />
Date: 2019-03-03 <br />
Audience: LWG <br />
Reply-To: Barry Revzin, barry dot revzin at gmail dot com <br />
</address>
<hr /><h1 align=center><p>The Mothership Has Landed - Adding <code class="language-cpp">&lt;=&gt;</code> to library</p></h1>
<h2>Contents</h2>
<div class="toc">
<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#acknowledgments">Acknowledgments</a></li>
<li><a href="#wording">Wording</a><ol>
<li><a href="#clause-15-library-introduction">Clause 15: Library Introduction</a></li>
<li><a href="#clause-16-language-support-library">Clause 16: Language support library</a></li>
<li><a href="#clause-17-concepts-library">Clause 17: Concepts Library</a></li>
<li><a href="#clause-18-diagnostics-library">Clause 18: Diagnostics Library</a></li>
<li><a href="#clause-19-general-utilities-library">Clause 19: General utilities library</a></li>
<li><a href="#clause-20-strings-library">Clause 20: Strings library</a></li>
<li><a href="#clause-24-algorithms-library">Clause 24: Algorithms library</a></li>
</ol>
</li>
<li><a href="#references">References</a></li>
</ol>
</div>

<h2 id="introduction">1. Introduction<a class="self-link" href="#introduction"></a></h2>
<p>The work of integrating <code class="language-cpp">operator&lt;=&gt;</code> into the library has been performed by multiple different papers, each addressing a different aspect of the integration. In the interest of streamlining review by the Library Working Group, the wording has been combined into a single paper. This is that paper.</p>
<p>In San Diego and Kona, several papers were approved by LEWG adding functionality to the library related to comparisons. What follows is the list of those papers, in alphabetical order, with a brief description of what those papers are. The complete motivation and design rationale for each can be found within the papers themselves.</p>
<ul>
<li><a href="https://wg21.link/p0790r2" title="Effect of operator&lt;=&gt; on the C++ Standard Library">P0790R2</a> - adding <code class="language-cpp">operator&lt;=&gt;</code> to the standard library types whose behavior is not dependent on a template parameter.</li>
<li><a href="https://wg21.link/p0891r2" title="Make strong_order a Customization Point!">P0891R2</a> - making the <code class="language-cpp">XXX_order</code> algorithms customization points and introducing <code class="language-cpp">compare_XXX_order_fallback</code> algorithms that preferentially invoke the former algorithm and fallback to synthesizing an ordering from <code class="language-cpp">==</code> and <code class="language-cpp">&lt;</code> (using the rules from <a href="https://wg21.link/p1186r1" title="When do you actually use &lt;=&gt;?">P1186R1</a>).</li>
<li><a href="https://wg21.link/p1154r1" title="Type traits for structural comparison">P1154R1</a> - adding the type trait <code class="language-cpp">has_strong_structural_equality&lt;T&gt;</code> (useful to check if a type can be used as a non-type template parameter).</li>
<li><a href="https://wg21.link/p1188r0" title="Library utilities for &lt;=&gt;">P1188R0</a> - adding the type trait <code class="language-cpp">compare_three_way_result&lt;T&gt;</code>, the concepts <code class="language-cpp">ThreeWayComparable&lt;T&gt;</code> and <code class="language-cpp">ThreeWayComparableWith&lt;T,U&gt;</code>, removing the algorithm <code class="language-cpp">compare_3way</code> and replacing it with a function comparison object <code class="language-cpp">compare_three_way</code> (i.e. the <code class="language-cpp">&lt;=&gt;</code> version of <code class="language-cpp">std::ranges::less</code>).</li>
<li><a href="https://wg21.link/p1189r0" title="Add &lt;=&gt; to Library">P1189R0</a> - adding <code class="language-cpp">operator&lt;=&gt;</code> to the standard library types whose behavior is dependent on a template parameter, removing those equality operators made redundant by <a href="https://wg21.link/p1185r1" title="&lt;=&gt; != ==">P1185R1</a> and defaulting <code class="language-cpp">operator==</code> where appropriate.</li>
<li><a href="https://wg21.link/p1191r0" title="Adding operator&lt;=&gt; to types that are not currently comparable">P1191R0</a> - adding equality to several previously incomparable standard library types.</li>
<li><a href="https://wg21.link/p1380r1" title="Ambiguity and Insecurities with Three-Way Comparison">P1380R1</a> - extending the floating point customization points for <code class="language-cpp">strong_order</code> and <code class="language-cpp">weak_order</code>.</li>
</ul>
<p>LEWG's unanimous preference was that <code class="language-cpp">operator&lt;=&gt;</code>s be declared as hidden friends.</p>
<h2 id="acknowledgments">2. Acknowledgments<a class="self-link" href="#acknowledgments"></a></h2>
<p>Thank you to Casey Carter for the tremendous wording review.</p>
<h2 id="wording">3. Wording<a class="self-link" href="#wording"></a></h2>
<h3 id="clause-15-library-introduction">3.1. Clause 15: Library Introduction<a class="self-link" href="#clause-15-library-introduction"></a></h3>
<p>Change 15.4.2.1/2 [expos.only.func]:</p>
<blockquote>
<p>The following <del>function is</del> <ins>are</ins> defined for exposition only to aid in the specification of the library:</p>
</blockquote>
<p>and append:</p>
<blockquote><pre><code>template&lt;class T, class U&gt;
constexpr auto <i>synth-3way</i>(const T& t, const U& u) {
  if constexpr (ThreeWayComparableWith&lt;T, U&gt;) {
    return t <=> u;
  } else {
    if (t < u) return weak_ordering::less;
    if (u < t) return weak_ordering::greater;
    return weak_ordering::equivalent;
  }
}

template&lt;class T, class U=T&gt;
using <i>synth-3way-type</i> = decltype(<i>synth-3way</i>(declval&lt;T&&gt;(), declval&lt;U&&gt;()));</code></pre></blockquote>

<p>Remove 15.4.2.3 [operators], which begins:</p>
<blockquote>
<p>In this library, whenever a declaration is provided for an <code class="language-cpp">operator!=</code>, <code class="language-cpp">operator&gt;</code>, <code class="language-cpp">operator&lt;=</code>, or <code class="language-cpp">operator&gt;=</code> for a type <code class="language-cpp">T</code>, its requirements and semantics are as follows, unless explicitly specified otherwise.</p>
</blockquote>
<h3 id="clause-16-language-support-library">3.2. Clause 16: Language support library<a class="self-link" href="#clause-16-language-support-library"></a></h3>
<p>Added: <code class="language-cpp">compare_three_way_result</code>, concepts <code class="language-cpp">ThreeWayComparable</code> and <code class="language-cpp">ThreeWayComparableWith</code>, <code class="language-cpp">compare_three_way</code> and <code class="language-cpp">compare_XXX_order_fallback</code></p>
<p>Changed operators for: <code class="language-cpp">type_info</code></p>
<p>Respecified: <code class="language-cpp">strong_order()</code>, <code class="language-cpp">weak_order()</code>, and <code class="language-cpp">partial_order()</code></p>
<p>Removed: <code class="language-cpp">compare_3way()</code>, <code class="language-cpp">strong_equal()</code>, and <code class="language-cpp">weak_equal()</code></p>
<p>In 16.7.2 [type.info], remove <code class="language-cpp">operator!=</code>:</p>
<blockquote><pre><code>namespace std {
  class type_info {
  public:
    virtual ~type_info();
    bool operator==(const type_info& rhs) const noexcept;
    <del>bool operator!=(const type_info& rhs) const noexcept;</del>
    bool before(const type_info& rhs) const noexcept;
    size_t hash_code() const noexcept;
    const char* name() const noexcept;
    type_info(const type_info& rhs) = delete; // cannot be copied
    type_info& operator=(const type_info& rhs) = delete; // cannot be copied
  };
}</code></pre></blockquote>

<p>and</p>
<blockquote>
<p><pre><code>bool operator==(const type_info&amp; rhs) const noexcept;</code></pre>
<em>Effects</em>: Compares the current object with rhs.<br />
<em>Returns</em>: <code class="language-cpp">true</code> if the two values describe the same type.<br />
<pre><code><del>bool operator!=(const type_info&amp; rhs) const noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">!(*this == rhs)</code>.</del></p>
</blockquote>
<p>Add into 16.11.1 [compare.syn]:</p>
<blockquote><pre><code>namespace std {
  // [cmp.categories], comparison category types
  class weak_equality;
  class strong_equality;
  class partial_ordering;
  class weak_ordering;
  class strong_ordering;

  // named comparison functions
  constexpr bool is_eq  (weak_equality cmp) noexcept    { return cmp == 0; }
  constexpr bool is_neq (weak_equality cmp) noexcept    { return cmp != 0; }
  constexpr bool is_lt  (partial_ordering cmp) noexcept { return cmp < 0; }
  constexpr bool is_lteq(partial_ordering cmp) noexcept { return cmp <= 0; }
  constexpr bool is_gt  (partial_ordering cmp) noexcept { return cmp > 0; }
  constexpr bool is_gteq(partial_ordering cmp) noexcept { return cmp >= 0; }

  // [cmp.common], common comparison category type  
  template&lt;class... Ts&gt;
  struct common_comparison_category {
    using type = see below;
  };
  template&lt;class... Ts&gt;
    using common_comparison_category_t = typename common_comparison_category&lt;Ts...&gt;::type;  

  <ins>// [cmp.concept], concept ThreeWayComparable</ins>
  <ins>template&lt;class T, class Cat = weak_equality&gt;</ins>
    <ins>concept ThreeWayComparable = <i>see below</i>;</ins>
  <ins>template&lt;class T, class U, class Cat = weak_equality&gt;</ins>
    <ins>concept ThreeWayComparableWith = <i>see below</i>;</ins>

  <ins>// [cmp.result], compare_three_way_result</ins>
  <ins>template&lt;class T, class U = T&gt; struct compare_three_way_result;</ins>

  <ins>template&lt;class T, class U = T&gt;</ins>
  <ins>  using compare_three_way_result_t = typename compare_three_way_result&lt;T, U&gt;::type;</ins>

  <ins>// [cmp.object], compare_three_way</ins>
  <ins>struct compare_three_way;</ins>

  // [cmp.alg], comparison algorithms
  <del>template&lt;class T&gt; constexpr strong_ordering strong_order(const T& a, const T& b);</del>
  <del>template&lt;class T&gt; constexpr weak_ordering weak_order(const T& a, const T& b);</del>
  <del>template&lt;class T&gt; constexpr partial_ordering partial_order(const T& a, const T& b);</del>
  <del>template&lt;class T&gt; constexpr strong_equality strong_equal(const T& a, const T& b);</del>
  <del>template&lt;class T&gt; constexpr weak_equality weak_equal(const T& a, const T& b);</del>
  <ins>inline namespace <i>unspecified</i> {</ins>
    <ins>inline constexpr <i>unspecified</i> strong_order = <i>unspecified</i>;</ins>
    <ins>inline constexpr <i>unspecified</i> weak_order = <i>unspecified</i>;</ins>
    <ins>inline constexpr <i>unspecified</i> partial_order = <i>unspecified</i>;</ins>
    <ins>inline constexpr <i>unspecified</i> compare_strong_order_fallback = <i>unspecified</i>;</ins>
    <ins>inline constexpr <i>unspecified</i> compare_weak_order_fallback = <i>unspecified</i>;</ins>
    <ins>inline constexpr <i>unspecified</i> compare_partial_order_fallback = <i>unspecified</i>;</ins>
  <ins>}</ins>
}</code></pre></blockquote>

<p>Add a new clause [cmp.concept]. We don't need to add any new semantic constraints. The requirement that the <code class="language-cpp">&lt;=&gt;</code>s used have to be equality-preserving is picked up through [concepts.equality] already.</p>
<blockquote>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T, typename Cat&gt;
  concept compares-as = // exposition only
    Same&lt;common_comparison_category_t&lt;T, Cat&gt;, Cat&gt;;

template &lt;typename T, typename Cat=std::weak_equality&gt;
  concept ThreeWayComparable =
    requires(const remove_reference_t&lt;T&gt;&amp; a,
             const remove_reference_t&lt;T&gt;&amp; b) {
      { a &lt;=&gt; b } -&gt; compares-as&lt;Cat&gt;;
    };

template &lt;typename T, typename U,
          typename Cat=std::weak_equality&gt;
  concept ThreeWayComparableWith = 
    ThreeWayComparable&lt;T, Cat&gt; &amp;&amp;
    ThreeWayComparable&lt;U, Cat&gt; &amp;&amp;
    CommonReference&lt;const remove_reference_t&lt;T&gt;&amp;, const remove_reference_t&lt;U&gt;&amp;&gt; &amp;&amp;
    ThreeWayComparable&lt;
      common_reference_t&lt;const remove_reference_t&lt;T&gt;&amp;, const remove_reference_t&lt;U&gt;&amp;&gt;,
      Cat&gt; &amp;&amp;
    requires(const remove_reference_t&lt;T&gt;&amp; t,
             const remove_reference_t&lt;U&gt;&amp; u) {
      { t &lt;=&gt; u } -&gt; compares-as&lt;Cat&gt;;
      { u &lt;=&gt; t } -&gt; compares-as&lt;Cat&gt;;
    };</code></pre>


</blockquote>
<p>Add a new specification for <code class="language-cpp">compare_three_way_result</code> in a new clause after 16.11.3 [cmp.common] named [cmp.result]:</p>
<blockquote>
<p>The behavior of a program that adds specializations for the <code class="language-cpp">compare_three_way_result</code> template defined in this subclause is undefined.</p>
<p>For the <code class="language-cpp">compare_three_way_result</code> type trait applied to the types <code class="language-cpp">T</code> and <code class="language-cpp">U</code>, let <code class="language-cpp">t</code> and <code class="language-cpp">u</code> denote lvalues of types <code class="language-cpp">const remove_reference_t&lt;T&gt;</code> and <code class="language-cpp">const remove_reference_t&lt;U&gt;</code>. If the expression <code class="language-cpp">t &lt;=&gt; u</code> is well-formed, the member <em>typedef-name</em> <code class="language-cpp">type</code> denotes the type <code class="language-cpp">decltype(t &lt;=&gt; u)</code>. Otherwise, there is no member <code class="language-cpp">type</code>.</p>
</blockquote>
<p>Add a new specification for <code class="language-cpp">compare_three_way</code> in a new clause named [cmp.object]:</p>
<blockquote>
<p>In this subclause, <code class="language-cpp">BUILTIN_PTR_3WAY(T, U)</code> for types <code class="language-cpp">T</code> and <code class="language-cpp">U</code> is a boolean constant expression. <code class="language-cpp">BUILTIN_PTR_3WAY(T, U)</code> is <code class="language-cpp">true</code> if and only if <code class="language-cpp">&lt;=&gt;</code> in the expression <code class="language-cpp">declval&lt;T&gt;() &lt;=&gt; declval&lt;U&gt;()</code> resolves to a built-in operator comparing pointers.</p>
<p>There is an implementation-defined strict total ordering over all pointer values of a given type. This total ordering is consistent with the partial order imposed by the builtin operator <code class="language-cpp">&lt;=&gt;</code>.</p>
<pre class="codehilite"><code class="language-cpp">struct compare_three_way {
  template&lt;class T, class U&gt;
    requires ThreeWayComparableWith&lt;T,U&gt; || BUILTIN_PTR_3WAY(T, U)
  constexpr auto operator()(T&amp;&amp; t, U&amp;&amp;u) const;

  using is_transparent = unspecified;
};</code></pre>


<p><em>Expects</em>: If the expression <code class="language-cpp">std::forward&lt;T&gt;(t) &lt;=&gt; std::forward&lt;U&gt;(u)</code> results in a call to a built-in operator <code class="language-cpp">&lt;=&gt;</code> comparing pointers of type <code class="language-cpp">P</code>, the conversion sequences from both <code class="language-cpp">T</code> and <code class="language-cpp">U</code> to <code class="language-cpp">P</code> are equality-preserving ([concepts.equality]).</p>
<p><em>Effects</em>: </p>
<ul>
<li>If the expression <code class="language-cpp">std::forward&lt;T&gt;(t) &lt;=&gt; std::forward&lt;U&gt;(u)</code> results in a call to a built-in operator <code class="language-cpp">&lt;=&gt;</code> comparing pointers of type <code class="language-cpp">P</code>: returns <code class="language-cpp">strong_ordering::less</code> if (the converted value of) <code class="language-cpp">t</code> precedes <code class="language-cpp">u</code> in the implementation-defined strict total order over pointers of type <code class="language-cpp">P</code>, <code class="language-cpp">strong_ordering::greater</code> if <code class="language-cpp">u</code> precedes <code class="language-cpp">t</code>, and otherwise <code class="language-cpp">strong_ordering::equal</code>.</li>
<li>Otherwise, equivalent to: <code class="language-cpp">return std::forward&lt;T&gt;(t) &lt;=&gt; std::forward&lt;U&gt;(u);</code></li>
</ul>
</blockquote>
<p>Replace the entirety of 16.11.4 [cmp.alg]. This wording relies on the specification-only function <code class="language-cpp">3WAY&lt;R&gt;</code> defined in <a href="https://wg21.link/p1186r1" title="When do you actually use &lt;=&gt;?">P1186R1</a>.</p>
<blockquote>
<p><pre><code><del>template&lt;class T&gt; constexpr strong_ordering strong_order(const T&amp; a, const T&amp; b);</del></code></pre>
<del><em>Effects</em>: Compares two values and produces a result of type <code class="language-cpp">strong_ordering</code>:</del>  </p>
<ul>
<li><del>If numeric_ยญlimits<T>::is_iec559 is true, returns a result of type strong_ordering that is consistent with the totalOrder operation as specified in ISO/IEC/IEEE 60559.</del></li>
<li><del>Otherwise, returns a &lt;=&gt; b if that expression is well-formed and convertible to strong_ordering.</del></li>
<li><del>Otherwise, if the expression a &lt;=&gt; b is well-formed, then the function is defined as deleted.</del></li>
<li><del>Otherwise, if the expressions a == b and a &lt; b are each well-formed and convertible to bool, then</del><ul>
<li><del>if a == b is true, returns strong_ordering::equal;</del></li>
<li><del>otherwise, if a &lt; b is true, returns strong_ordering::less;</del></li>
<li><del>otherwise, returns strong_ordering::greater.</del></li>
</ul>
</li>
<li><del>Otherwise, the function is defined as deleted.</del></li>
</ul>
<p><pre><code><del>template&lt;class T&gt; constexpr weak_ordering weak_order(const T&amp; a, const T&amp; b);</del></code></pre>
<del><em>Effects</em>: Compares two values and produces a result of type weak_ordering:</del></p>
<ul>
<li><del>Returns a &lt;=&gt; b if that expression is well-formed and convertible to weak_ordering.</del></li>
<li><del>Otherwise, if the expression a &lt;=&gt; b is well-formed, then the function is defined as deleted.</del></li>
<li><del>Otherwise, if the expressions a == b and a &lt; b are each well-formed and convertible to bool, then</del><ul>
<li><del>if a == b is true, returns weak_ordering::equivalent;</del></li>
<li><del>otherwise, if a &lt; b is true, returns weak_ordering::less;</del></li>
<li><del>otherwise, returns weak_ordering::greater.</del></li>
</ul>
</li>
<li><del>Otherwise, the function is defined as deleted.</del></li>
</ul>
<p><pre><code><del>template&lt;class T&gt; constexpr partial_ordering partial_order(const T&amp; a, const T&amp; b);</del></code></pre>
<del><em>Effects</em>: Compares two values and produces a result of type partial_ordering:</del></p>
<ul>
<li><del>Returns a &lt;=&gt; b if that expression is well-formed and convertible to partial_ordering.</del></li>
<li><del>Otherwise, if the expression a &lt;=&gt; b is well-formed, then the function is defined as deleted.</del></li>
<li><del>Otherwise, if the expressions a == b and a &lt; b are each well-formed and convertible to bool, then</del><ul>
<li><del>if a == b is true, returns partial_ordering::equivalent;</del></li>
<li><del>otherwise, if a &lt; b is true, returns partial_ordering::less;</del></li>
<li><del>otherwise, returns partial_ordering::greater.</del></li>
</ul>
</li>
<li><del>Otherwise, the function is defined as deleted.</del></li>
</ul>
<p><pre><code><del>template&lt;class T&gt; constexpr strong_equality strong_equal(const T&amp; a, const T&amp; b);</del></code></pre>
<del><em>Effects</em>: Compares two values and produces a result of type strong_equality:</del></p>
<ul>
<li><del>Returns a &lt;=&gt; b if that expression is well-formed and convertible to strong_equality.</del></li>
<li><del>Otherwise, if the expression a &lt;=&gt; b is well-formed, then the function is defined as deleted.</del></li>
<li><del>Otherwise, if the expression a == b is well-formed and convertible to bool, then</del><ul>
<li><del>if a == b is true, returns strong_equality::equal;</del></li>
<li><del>otherwise, returns strong_equality::nonequal.</del></li>
</ul>
</li>
<li><del>Otherwise, the function is defined as deleted.</del></li>
</ul>
<p><pre><code><del>template&lt;class T&gt; constexpr weak_equality weak_equal(const T&amp; a, const T&amp; b);</del></code></pre>
<del><em>Effects</em>: Compares two values and produces a result of type weak_equality:</del></p>
<ul>
<li><del>Returns a &lt;=&gt; b if that expression is well-formed and convertible to weak_equality.</del></li>
<li><del>Otherwise, if the expression a &lt;=&gt; b is well-formed, then the function is defined as deleted.</del></li>
<li><del>Otherwise, if the expression a == b is well-formed and convertible to bool, then</del><ul>
<li><del>if a == b is true, returns weak_equality::equivalent;</del></li>
<li><del>otherwise, returns weak_equality::nonequivalent.</del></li>
</ul>
</li>
<li><del>Otherwise, the function is defined as deleted.</del></li>
</ul>
<p><ins>The name <code class="language-cpp">strong_order</code> denotes a customization point object ([customization.point.object]). The expression <code class="language-cpp">strong_order(E, F)</code> for some subexpressions <code class="language-cpp">E</code> and <code class="language-cpp">F</code> is expression-equivalent to the following:</p>
<ul>
<li><ins>If the decayed types of <code class="language-cpp">E</code> and <code class="language-cpp">F</code> differ, <code class="language-cpp">strong_order(E, F)</code> is ill-formed.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">strong_ordering(strong_order(E, F))</code> if it is a well-formed expression with overload resolution performed in a context that does not include a declaration of <code class="language-cpp">std::strong_order</code>.</ins></li>
<li><ins>Otherwise, if the decayed type <code class="language-cpp">T</code> of <code class="language-cpp">E</code> and <code class="language-cpp">F</code> is a floating point type, yields a value of type <code class="language-cpp">strong_ordering</code> that is consistent with the ordering observed by <code class="language-cpp">T</code>'s comparison operators, and if <code class="language-cpp">numeric_limits&lt;T&gt;::is_iec559</code> is <code class="language-cpp">true</code> is additionally consistent with the totalOrder operation as specified in ISO/IEC/IEEE 60599.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">strong_ordering(E &lt;=&gt; F)</code> if it is a well-formed expression.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">strong_order(E, F)</code> is ill-formed. [<em>Note</em>: This case can result in substitution failure when <code class="language-cpp">strong_order(E, F)</code> appears in the immediate context of a template instantiation. โ<em>end note</em>]</ins></li>
</ul>
<p><ins>The name <code class="language-cpp">weak_order</code> denotes a customization point object ([customization.point.object]). The expression <code class="language-cpp">weak_order(E, F)</code> for some subexpressions <code class="language-cpp">E</code> and <code class="language-cpp">F</code> is expression-equivalent to the following:</ins></p>
<ul>
<li><ins>If the decayed types of <code class="language-cpp">E</code> and <code class="language-cpp">F</code> differ, <code class="language-cpp">weak_order(E, F)</code> is ill-formed.</ins> </li>
<li><ins>Otherwise, <code class="language-cpp">weak_ordering(weak_order(E, F))</code> if it is a well-formed expression with overload resolution performed in a context that does not include a declaration of <code class="language-cpp">std::weak_order</code>.</ins></li>
<li><ins>Otherwise, if the decayed type <code class="language-cpp">T</code> of <code class="language-cpp">E</code> and <code class="language-cpp">F</code> is a floating point type, yields a value of type <code class="language-cpp">weak_ordering</code> that is consistent with the ordering observed by <code class="language-cpp">T</code>'s comparison operators and <code class="language-cpp">strong_order</code>, and if <code class="language-cpp">numeric_liits&lt;T&gt;::is_iec559</code> is <code class="language-cpp">true</code> is additionally consistent with the following equivalence classes, ordered from lesser to greater:</ins><ul>
<li><ins>Together, all negative NaN values</ins></li>
<li><ins>Negative infinity</ins></li>
<li><ins>Each normal negative value</ins></li>
<li><ins>Each subnormal negative value</ins></li>
<li><ins>Together, both zero values</ins></li>
<li><ins>Each subnormal positive value</ins></li>
<li><ins>Each normal positive value</ins></li>
<li><ins>Positive infinity</ins></li>
<li><ins>Together, all positive NaN values</ins></li>
</ul>
</li>
<li><ins>Otherwise, <code class="language-cpp">weak_ordering(strong_order(E, F))</code> if it is a well-formed expression.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">weak_ordering(E &lt;=&gt; F)</code> if it is a well-formed expression.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">weak_order(E, F)</code> is ill-formed. [<em>Note</em>: This case can result in substitution failure when <code class="language-cpp">std::weak_order(E, F)</code> appears in the immediate context of a template instantiation. โ<em>end note</em>]</ins></li>
</ul>
<p><ins>The name <code class="language-cpp">partial_order</code> denotes a customization point object ([customization.point.object]). The expression <code class="language-cpp">partial_order(E, F)</code> for some subexpressions <code class="language-cpp">E</code> and <code class="language-cpp">F</code> is expression-equivalent to the following:</ins></p>
<ul>
<li><ins>If the decayed types of <code class="language-cpp">E</code> and <code class="language-cpp">F</code> differ, <code class="language-cpp">partial_order(E, F)</code> is ill-formed.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">partial_ordering(partial_order(E, F))</code> if it is a well-formed expression with overload resolution performed in a context that does not include a declaration of <code class="language-cpp">std::partial_order</code>.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">partial_ordering(weak_order(E, F))</code> if it is a well-formed expression.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">partial_ordering(E &lt;=&gt; F)</code> if it is a well-formed expression.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">partial_order(E, F)</code> is ill-formed. [<em>Note</em>: This case can result in substitution failure when <code class="language-cpp">std::partial_order(E, F)</code> appears in the immediate context of a template instantiation. โ<em>end note</em>]</ins>
</li>
</ul>
<p><ins>The name <code class="language-cpp">compare_strong_order_fallback</code> denotes a comparison customization point ([customization.point.object]) object. The expression <code class="language-cpp">compare_strong_order_fallback(E, F)</code> for some subexpressions <code class="language-cpp">E</code> and <code class="language-cpp">F</code> is expression-equivalent to:</ins></p>
<ul>
<li><ins>If the decayed types of <code class="language-cpp">E</code> and <code class="language-cpp">F</code> differ, <code class="language-cpp">compare_strong_order_fallback(E, F)</code> is ill-formed.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">strong_order(E, F)</code> if it is a well-formed expression.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">3WAY&lt;strong_ordering&gt;(E, F)</code> ([class.spaceship]) if it is a well-formed expression.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">compare_strong_order_fallback(E, F)</code> is ill-formed.</ins></li>
</ul>
<p><ins>The name <code class="language-cpp">compare_weak_order_fallback</code> denotes a customization point object ([customization.point.object]). The expression <code class="language-cpp">compare_weak_order_fallback(E, F)</code> for some subexpressions <code class="language-cpp">E</code> and <code class="language-cpp">F</code> is expression-equivalent to:</ins></p>
<ul>
<li><ins>If the decayed types of <code class="language-cpp">E</code> and <code class="language-cpp">F</code> differ, <code class="language-cpp">compare_weak_order_fallback(E, F)</code> is ill-formed.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">weak_order(E, F)</code> if it is a well-formed expression.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">3WAY&lt;weak_ordering&gt;(E, F)</code> ([class.spaceship]) if it is a well-formed expression.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">compare_weak_order_fallback(E, F)</code> is ill-formed.</ins></li>
</ul>
<p><ins>The name <code class="language-cpp">compare_partial_order_fallback</code> denotes a customization point object ([customization.point.object]). The expression <code class="language-cpp">compare_partial_order_fallback(E, F)</code> for some subexpressions <code class="language-cpp">E</code> and <code class="language-cpp">F</code> is expression-equivalent to:</ins></p>
<ul>
<li><ins>If the decayed types of <code class="language-cpp">E</code> and <code class="language-cpp">F</code> differ, <code class="language-cpp">compare_partial_order_fallback(E, F)</code> is ill-formed.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">partial_order(E, F)</code> if it is a well-formed expression.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">3WAY&lt;partial_ordering&gt;(E, F)</code> ([class.spaceship]) if it is a well-formed expression.</ins></li>
<li><ins>Otherwise, <code class="language-cpp">compare_partial_order_fallback(E, F)</code> is ill-formed.</ins></li>
</ul>
</blockquote>
<h3 id="clause-17-concepts-library">3.3. Clause 17: Concepts Library<a class="self-link" href="#clause-17-concepts-library"></a></h3>
<p>Nothing.</p>
<h3 id="clause-18-diagnostics-library">3.4. Clause 18: Diagnostics Library<a class="self-link" href="#clause-18-diagnostics-library"></a></h3>
<p>Changed operators for:</p>
<ul>
<li><code class="language-cpp">error_category</code></li>
<li><code class="language-cpp">error_code</code></li>
<li><code class="language-cpp">error_condition</code></li>
</ul>
<p>Change 18.5.1 [system_error.syn]</p>
<blockquote><pre><code>namespace std {
  [...]
  // 18.5.5, comparison functions
  bool operator==(const error_code& lhs, const error_code& rhs) noexcept;
  bool operator==(const error_code& lhs, const error_condition& rhs) noexcept;
  <del>bool operator==(const error_condition& lhs, const error_code& rhs) noexcept;</del>
  bool operator==(const error_condition& lhs, const error_condition& rhs) noexcept;
  <del>bool operator!=(const error_code& lhs, const error_code& rhs) noexcept;</del>
  <del>bool operator!=(const error_code& lhs, const error_condition& rhs) noexcept;</del>
  <del>bool operator!=(const error_condition& lhs, const error_code& rhs) noexcept;</del>
  <del>bool operator!=(const error_condition& lhs, const error_condition& rhs) noexcept;</del>
  <del>bool operator< (const error_code& lhs, const error_code& rhs) noexcept;</del>
  <del>bool operator< (const error_condition& lhs, const error_condition& rhs) noexcept;</del>
  <ins>strong_ordering operator<=>(const error_code& lhs, const error_code& rhs) noexcept;</ins>
  <ins>strong_ordering operator<=>(const error_condition& lhs, const error_condition& rhs) noexcept;</ins>
  [...]
}</code></pre></blockquote>

<p>Change 18.5.2.1 [syserr.errcat.overview]:</p>
<blockquote><pre><code>namespace std {
  class error_category {
    [...]
    bool operator==(const error_category& rhs) const noexcept;
    <del>bool operator!=(const error_category& rhs) const noexcept;</del>
    <del>bool operator< (const error_category& rhs) const noexcept;</del>
    <ins>strong_ordering operator<=>(const error_category& rhs) const noexcept;</ins>
  };
  [...]
}</code></pre></blockquote>

<p>Change 18.5.2.3 [syserr.errcat.nonvirtuals]:</p>
<blockquote>
<p><pre><code>bool operator==(const error_category&amp; rhs) const noexcept;</code></pre>
<em>Returns</em>: <code class="language-cpp">this == &amp;rhs</code>.
<pre><code><del>bool operator!=(const error_category&amp; rhs) const noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">!(*this == rhs)</code>.</del>
<pre><code><del>bool operator&lt;(const error_category&amp; rhs) const noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">less&lt;const error_category*&gt;()(this, &amp;rhs)</code>.</del><br />
<del>[Note: <code class="language-cpp">less</code> (19.14.7) provides a total ordering for pointers. โend note]</del>
<pre><code><ins>strong_ordering operator&lt;=&gt;(const error_category&amp; rhs) const noexcept;</ins></code></pre>
<ins><em>Returns</em>: <code class="language-cpp">compare_three_way()(this, &amp;rhs)</code>.</ins><br />
<ins>[Note: <code class="language-cpp">compare_three_way</code> (cmp.object) provides a total ordering for pointers. โend note]</ins></p>
</blockquote>
<p>Change 18.5.5 [syserr.compare]</p>
<blockquote>
<p><pre><code>bool operator==(const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</code></pre>
<em>Returns</em>: <code class="language-cpp">lhs.category() == rhs.category() &amp;&amp; lhs.value() == rhs.value()</code>
<pre><code>bool operator==(const error_code&amp; lhs, const error_condition&amp; rhs) noexcept;</code></pre>
<em>Returns</em>: <code class="language-cpp">lhs.category().equivalent(lhs.value(), rhs) || rhs.category().equivalent(lhs, rhs.value())</code>
<pre><code><del>bool operator==(const error_condition&amp; lhs, const error_code&amp; rhs) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">rhs.category().equivalent(rhs.value(), lhs) || lhs.category().equivalent(rhs, lhs.value())</code></del>
<pre><code>bool operator==(const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</code></pre>
<em>Returns</em>: <code class="language-cpp">lhs.category() == rhs.category() &amp;&amp; lhs.value() == rhs.value()</code>
<pre><code><del>bool operator!=(const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</del>
<del>bool operator!=(const error_code&amp; lhs, const error_condition&amp; rhs) noexcept;</del>
<del>bool operator!=(const error_condition&amp; lhs, const error_code&amp; rhs) noexcept;</del>
<del>bool operator!=(const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">!(lhs == rhs)</code>.</del>
<code><pre><del>bool operator&lt;(const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</del></code></pre>
<del><em>Returns</em>:
<code class="language-cpp">lhs.category() &lt; rhs.category() ||
(lhs.category() == rhs.category() &amp;&amp; lhs.value() &lt; rhs.value())</code></del>
<code><pre><del>bool operator&lt;(const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</del></code></pre>
<del><em>Returns</em>:
<code class="language-cpp">lhs.category() &lt; rhs.category() ||
(lhs.category() == rhs.category() &amp;&amp; lhs.value() &lt; rhs.value())</code></del>
<pre><code><ins>strong_ordering operator&lt;=&gt;(const error_code&amp; lhs, const error_code&amp; rhs) noexcept;</ins></code></pre>
<ins><em>Effects</em>: Equivalent to:</ins>
<blockquote class="ins"><pre><code>if (auto c = lhs.category() &lt;=&gt; rhs.category(); c != 0) return c;
return lhs.value() &lt;=&gt; rhs.value();</code></pre></blockquote>
<pre><code><ins>strong_ordering operator&lt;=&gt;(const error_condition&amp; lhs, const error_condition&amp; rhs) noexcept;</ins></code></pre>
<ins><em>Effects</em>: Equivalent to:</ins>
<blockquote class="ins"><pre><code>if (auto c = lhs.category() &lt;=&gt; rhs.category(); c != 0) return c;
return lhs.value() &lt;=&gt; rhs.value();</code></pre></blockquote></p>
</blockquote>
<h3 id="clause-19-general-utilities-library">3.5. Clause 19: General utilities library<a class="self-link" href="#clause-19-general-utilities-library"></a></h3>
<p>Changed operators for:</p>
<ul>
<li><code class="language-cpp">pair</code>, <code class="language-cpp">tuple</code>, <code class="language-cpp">optional</code>, <code class="language-cpp">variant</code>, <code class="language-cpp">monostate</code>, <code class="language-cpp">bitset</code>, <code class="language-cpp">allocator</code>, <code class="language-cpp">unique_ptr</code>, <code class="language-cpp">shared_ptr</code>, <code class="language-cpp">memory_resource</code>, <code class="language-cpp">polymorphic_allocator</code>, <code class="language-cpp">scoped_allocator_adaptor</code>, <code class="language-cpp">function</code>, <code class="language-cpp">type_index</code></li>
</ul>
<p>Change 19.2.1 [utility.syn]</p>
<blockquote><pre><code>#include <initializer_list> // see 16.10.1

namespace std {
  [...]
  // 19.4, class template pair
  template&lt;class T1, class T2&gt;
  struct pair;

  <del>// 19.4.3, pair specialized algorithms</del>
  <del>template&lt;class T1, class T2&gt;</del>
  <del>constexpr bool operator==(const pair&lt;T1, T2&gt;&, const pair&lt;T1, T2&gt;&);</del>
  <del>template&lt;class T1, class T2&gt;</del>
  <del>constexpr bool operator!=(const pair&lt;T1, T2&gt;&, const pair&lt;T1, T2&gt;&);</del>
  <del>template&lt;class T1, class T2&gt;</del>
  <del>constexpr bool operator&lt; (const pair&lt;T1, T2&gt;&, const pair&lt;T1, T2&gt;&);</del>
  <del>template&lt;class T1, class T2&gt;</del>
  <del>constexpr bool operator&gt; (const pair&lt;T1, T2&gt;&, const pair&lt;T1, T2&gt;&);</del>
  <del>template&lt;class T1, class T2&gt;</del>
  <del>constexpr bool operator&lt;=(const pair&lt;T1, T2&gt;&, const pair&lt;T1, T2&gt;&);</del>
  <del>template&lt;class T1, class T2&gt;</del>
  <del>constexpr bool operator&gt;=(const pair&lt;T1, T2&gt;&, const pair&lt;T1, T2&gt;&);</del>

  [...]
}</code></pre></blockquote>

<p>Change 19.4.2 [pairs.pair]:</p>
<blockquote><pre><code>namespace std {
template&lt;class T1, class T2&gt;
struct pair {
  [...]
  constexpr void swap(pair& p) noexcept(<i>see below</i>);

  <ins>friend constexpr bool operator==(const pair&, const pair&) = default;</ins>
  <ins>friend constexpr auto operator<=>(const pair&, const pair&)</ins>
  <ins>  -> common_comparison_category_t&lt;<i>synth-3way-type</i>&lt;T1&gt;, <i>synth-3way-type</i>&lt;T2&gt;&gt;</ins>
  <ins>{ <i>see below</i> }</ins>
};</code></pre>
</blockquote>

<blockquote>
<p>[...]
<pre><code>constexpr void swap(pair&amp; p) noexcept(<i>see below</i>);</code></pre>
<em>Requires</em>: <code class="language-cpp">first</code> shall be swappable with (15.5.3.2) <code class="language-cpp">p.first</code> and <code class="language-cpp">second</code> shall be swappable with <code class="language-cpp">p.second</code>.<br />
<em>Effects</em>: Swaps <code class="language-cpp">first</code> with <code class="language-cpp">p.first</code> and <code class="language-cpp">second</code> with <code class="language-cpp">p.second</code>.<br />
<em>Remarks</em>: The expression inside noexcept is equivalent to:
<code class="language-cpp">is_nothrow_swappable_v&lt;first_type&gt; &amp;&amp; is_nothrow_swappable_v&lt;second_type&gt;</code>
<pre><code><ins>friend constexpr auto operator&lt;=&gt;(const pair&amp; lhs, const pair&amp; rhs)</ins>
<ins>  -&gt; common_comparison_category_t&lt;<i>synth-3way-type</i>&lt;T1&gt;, <i>synth-3way-type</i>&lt;T2&gt;&gt;;</ins></code></pre>
<ins><em>Effects</em>: Equivalent to:</ins>
<blockquote class="ins"><pre><code>if (auto c = <i>synth-3way</i>(lhs.first, rhs.first); c != 0) return c;
return <i>synth-3way</i>(lhs.second, rhs.second);</code></pre></blockquote>
<ins><em>Remarks</em>:  This function is to be found via argument-dependent lookup only.</ins></p>
</blockquote>
<p>Change 19.4.3 [pairs.spec].</p>
<blockquote>
<p><pre><code><del>template&lt;class T1, class T2&gt;
constexpr bool operator==(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">x.first == y.first &amp;&amp; x.second == y.second</code>.</del>
<pre><code><del>template&lt;class T1, class T2&gt;
constexpr bool operator!=(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">!(x == y)</code>.</del>
<pre><code><del>template&lt;class T1, class T2&gt;
constexpr bool operator&lt;(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">x.first &lt; y.first || (!(y.first &lt; x.first) &amp;&amp; x.second &lt; y.second)</code>.</del>
<pre><code><del>template&lt;class T1, class T2&gt;
constexpr bool operator&gt;(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">y &lt; x</code></del>.
<pre><code><del>template&lt;class T1, class T2&gt;
constexpr bool operator&lt;=(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">!(y &lt; x)</code>.</del>
<pre><code><del>template&lt;class T1, class T2&gt;
constexpr bool operator&gt;=(const pair&lt;T1, T2&gt;&amp; x, const pair&lt;T1, T2&gt;&amp; y);</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">!(x &lt; y)</code>.</del>
<pre><code>template&lt;class T1, class T2&gt;
constexpr void swap(pair&lt;T1, T2&gt;&amp; x, pair&lt;T1, T2&gt;&amp; y) noexcept(noexcept(x.swap(y)));</code></pre>
[...]</p>
</blockquote>
<p>Change 19.5.2 [tuple.syn]:</p>
<blockquote><pre><code>namespace std {
  // 19.5.3, class template tuple
  template&lt;class... Types&gt;
    class tuple;

  [...]  

  template&lt;class T, class... Types&gt;
    constexpr const T&& get(const tuple&lt;Types...&gt;&& t) noexcept;

  <del>// 19.5.3.8, relational operators</del>
  <del>template&lt;class... TTypes, class... UTypes&gt;</del>
    <del>constexpr bool operator==(const tuple&lt;TTypes...&gt;&, const tuple&lt;UTypes...&gt;&);</del>
  <del>template&lt;class... TTypes, class... UTypes&gt;</del>
    <del>constexpr bool operator!=(const tuple&lt;TTypes...&gt;&, const tuple&lt;UTypes...&gt;&);</del>
  <del>template&lt;class... TTypes, class... UTypes&gt;</del>
    <del>constexpr bool operator&lt;(const tuple&lt;TTypes...&gt;&, const tuple&lt;UTypes...&gt;&);</del>
  <del>template&lt;class... TTypes, class... UTypes&gt;</del>
    <del>constexpr bool operator&gt;(const tuple&lt;TTypes...&gt;&, const tuple&lt;UTypes...&gt;&);</del>
  <del>template&lt;class... TTypes, class... UTypes&gt;</del>
    <del>constexpr bool operator&lt;=(const tuple&lt;TTypes...&gt;&, const tuple&lt;UTypes...&gt;&);</del>
  <del>template&lt;class... TTypes, class... UTypes&gt;</del>
    <del>constexpr bool operator&gt;=(const tuple&lt;TTypes...&gt;&, const tuple&lt;UTypes...&gt;&);</del>

  // 19.5.3.9, allocator-related traits
  template&lt;class... Types, class Alloc&gt;
    struct uses_allocator&lt;tuple&lt;Types...&gt;, Alloc&gt;;  

  [...]
}</code></pre></blockquote>

<p>Change 19.5.3 [tuple.tuple]:</p>
<blockquote><pre><code>namespace std {
template<class... Types>
class tuple {
public:
  [...]

  // 19.5.3.3, tuple swap
  constexpr void swap(tuple&) noexcept(see below );

  <ins>// 19.5.3.8, tuple relational operators</ins>
  <ins>template&lt;class... UTypes&gt;</ins>
  <ins>  friend constexpr bool operator==(const tuple&, const tuple&lt;UTypes...&gt;&)</ins>  
  <ins>  { <i>see below</i> }</ins>
  <ins>template&lt;class... UTypes&gt;</ins>
  <ins>  friend constexpr auto operator<=>(const tuple&, const tuple&lt;UTypes...&gt;&)</ins>
  <ins>    -> common_comparison_category_t&lt;<i>synth-3way-type</i>&lt;Types, UTypes&gt;...&gt;</ins>
  <ins>  { <i>see below</i> }</ins>
};</code></pre></blockquote>

<p>Change 19.5.3.8 [tuple.rel]:</p>
<blockquote>
<p><pre><code><del>template&lt;class... TTypes, class... UTypes&gt;
  constexpr bool operator==(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</del></code></pre>
<pre><code><ins>template&lt;class... UTypes&gt;</ins>
<ins>  friend constexpr bool operator==(const tuple&amp;, const tuple&lt;UTypes...&gt;&amp;)</ins></code></pre>
<em>Requires</em>: For all <code class="language-cpp">i</code>, where <code class="language-cpp">0 &lt;= i</code> and <code>i &lt; sizeof...(<del>TTypes</del> <ins>Types</ins>)</code>, <code class="language-cpp">get&lt;i&gt;(t) == get&lt;i&gt;(u)</code> is a well-formed expression returning a type that is convertible to <code class="language-cpp">bool</code>. <code>sizeof...(<del>TTypes</del> <ins>Types</ins>) == sizeof...(UTypes)</code>.<br />
<em>Returns</em>: <code class="language-cpp">true</code> if <code class="language-cpp">get&lt;i&gt;(t) == get&lt;i&gt;(u)</code> for all <code class="language-cpp">i</code>, otherwise <code class="language-cpp">false</code>. For any two zero-length tuples <code class="language-cpp">e</code> and <code class="language-cpp">f</code>, <code class="language-cpp">e == f</code> returns <code class="language-cpp">true</code>.<br />
<em>Effects</em>: The elementary comparisons are performed in order from the zeroth index upwards. No comparisons or element accesses are performed after the first equality comparison that evaluates to <code class="language-cpp">false</code>.<br />
<ins><em>Remarks</em>:  This function is to be found via argument-dependent lookup only.</ins>
<pre><code><del>template&lt;class... TTypes, class... UTypes&gt;<del>
<del>  constexpr bool operator!=(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">!(t == u)</code>.</del>
<pre><code><del>template&lt;class... TTypes, class... UTypes&gt;</del>
<del>constexpr bool operator&lt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</del></code></pre>
<pre><code><ins>template&lt;class... UTypes&gt;</ins>
<ins>  friend constexpr auto operator&lt;=&gt;(const tuple&amp; t, const tuple&lt;UTypes...&gt;&amp; u)</ins>
<ins>    -&gt; common_comparison_category_t&lt;<i>synth-3way-type</i>&lt;Types, UTypes&gt;...&gt;;</ins></code></pre>
<em>Requires</em>: For all <code class="language-cpp">i</code>, where <code class="language-cpp">0 &lt;= i</code> and <code class="language-cpp">i &lt; sizeof...(Types)</code>, <del>both <code class="language-cpp">get&lt;i&gt;(t) &lt; get&lt;i&gt;(u)</code> and <code class="language-cpp">get&lt;i&gt;(u) &lt; get&lt;i&gt;(t)</code> are well-formed expressions returning types that are convertible to <code class="language-cpp">bool</code></del> <ins><code><i>synth-3way</i>(get&lt;i&gt;(t), get&lt;i&gt;(u))</code></ins> is a well-formed expression. <code>sizeof...(<del>TTypes</del> <ins>Types</ins>) == sizeof...(UTypes)</code>.<br />
<del><em>Returns</em>: The result of a lexicographical comparison between <code class="language-cpp">t</code> and <code class="language-cpp">u</code>. The result is defined as:
<code class="language-cpp">(bool)(get&lt;0&gt;(t) &lt; get&lt;0&gt;(u)) || (!(bool)(get&lt;0&gt;(u) &lt; get&lt;0&gt;(t)) &amp;&amp; ttail &lt; utail)</code>, where
<code>r<sub>tail</sub></code> for some tuple <code class="language-cpp">r</code> is a tuple containing all but the first element of <code class="language-cpp">r</code>. For any two zero-length tuples <code class="language-cpp">e</code> and <code class="language-cpp">f</code>, <code class="language-cpp">e &lt; f</code> returns <code class="language-cpp">false</code>.</del><br />
<ins><em>Effects</em>: Performs a lexicographical comparison between <code class="language-cpp">t</code> and <code class="language-cpp">u</code>. Equivalent to:</ins>
<blockquote class="ins"><pre><code>auto c = <i>synth-3way</i>(get&lt;0&gt;(t), get&lt;0&gt;(u));
return (c != 0) ? c : (t<sub>tail</sub> &lt;=&gt; u<sub>tail</sub>);</code></pre></blockquote>
<ins>where <code>r<sub>tail</sub></code> for some tuple <code class="language-cpp">r</code> is a tuple containing all but the first element of <code class="language-cpp">r</code>. For any two zero-length tuples <code class="language-cpp">e</code> and <code class="language-cpp">f</code>, <code class="language-cpp">e &lt;=&gt; f</code> returns <code class="language-cpp">strong_ordering::equal</code>.</ins><br />
<ins><em>Remarks</em>:  This function is to be found via argument-dependent lookup only.</ins>
<pre><code><del>template&lt;class... TTypes, class... UTypes&gt;
constexpr bool operator&gt;(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">u &lt; t</code></del>.
<pre><code><del>template&lt;class... TTypes, class... UTypes&gt;
constexpr bool operator&lt;=(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">!(u &lt; t)</code></del>
<pre><code><del>template&lt;class... TTypes, class... UTypes&gt;
constexpr bool operator&gt;=(const tuple&lt;TTypes...&gt;&amp; t, const tuple&lt;UTypes...&gt;&amp; u);</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">!(t &lt; u)</code></del><br />
<em>[Note:</em> The above definitions for comparison functions do not require <code>t<sub>tail</sub></code> (or <code>u<sub>tail</sub></code>) to be constructed. It may not even be possible, as <code class="language-cpp">t</code> and <code class="language-cpp">u</code> are not required to be copy constructible. Also, all comparison functions are short circuited; they do not perform element accesses beyond what is required to determine the result of the
comparison. <em>โend note]</em></p>
</blockquote>
<p>Change 19.6.2 [optional.syn]:</p>
<blockquote><pre><code>namespace std {
  [...]
  // [optional.relops], relational operators
  template&lt;class T, class U&gt;
    constexpr bool operator==(const optional&lt;T&gt;&, const optional&lt;U&gt;&);
  template&lt;class T, class U&gt;
    constexpr bool operator!=(const optional&lt;T&gt;&, const optional&lt;U&gt;&);
  template&lt;class T, class U&gt;
    constexpr bool operator&lt;(const optional&lt;T&gt;&, const optional&lt;U&gt;&);
  template&lt;class T, class U&gt;
    constexpr bool operator&gt;(const optional&lt;T&gt;&, const optional&lt;U&gt;&);
  template&lt;class T, class U&gt;
    constexpr bool operator&lt;=(const optional&lt;T&gt;&, const optional&lt;U&gt;&);
  template&lt;class T, class U&gt;
    constexpr bool operator&gt;=(const optional&lt;T&gt;&, const optional&lt;U&gt;&);

  <del>// [optional.nullops], comparison with nullopt</del>
  <del>template&lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&, nullopt_t) noexcept;</del>
  <del>template&lt;class T&gt; constexpr bool operator==(nullopt_t, const optional&lt;T&gt;&) noexcept;</del>
  <del>template&lt;class T&gt; constexpr bool operator!=(const optional&lt;T&gt;&, nullopt_t) noexcept;</del>
  <del>template&lt;class T&gt; constexpr bool operator!=(nullopt_t, const optional&lt;T&gt;&) noexcept;</del>
  <del>template&lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&, nullopt_t) noexcept;</del>
  <del>template&lt;class T&gt; constexpr bool operator&lt;(nullopt_t, const optional&lt;T&gt;&) noexcept;</del>
  <del>template&lt;class T&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&, nullopt_t) noexcept;</del>
  <del>template&lt;class T&gt; constexpr bool operator&gt;(nullopt_t, const optional&lt;T&gt;&) noexcept;</del>
  <del>template&lt;class T&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&, nullopt_t) noexcept;</del>
  <del>template&lt;class T&gt; constexpr bool operator&lt;=(nullopt_t, const optional&lt;T&gt;&) noexcept;</del>
  <del>template&lt;class T&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&, nullopt_t) noexcept;</del>
  <del>template&lt;class T&gt; constexpr bool operator&gt;=(nullopt_t, const optional&lt;T&gt;&) noexcept;</del>

  // [optional.comp_with_t], comparison with T
  template&lt;class T, class U&gt; constexpr bool operator==(const optional&lt;T&gt;&, const U&);
  template&lt;class T, class U&gt; constexpr bool operator==(const T&, const optional&lt;U&gt;&);
  template&lt;class T, class U&gt; constexpr bool operator!=(const optional&lt;T&gt;&, const U&);
  template&lt;class T, class U&gt; constexpr bool operator!=(const T&, const optional&lt;U&gt;&);
  [...]
}</code></pre></blockquote>

<p>Change 19.6.3 [optional.optional]:</p>
<blockquote><pre><code>namespace std {
  template&lt;class T&gt;
  class optional {
  public:
    [...]

    // [optional.mod], modifiers
    void reset() noexcept;

    <ins>// [optional.relops], relational operators</ins>
    <ins>template&lt;ThreeWayComparableWith&lt;T&gt; U&gt;</ins>
    <ins>  friend constexpr compare_three_way_result_t&lt;T,U&gt;</ins>
    <ins>    operator&lt;=&gt;(const optional&, const optional&lt;U&gt;&)</ins>
    <ins>    { <i>see below</i> }</ins>

    <ins>// [optional.nullops]</ins>
    <ins>friend constexpr bool operator==(const optional& x, nullopt_t) { return !x; }</ins>
    <ins>friend constexpr strong_ordering operator&lt;=&gt;(const optional& x, nullopt_t) { return bool(x) &lt;=&gt; false; }</ins>

    <ins>// [optional.comp_with_t], comparison with T</ins>
    <ins>template&lt;ThreeWayComparableWith&lt;T&gt; U&gt;</ins>
    <ins>  friend constexpr compare_three_way_result_t&lt;T,U&gt;</ins>
    <ins>    operator&lt;=&gt;(const optional&, const U&)</ins>
    <ins>    { <i>see below</i> }</ins>

  private:
    T *val;         // exposition only
  };
}</code></pre></blockquote>

<p>Change 19.6.6 [optional.relops]:</p>
<blockquote>
<p>[...]
<pre><code>template&lt;class T, class U&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; x, const optional&lt;U&gt;&amp; y);</code></pre>
<em>Requires</em>: The expression <code class="language-cpp">*x &gt;= *y</code> shall be well-formed and its result shall be convertible to <code class="language-cpp">bool</code>.<br />
<em>Returns</em>: If <code class="language-cpp">!y</code>, <code class="language-cpp">true</code>; otherwise, if <code class="language-cpp">!x</code>, <code class="language-cpp">false</code>; otherwise <code class="language-cpp">*x &gt;= *y</code>.<br />
<em>Remarks</em>: Specializations of this function template for which <code class="language-cpp">*x &gt;= *y</code> is a core constant expression shall be <code class="language-cpp">constexpr</code> functions.<br />
<pre><code><ins>template&lt;ThreeWayComparableWith&lt;T&gt; U&gt;</ins>
<ins>  friend constexpr compare_three_way_result_t&lt;T,U&gt;</ins>
<ins>    operator&lt;=&gt;(const optional&amp; x, const optional&lt;U&gt;&amp; y);</ins></code></pre>
<ins><em>Returns</em>: If <code class="language-cpp">x &amp;&amp; y</code>, <code class="language-cpp">*x &lt;=&gt; *y</code>; otherwise <code class="language-cpp">bool(x) &lt;=&gt; bool(y)</code>.</ins><br />
<ins><em>Remarks</em>: Specializations of this function template for which <code class="language-cpp">*x &lt;=&gt; *y</code> is a core constant expression shall be <code class="language-cpp">constexpr</code> functions. This function is to be found via argument-dependent lookup only.</ins></p>
</blockquote>
<p>Change 19.6.7 [optional.nullops]:</p>
<blockquote>
<p><pre><code><del>template&lt;class T&gt; constexpr bool operator==(const optional&lt;T&gt;&amp; x, nullopt_t) noexcept;</del>
<del>template&lt;class T&gt; constexpr bool operator==(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">!x</code>.</del>
<pre><code><del>template&lt;class T&gt; constexpr bool operator!=(const optional&lt;T&gt;&amp; x, nullopt_t) noexcept;
template&lt;class T&gt; constexpr bool operator!=(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">bool(x)</code>.</del>
<pre><code><del>template&lt;class T&gt; constexpr bool operator&lt;(const optional&lt;T&gt;&amp; x, nullopt_t) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">false</code>.</del>
<pre><code><del>template&lt;class T&gt; constexpr bool operator&lt;(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">bool(x)</code>.</del>
<pre><code><del>template&lt;class T&gt; constexpr bool operator&gt;(const optional&lt;T&gt;&amp; x, nullopt_t) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">bool(x)</code>.</del>
<pre><code><del>template&lt;class T&gt; constexpr bool operator&gt;(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">false</code>.</del>
<pre><code><del>template&lt;class T&gt; constexpr bool operator&lt;=(const optional&lt;T&gt;&amp; x, nullopt_t) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">!x</code>.</del>
<pre><code><del>template&lt;class T&gt; constexpr bool operator&lt;=(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">true</code>.</del>
<pre><code><del>template&lt;class T&gt; constexpr bool operator&gt;=(const optional&lt;T&gt;&amp; x, nullopt_t) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">true</code>.</del>
<pre><code><del>template&lt;class T&gt; constexpr bool operator&gt;=(nullopt_t, const optional&lt;T&gt;&amp; x) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">!x</code>.</del></p>
</blockquote>
<p>Change 19.6.8 [optional.comp_with_t]:</p>
<blockquote>
<p>[...]
<pre><code>template&lt;class T, class U&gt; constexpr bool operator&gt;=(const T&amp; v, const optional&lt;U&gt;&amp; x);</code></pre>
<em>Requires</em>: The expression <code class="language-cpp">v &gt;= *x</code> shall be well-formed and its result shall be convertible to <code class="language-cpp">bool</code>.<br />
<em>Effects</em>: Equivalent to: <code class="language-cpp">return bool(x) ? v &gt;= *x : true;</code>
<pre><code><ins>template&lt;ThreeWayComparableWith&lt;T&gt; U&gt;</ins>
<ins>  friend constexpr compare_three_way_result_t&lt;T,U&gt;</ins>
<ins>    operator&lt;=&gt;(const optional&amp; x, const U&amp; v);</ins></code></pre>
<ins><em>Effects</em>: Equivalent to: <code class="language-cpp">return bool(x) ? *x &lt;=&gt; v : strong_ordering::less;</code></ins><br />
<ins><em>Remarks</em>: This function is to be found via argument-dependent lookup only.</ins></p>
</blockquote>
<p>Change 19.7.2 [variant.syn]:</p>
<blockquote><pre><code>namespace std {
  [...]
  // [variant.monostate], class monostate
  struct monostate;

  // [variant.monostate.relops], monostate relational operators
  constexpr bool operator==(monostate, monostate) noexcept;
  <del>constexpr bool operator!=(monostate, monostate) noexcept;</del>
  <del>constexpr bool operator<(monostate, monostate) noexcept;</del>
  <del>constexpr bool operator>(monostate, monostate) noexcept;</del>
  <del>constexpr bool operator<=(monostate, monostate) noexcept;</del>
  <del>constexpr bool operator>=(monostate, monostate) noexcept;</del>
  <ins>constexpr strong_ordering operator<=>(monostate, monostate) noexcept;</ins>

  // [variant.specalg], specialized algorithms
  template&lt;class... Types&gt;
    void swap(variant&lt;Types...&gt;&, variant&lt;Types...&gt;&) noexcept(<i>see below</i>);
  [...]
}</code></pre></blockquote>

<p>Change 19.7.3 [variant.variant]:</p>
<blockquote><pre><code>namespace std {
  template&lt;class... Types&gt;
  class variant {
  public:
    [...]

    // [variant.swap], swap
    void swap(variant&) noexcept(see below);

    <ins>// [variant.relops], relational operators</ins>
    <ins>friend constexpr common_comparison_category_t&lt;compare_three_way_result_t&lt;Types&gt;...&gt;</ins>
    <ins>  operator&lt;=&gt;(const variant&, const variant&)</ins>
    <ins>    requires (ThreeWayComparable&lt;Types&gt; && ...)</ins>
    <ins>    { <i>see below</i> }</ins>
  };
}</code></pre></blockquote>

<p>Insert at the end of 19.7.6 [variant.relops]:</p>
<blockquote>
<p><pre><code><ins>constexpr common_comparison_category_t&lt;compare_three_way_result_t&lt;Types&gt;...&gt;</ins>
<ins>  friend operator&lt;=&gt;(const variant&amp; v, const variant&amp; w)</ins>
<ins>    requires (ThreeWayComparable&lt;Types&gt; &amp;&amp; ...);</ins></code></pre>
<ins><em>Returns</em>: Let <code class="language-cpp">c</code> be <code class="language-cpp">(v.index() + 1) &lt;=&gt; (w.index() + 1)</code>. If <code class="language-cpp">c != 0</code>, <code class="language-cpp">c</code>. Otherwise, <code class="language-cpp">get&lt;i&gt;(v) &lt;=&gt; get&lt;i&gt;(w)</code> with <code class="language-cpp">i</code> being <code class="language-cpp">v.index()</code>.</ins><br />
<ins><em>Remarks</em>: This function is to be found via argument-dependent lookup only.</ins></p>
</blockquote>
<p>Change 19.7.9 [variant.monostate.relops]:</p>
<blockquote><pre><code>constexpr bool operator==(monostate, monostate) noexcept { return true; }
<del>constexpr bool operator!=(monostate, monostate) noexcept { return false; }</del>
<del>constexpr bool operator<(monostate, monostate) noexcept { return false; }</del>
<del>constexpr bool operator>(monostate, monostate) noexcept { return false; }</del>
<del>constexpr bool operator<=(monostate, monostate) noexcept { return true; }</del>
<del>constexpr bool operator>=(monostate, monostate) noexcept { return true; }</del>
<ins>constexpr strong_ordering operator<=>(monostate, monostate) noexcept { return strong_ordering::equal; }</ins></code></pre>

[<i>Note</i>: monostate objects have only a single state; they thus always compare equal. โ<i>end note</i>]</blockquote>

<p>Change 19.9.2 [template.bitset]:</p>
<blockquote><pre><code>namespace std {
  template&lt;size_t N&gt; class bitset {
  public:
    [...]
    constexpr size_t size() const noexcept;
    bool operator==(const bitset&lt;N&gt;& rhs) const noexcept;
    <del>bool operator!=(const bitset&lt;N&gt;& rhs) const noexcept;</del>
    bool test(size_t pos) const;
    [...]
  };
}</code></pre></blockquote>

<p>Change 19.9.2.2 [bitset.members]:</p>
<blockquote>
<p><pre><code>bool operator==(const bitset&lt;N&gt;&amp; rhs) const noexcept;</code></pre>
<em>Returns</em>: <code class="language-cpp">true</code> if the value of each bit in <code class="language-cpp">*this</code> equals the value of the corresponding bit in <code class="language-cpp">rhs</code>.
<del><pre><code>bool operator!=(const bitset&lt;N&gt;&amp; rhs) const noexcept;</code></pre></del>
<del><em>Returns</em>: <code class="language-cpp">true</code> if <code class="language-cpp">!(*this == rhs)</code>.</del></blockquote></p>
</blockquote>
<p>Change 19.10.2 [memory.syn]:</p>
<blockquote><pre><code>namespace std {
  [...]
  // [default.allocator], the default allocator
  template&lt;class T&gt; class allocator;
  template&lt;class T, class U&gt;
    bool operator==(const allocator&lt;T&gt;&, const allocator&lt;U&gt;&) noexcept;
  <del>template&lt;class T, class U&gt;</del>
    <del>bool operator!=(const allocator&lt;T&gt;&, const allocator&lt;U&gt;&) noexcept;</del>
  [...]
  template&lt;class T, class D&gt; 
    void swap(unique_ptr&lt;T, D&gt;& x, unique_ptr&lt;T, D&gt;& y) noexcept;

<del>  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator==(const unique_ptr&lt;T1, D1&gt;& x, const unique_ptr&lt;T2, D2&gt;& y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator!=(const unique_ptr&lt;T1, D1&gt;& x, const unique_ptr&lt;T2, D2&gt;& y);</del>
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator&lt;(const unique_ptr&lt;T1, D1&gt;& x, const unique_ptr&lt;T2, D2&gt;& y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator&gt;(const unique_ptr&lt;T1, D1&gt;& x, const unique_ptr&lt;T2, D2&gt;& y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;& x, const unique_ptr&lt;T2, D2&gt;& y);
  template&lt;class T1, class D1, class T2, class D2&gt;
    bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;& x, const unique_ptr&lt;T2, D2&gt;& y);

<del>  template&lt;class T, class D&gt;
    bool operator==(const unique_ptr&lt;T, D&gt;& x, nullptr_t) noexcept;
  template&lt;class T, class D&gt;
    bool operator==(nullptr_t, const unique_ptr&lt;T, D&gt;& y) noexcept;
  template&lt;class T, class D&gt;
    bool operator!=(const unique_ptr&lt;T, D&gt;& x, nullptr_t) noexcept;
  template&lt;class T, class D&gt;
    bool operator!=(nullptr_t, const unique_ptr&lt;T, D&gt;& y) noexcept;</del>
  template&lt;class T, class D&gt;
    bool operator&lt;(const unique_ptr&lt;T, D&gt;& x, nullptr_t);
  template&lt;class T, class D&gt;
    bool operator&lt;(nullptr_t, const unique_ptr&lt;T, D&gt;& y);
  template&lt;class T, class D&gt;
    bool operator&gt;(const unique_ptr&lt;T, D&gt;& x, nullptr_t);
  template&lt;class T, class D&gt;
    bool operator&gt;(nullptr_t, const unique_ptr&lt;T, D&gt;& y);
  template&lt;class T, class D&gt;
    bool operator&lt;=(const unique_ptr&lt;T, D&gt;& x, nullptr_t);
  template&lt;class T, class D&gt;
    bool operator&lt;=(nullptr_t, const unique_ptr&lt;T, D&gt;& y);
  template&lt;class T, class D&gt;
    bool operator&gt;=(const unique_ptr&lt;T, D&gt;& x, nullptr_t);
  template&lt;class T, class D&gt;
    bool operator&gt;=(nullptr_t, const unique_ptr&lt;T, D&gt;& y);

  template&lt;class E, class T, class Y, class D&gt;
    basic_ostream&lt;E, T&gt;& operator&lt;&lt;(basic_ostream&lt;E, T&gt;& os, const unique_ptr&lt;Y, D&gt;& p);  
  [...]
  <del>// [util.smartptr.shared.cmp], shared_ptr comparisons</del>
<del>  template&lt;class T, class U&gt;
    bool operator==(const shared_ptr&lt;T&gt;& a, const shared_ptr&lt;U&gt;& b) noexcept;
  template&lt;class T, class U&gt;
    bool operator!=(const shared_ptr&lt;T&gt;& a, const shared_ptr&lt;U&gt;& b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&lt;(const shared_ptr&lt;T&gt;& a, const shared_ptr&lt;U&gt;& b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&gt;(const shared_ptr&lt;T&gt;& a, const shared_ptr&lt;U&gt;& b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&lt;=(const shared_ptr&lt;T&gt;& a, const shared_ptr&lt;U&gt;& b) noexcept;
  template&lt;class T, class U&gt;
    bool operator&gt;=(const shared_ptr&lt;T&gt;& a, const shared_ptr&lt;U&gt;& b) noexcept;

  template&lt;class T&gt;
    bool operator==(const shared_ptr&lt;T&gt;& x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator==(nullptr_t, const shared_ptr&lt;T&gt;& y) noexcept;
  template&lt;class T&gt;
    bool operator!=(const shared_ptr&lt;T&gt;& x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator!=(nullptr_t, const shared_ptr&lt;T&gt;& y) noexcept;
  template&lt;class T&gt;
    bool operator&lt;(const shared_ptr&lt;T&gt;& x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator&lt;(nullptr_t, const shared_ptr&lt;T&gt;& y) noexcept;
  template&lt;class T&gt;
    bool operator&gt;(const shared_ptr&lt;T&gt;& x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator&gt;(nullptr_t, const shared_ptr&lt;T&gt;& y) noexcept;
  template&lt;class T&gt;
    bool operator&lt;=(const shared_ptr&lt;T&gt;& x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator&lt;=(nullptr_t, const shared_ptr&lt;T&gt;& y) noexcept;
  template&lt;class T&gt;
    bool operator&gt;=(const shared_ptr&lt;T&gt;& x, nullptr_t) noexcept;
  template&lt;class T&gt;
    bool operator&gt;=(nullptr_t, const shared_ptr&lt;T&gt;& y) noexcept;</del>

  // [util.smartptr.shared.spec], shared_ยญptr specialized algorithms
  template&lt;class T&gt;
    void swap(shared_ptr&lt;T&gt;& a, shared_ptr&lt;T&gt;& b) noexcept;
  [...]    
}</code></pre></blockquote>

<p>Change 19.10.10.2 [allocator.globals]:</p>
<blockquote>
<p><pre><code>template&lt;class T, class U&gt;
  bool operator==(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;</code></pre>
<em>Returns</em>: <code class="language-cpp">true</code>.
<del><pre><code>template&lt;class T, class U&gt;
  bool operator!=(const allocator&lt;T&gt;&amp;, const allocator&lt;U&gt;&amp;) noexcept;</code></pre></del>
<del><em>Returns</em>: <code class="language-cpp">false</code>.</del></p>
</blockquote>
<p>Change 19.11.1.2 [unique.ptr.single]:</p>
<blockquote><pre><code>namespace std {
  template&lt;class T, class D = default_delete&lt;T&gt;&gt; class unique_ptr {
  public:
    using pointer      = <i>see below</i>;
    using element_type = T;
    using deleter_type = D;
    [...]
    // disable copy from lvalue
    unique_ptr(const unique_ptr&) = delete;
    unique_ptr& operator=(const unique_ptr&) = delete;

    <ins>template&lt;class T2, class D2&gt;</ins>
      <ins>friend bool operator==(const unique_ptr& x, const unique_ptr&lt;T2, D2&gt;& y) { return x.get() == y.get(); }</ins>
    <ins>template&lt;class T2, class D2&gt;</ins>
      <ins>  requires ThreeWayComparableWith&lt;pointer, typename unique_ptr&lt;T2, D2&gt;::pointer&gt;</ins>
      <ins>friend auto operator&lt;=&gt;(const unique_ptr& x, const unique_ptr&lt;T2, D2&gt;& y)</ins>  
      <ins>{ return compare_three_way()(x.get(), y.get()); }</ins>

    <ins>friend bool operator==(const unique_ptr& x, nullptr_t) noexcept { return !x; }</ins>
    <ins>friend auto operator&lt;=&gt;(const unique_ptr& x, nullptr_t)</ins>
    <ins>  requires ThreeWayComparableWith&lt;pointer, nullptr_t&gt;</ins>
    <ins>  { return compare_three_way()(x.get(), nullptr); }</ins>
  };
}</code></pre></blockquote>

<p>Change 19.11.1.5 [unique.ptr.special]:</p>
<blockquote>
<p><pre><code>template&lt;class T, class D&gt; void swap(unique_ptr&lt;T, D&gt;&amp; x, unique_ptr&lt;T, D&gt;&amp; y) noexcept;</code></pre>
<em>Remarks</em>: This function shall not participate in overload resolution unless <code class="language-cpp">is_swappable_v&lt;D&gt;</code> is <code class="language-cpp">true</code>.
<em>Effects</em>: Calls <code class="language-cpp">x.swap(y)</code>.
<pre><code><del>template&lt;class T1, class D1, class T2, class D2&gt;</del>
  <del>bool operator==(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">x.get() == y.get()</code>.</del>
<pre><code><del>template&lt;class T1, class D1, class T2, class D2&gt;
  bool operator!=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">x.get() != y.get()</code>.</del>
<pre><code>template&lt;class T1, class D1, class T2, class D2&gt;
  bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);</code></pre>
<em>Requires</em>: Let <code class="language-cpp">CT</code> denote <code class="language-cpp">common_type_t&lt;typename unique_ptr&lt;T1, D1&gt;::pointer, typename unique_ptr&lt;T2, D2&gt;::pointer&gt;</code> Then the specialization <code class="language-cpp">less&lt;CT&gt;</code> shall be a function object type that induces a strict weak ordering on the pointer values.<br />
<em>Returns</em>: <code class="language-cpp">less&lt;CT&gt;()(x.get(), y.get())</code>.<br />
<em>Remarks</em>: If <code class="language-cpp">unique_ptr&lt;T1, D1&gt;::pointer</code> is not implicitly convertible to <code class="language-cpp">CT</code> or <code class="language-cpp">unique_ptr&lt;T2, D2&gt;::pointer</code> is not implicitly convertible to <code class="language-cpp">CT</code>, the program is ill-formed.<br />
[...]</p>
</blockquote>
<p>Change 19.11.3, [util.smartptr.shared]:</p>
<blockquote><pre><code>namespace std {
  template&lt;class T&gt; class shared_ptr {
    [...]
    // [util.smartptr.shared.obs], observers
    element_type* get() const noexcept;
    T& operator*() const noexcept;
    T* operator-&gt;() const noexcept;
    element_type& operator[](ptrdiff_t i) const;
    long use_count() const noexcept;
    explicit operator bool() const noexcept;
    template&lt;class U&gt;
      bool owner_before(const shared_ptr&lt;U&gt;& b) const noexcept;
    template&lt;class U&gt;
      bool owner_before(const weak_ptr&lt;U&gt;& b) const noexcept;

    <ins>// [util.smartptr.shared.cmp], shared_ptr comparisons</ins>
    <ins>template&lt;class U&gt;</ins>
      <ins>friend bool operator==(const shared_ptr& a, const shared_ptr&lt;U&gt;& b) noexcept</ins>
      <ins>{ return a.get() == b.get(); }</ins>
    <ins>template&lt;class U&gt;</ins>
      <ins>friend strong_ordering operator&lt;=&gt;(const shared_ptr& a, const shared_ptr&lt;U&gt;& b) noexcept</ins>
      <ins>{ return compare_three_way()(a.get(), b.get()); }</ins>

    <ins>friend bool operator==(const shared_ptr& a, nullptr_t) noexcept { return !a; }</ins>
    <ins>friend strong_ordering operator&lt;=&gt;(const shared_ptr& a, nullptr_t) noexcept</ins>
    <ins>  { return compare_three_way()(a.get(), nullptr); }</ins>
  };
}</code></pre></blockquote>

<p>Remove all of 19.11.3.7 [util.smartptr.shared.cmp]:</p>
<blockquote>
<p><pre><code><del>template&lt;class T, class U&gt;</del>
<del>  bool operator==(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">a.get() == b.get()</code>.</del>
<pre><code><del>template&lt;class T, class U&gt;
  bool operator&lt;(const shared_ptr&lt;T&gt;&amp; a, const shared_ptr&lt;U&gt;&amp; b) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">less&lt;&gt;()(a.get(), b.get())</code>.</del><br />
[...]</p>
</blockquote>
<p>Change 19.12.1 [mem.res.syn]:</p>
<blockquote><pre><code>namespace std::pmr {
  // [mem.res.class], class memory_ยญresource
  class memory_resource;

  bool operator==(const memory_resource& a, const memory_resource& b) noexcept;
  <del>bool operator!=(const memory_resource& a, const memory_resource& b) noexcept;</del>

  // [mem.poly.allocator.class], class template polymorphic_ยญallocator
  template&lt;class Tp&gt; class polymorphic_allocator;

  template&lt;class T1, class T2&gt;
    bool operator==(const polymorphic_allocator&lt;T1&gt;& a,
                    const polymorphic_allocator&lt;T2&gt;& b) noexcept;
  <del>template&lt;class T1, class T2&gt;</del>
  <del>  bool operator!=(const polymorphic_allocator&lt;T1&gt;& a,</del>
  <del>                  const polymorphic_allocator&lt;T2&gt;& b) noexcept;</del>

  // [mem.res.global], global memory resources
  memory_resource* new_delete_resource() noexcept;
  [...]
}</code></pre></blockquote>

<p>Change 19.12.2.3 [mem.res.eq]:</p>
<blockquote>
<p><pre><code>bool operator==(const memory_resource&amp; a, const memory_resource&amp; b) noexcept;</code></pre>
<em>Returns</em>: <code class="language-cpp">&amp;a == &amp;b || a.is_equal(b)</code>.
<pre><code><del>bool operator!=(const memory_resource&amp; a, const memory_resource&amp; b) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">!(a == b)</code>.</del></p>
</blockquote>
<p>Change 19.12.3.3 [mem.poly.allocator.eq]:</p>
<blockquote>
<p><pre><code>template&lt;class T1, class T2&gt;
  bool operator==(const polymorphic_allocator&lt;T1&gt;&amp; a,
                  const polymorphic_allocator&lt;T2&gt;&amp; b) noexcept;</code></pre>
<em>Returns</em>: <code class="language-cpp">*a.resource() == *b.resource()</code>.
<pre><code><del>template&lt;class T1, class T2&gt;</del>
<del>  bool operator!=(const polymorphic_allocator&lt;T1&gt;&amp; a,</del>
<del>                  const polymorphic_allocator&lt;T2&gt;&amp; b) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">!(a == b)</code>.</del></p>
</blockquote>
<p>Change 19.13.1 [allocator.adaptor.syn]:</p>
<blockquote><pre><code>namespace std {
  // class template scoped allocator adaptor
  template&lt;class OuterAlloc, class... InnerAlloc&gt;
    class scoped_allocator_adaptor;

  // [scoped.adaptor.operators], scoped allocator operators
  template&lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
    bool operator==(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;& a,
                    const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;& b) noexcept;
  <del>template&lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;</del>
  <del>  bool operator!=(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;& a,</del>
  <del>                  const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;& b) noexcept;</del>
}</code></pre></blockquote>

<p>Change 19.13.5 [scoped.adaptor.operators]:</p>
<blockquote>
<p><pre><code>template&lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;
  bool operator==(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,
                  const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;</code></pre>
<em>Returns</em>: If <code class="language-cpp">sizeof...(InnerAllocs)</code> is zero,<br />
<code class="language-cpp">a.outer_allocator() == b.outer_allocator()</code><br />
otherwise<br />
<code class="language-cpp">a.outer_allocator() == b.outer_allocator() &amp;&amp; a.inner_allocator() == b.inner_allocator()</code>
<pre><code><del>template&lt;class OuterA1, class OuterA2, class... InnerAllocs&gt;</del>
<del>  bool operator!=(const scoped_allocator_adaptor&lt;OuterA1, InnerAllocs...&gt;&amp; a,</del>
<del>                  const scoped_allocator_adaptor&lt;OuterA2, InnerAllocs...&gt;&amp; b) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">!(a == b)</code>.</del></p>
</blockquote>
<p>Change 19.14.1 [functional.syn]</p>
<blockquote><pre><code>namespace std {
  [...]
  template&lt;class R, class... ArgTypes&gt;
    bool operator==(const function&lt;R(ArgTypes...)&gt;&, nullptr_t) noexcept;
  <del>template&lt;class R, class... ArgTypes&gt;</del>
  <del>  bool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&) noexcept;</del>
  <del>template&lt;class R, class... ArgTypes&gt;</del>
  <del>  bool operator!=(const function&lt;R(ArgTypes...)&gt;&, nullptr_t) noexcept;</del>
  <del>template&lt;class R, class... ArgTypes&gt;</del>
  <del>  bool operator!=(nullptr_t, const function&lt;R(ArgTypes...)&gt;&) noexcept;</del>

  // [func.search], searchers
  [...]
}</code></pre></blockquote>

<p>Change 19.14.16.2 [func.wrap.func]:</p>
<blockquote><pre><code>namespace std {
  template&lt;class&gt; class function; // not defined
  [...]
  // [func.wrap.func.nullptr], Null pointer comparisons
  template&lt;class R, class... ArgTypes&gt;
    bool operator==(const function&lt;R(ArgTypes...)&gt;&, nullptr_t) noexcept;

  <del>template&lt;class R, class... ArgTypes&gt;</del>
  <del>  bool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&) noexcept;</del>

  <del>template&lt;class R, class... ArgTypes&gt;</del>
  <del>  bool operator!=(const function&lt;R(ArgTypes...)&gt;&, nullptr_t) noexcept;</del>

  <del>template&lt;class R, class... ArgTypes&gt;</del>
  <del>  bool operator!=(nullptr_t, const function&lt;R(ArgTypes...)&gt;&) noexcept;</del>
  [...]
}</code></pre></blockquote>

<p>Change 19.14.16.2.6 [func.wrap.func.nullptr]:</p>
<blockquote>
<p><pre><code>template&lt;class R, class... ArgTypes&gt;
  bool operator==(const function&lt;R(ArgTypes...)&gt;&amp; f, nullptr_t) noexcept;
<del>template&lt;class R, class... ArgTypes&gt;</del>
<del>  bool operator==(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp; f) noexcept;</del></code></pre>
<em>Returns</em>: <code class="language-cpp">!f</code>.</p>
<p><pre><code><del>template&lt;class R, class... ArgTypes&gt;</del>
<del>  bool operator!=(const function&lt;R(ArgTypes...)&gt;&amp; f, nullptr_t) noexcept;</del>
<del>template&lt;class R, class... ArgTypes&gt;</del>
<del>  bool operator!=(nullptr_t, const function&lt;R(ArgTypes...)&gt;&amp; f) noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">(bool)f</code>.</del></p>
</blockquote>
<p>Change 19.17.2 [type.index.overview]. Note that the relational operators on <code class="language-cpp">type_index</code> are based on <code class="language-cpp">type_info::before</code> (effectively <code class="language-cpp">&lt;</code>). <code class="language-cpp">type_info</code> <em>could</em> provide a three-way ordering function, but does not. Since an important motivation for the existence of <code class="language-cpp">type_index</code> is to be used as a key in an associative container, we do not want to pessimize <code class="language-cpp">&lt;</code> - but do want to provide <code class="language-cpp">&lt;=&gt;</code>.</p>
<blockquote><pre><code>namespace std {
  class type_index {
  public:
    type_index(const type_info& rhs) noexcept;
    bool operator==(const type_index& rhs) const noexcept;
    <del>bool operator!=(const type_index& rhs) const noexcept;</del>
    bool operator&lt; (const type_index& rhs) const noexcept;
    bool operator&gt; (const type_index& rhs) const noexcept;
    bool operator&lt;= (const type_index& rhs) const noexcept;
    bool operator&gt;= (const type_index& rhs) const noexcept;
    <ins>strong_ordering operator&lt;=&gt;(const type_index& rhs) const noexcept;</ins>
    size_t hash_code() const noexcept;
    const char* name() const noexcept;

  private:
    const type_info* target;    // exposition only
    // Note that the use of a pointer here, rather than a reference,
    // means that the default copy/move constructor and assignment
    // operators will be provided and work as expected.
  };
}</code></pre></blockquote>

<p>Change 19.17.3 [type.index.members]:</p>
<blockquote>
<p><pre><code>type_index(const type_info&amp; rhs) noexcept;</code></pre>
<em>Effects</em>: Constructs a <code class="language-cpp">type_index</code> object, the equivalent of <code class="language-cpp">target = &amp;rhs</code>.
<pre><code>bool operator==(const type_index&amp; rhs) const noexcept;</code></pre>
<em>Returns</em>: <code class="language-cpp">*target == *rhs.target</code>.
<pre><code><del>bool operator!=(const type_index&amp; rhs) const noexcept;</del></code></pre>
<del><em>Returns</em>: <code class="language-cpp">*target != *rhs.target</code>.</del>
<pre><code>bool operator&lt;(const type_index&amp; rhs) const noexcept;</code></pre>
<em>Returns</em>: <code class="language-cpp">target-&gt;before(*rhs.target)</code>.
<pre><code>bool operator&gt;(const type_index&amp; rhs) const noexcept;</code></pre>
<em>Returns</em>: <code class="language-cpp">rhs.target-&gt;before(*target)</code>.
<pre><code>bool operator&lt;=(const type_index&amp; rhs) const noexcept;</code></pre>
<em>Returns</em>: <code class="language-cpp">!rhs.target-&gt;before(*target)</code>.
<pre><code>bool operator&gt;=(const type_index&amp; rhs) const noexcept;</code></pre>
<em>Returns</em>: <code class="language-cpp">!target-&gt;before(*rhs.target)</code>.
<pre><code><ins>strong_ordering operator&lt;=&gt;(const type_index&amp; rhs) const noexcept;</ins></code></pre>
<ins><em>Effects</em>: Equivalent to</ins>
<blockquote class="ins"><pre><code>if (*target == *rhs.target) return strong_ordering::equal;
if (target-&gt;before(*rhs.target)) return strong_ordering::less;
return strong_ordering::greater;</code></pre></blockquote>
<pre><code>size_t hash_code() const noexcept;</code></pre>
<em>Returns</em>: <code class="language-cpp">target-&gt;hash_code()</code>.
[...]</p>
</blockquote>
<h3 id="clause-20-strings-library">3.6. Clause 20: Strings library<a class="self-link" href="#clause-20-strings-library"></a></h3>
<p>Changing the operators for <code class="language-cpp">basic_string</code> and <code class="language-cpp">basic_string_view</code> and adding extra type alises to the <code class="language-cpp">char_traits</code> specializations provided by the standard.</p>
<p>Change 20.2.3.1 [char.traits.specializations.char]:</p>
<blockquote><pre><code>namespace std {
  template&lt;&gt; struct char_traits&lt;char&gt; {
    using char_type  = char;
    using int_type   = int;
    using off_type   = streamoff;
    using pos_type   = streampos;
    using state_type = mbstate_t;
    <ins>using comparison_category = strong_ordering;</ins>
    [...]
  };
}</code></pre></blockquote>

<p>Change 20.2.3.2 [char.traits.specializations.char8_t]:</p>
<blockquote><pre><code>namespace std {
  template&lt;&gt; struct char_traits&lt;char8_t&gt; {
    using char_type = char8_t;
    using int_type = unsigned int;
    using off_type = streamoff;
    using pos_type = u8streampos;
    using state_type = mbstate_t;
    <ins>using comparison_category = strong_ordering;</ins>
    [...]
  };
}</code></pre></blockquote>

<p>Change 20.2.3.3 [char.traits.specializations.char16_t]:</p>
<blockquote><pre><code>namespace std {
  template&lt;&gt; struct char_traits&lt;char16_t&gt; {
    using char_type  = char16_t;
    using int_type   = uint_least16_t;
    using off_type   = streamoff;
    using pos_type   = u16streampos;
    using state_type = mbstate_t;
    <ins>using comparison_category = strong_ordering;</ins>
    [...]
  };
}</code></pre></blockquote>

<p>Change 20.2.3.4 [char.traits.specializations.char32_t]</p>
<blockquote><pre><code>namespace std {
  template&lt;&gt; struct char_traits&lt;char32_t&gt; {
    using char_type  = char32_t;
    using int_type   = uint_least32_t;
    using off_type   = streamoff;
    using pos_type   = u32streampos;
    using state_type = mbstate_t;
    <ins>using comparison_category = strong_ordering;</ins>
    [...]
  };
}</code></pre></blockquote>

<p>Change 20.2.3.5 [char.traits.specializations.wchar.t]</p>
<blockquote><pre><code>namespace std {
  template&lt;&gt; struct char_traits&lt;wchar_t&gt; {
    using char_type  = wchar_t;
    using int_type   = wint_t;
    using off_type   = streamoff;
    using pos_type   = wstreampos;
    using state_type = mbstate_t;
    <ins>using comparison_category = strong_ordering;</ins>
    [...]
  };
}</code></pre></blockquote>

<p>Change 20.3.1 [string.syn]:</p>
<blockquote><pre><code>#include &lt;initializer_list&gt;

namespace std {
  [...]
<del>  template&lt;class charT, class traits, class Allocator&gt;
    bool operator==(const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                    const basic_string&lt;charT, traits, Allocator&gt;& rhs) noexcept;
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator==(const charT* lhs,
                    const basic_string&lt;charT, traits, Allocator&gt;& rhs);
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator==(const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                    const charT* rhs);
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator!=(const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                    const basic_string&lt;charT, traits, Allocator&gt;& rhs) noexcept;
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator!=(const charT* lhs,
                    const basic_string&lt;charT, traits, Allocator&gt;& rhs);
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator!=(const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                    const charT* rhs);

  template&lt;class charT, class traits, class Allocator&gt;
    bool operator&lt; (const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                    const basic_string&lt;charT, traits, Allocator&gt;& rhs) noexcept;
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator&lt; (const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                    const charT* rhs);
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator&lt; (const charT* lhs,
                    const basic_string&lt;charT, traits, Allocator&gt;& rhs);
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator&gt; (const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                    const basic_string&lt;charT, traits, Allocator&gt;& rhs) noexcept;
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator&gt; (const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                    const charT* rhs);
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator&gt; (const charT* lhs,
                    const basic_string&lt;charT, traits, Allocator&gt;& rhs);

  template&lt;class charT, class traits, class Allocator&gt;
    bool operator&lt;=(const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                    const basic_string&lt;charT, traits, Allocator&gt;& rhs) noexcept;
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator&lt;=(const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                    const charT* rhs);
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator&lt;=(const charT* lhs,
                    const basic_string&lt;charT, traits, Allocator&gt;& rhs);
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator&gt;=(const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                    const basic_string&lt;charT, traits, Allocator&gt;& rhs) noexcept;
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator&gt;=(const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                    const charT* rhs);
  template&lt;class charT, class traits, class Allocator&gt;
    bool operator&gt;=(const charT* lhs,
                    const basic_string&lt;charT, traits, Allocator&gt;& rhs);</del>
  [...]
}</code></pre></blockquote>

<p>Change 20.3.2 [basic.string]/3. Insert wherever the editor deems appropriate:</p>
<blockquote><pre><code>namespace std {
  template&lt;class charT, class traits = char_traits&lt;charT&gt;,
           class Allocator = allocator&lt;charT&gt;&gt;
  class basic_string {
    [...]
    <ins>friend bool operator==(const basic_string& lhs, const basic_string& rhs) { <i>see below</i> }</ins>
    <ins>friend bool operator==(const basic_string& lhs, const charT* rhs) { <i>see below</i> }</ins>
    <ins>friend <i>see below</i> operator&lt;=&gt;(const basic_string& lhs, const basic_string& rhs) { <i>see below</i> }</ins>
    <ins>friend <i>see below</i> operator&lt;=&gt;(const basic_string& lhs, const charT* rhs) { <i>see below</i> }</ins>
    [...]
  };
}</code></pre></blockquote>

<p>Change 20.3.3.2 [string.cmp].</p>
<blockquote><pre><code><del>template&lt;class charT, class traits, class Allocator&gt;
  bool operator==(const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                  const basic_string&lt;charT, traits, Allocator&gt;& rhs) noexcept;
template&lt;class charT, class traits, class Allocator&gt;
  bool operator==(const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;& rhs);
template&lt;class charT, class traits, class Allocator&gt;
  bool operator==(const basic_string&lt;charT, traits, Allocator&gt;& lhs, const charT* rhs);</del>

<ins>friend bool operator==(const basic_string& lhs, const basic_string& rhs);</ins>
<ins>friend bool operator==(const basic_string& lhs, const charT* rhs);</ins>

<del>template&lt;class charT, class traits, class Allocator&gt;
  bool operator!=(const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                  const basic_string&lt;charT, traits, Allocator&gt;& rhs) noexcept;
template&lt;class charT, class traits, class Allocator&gt;
  bool operator!=(const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;& rhs);
template&lt;class charT, class traits, class Allocator&gt;
  bool operator!=(const basic_string&lt;charT, traits, Allocator&gt;& lhs, const charT* rhs);</code></pre></blockquote>

<blockquote>
<p><ins><em>Effects</em>: Equivalent to <code class="language-cpp">return basic_string_view&lt;charT, traits&gt;(lhs) == basic_string_view&lt;charT, traits&gt;(rhs);</code></ins><br />
<ins><em>Remarks</em>: This function is to be found via argument-dependent lookup only.</ins></p>
</blockquote>
<blockquote><pre><code><del>template&lt;class charT, class traits, class Allocator&gt;
  bool operator&lt; (const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                  const basic_string&lt;charT, traits, Allocator&gt;& rhs) noexcept;
template&lt;class charT, class traits, class Allocator&gt;
  bool operator&lt; (const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;& rhs);
template&lt;class charT, class traits, class Allocator&gt;
  bool operator&lt; (const basic_string&lt;charT, traits, Allocator&gt;& lhs, const charT* rhs);

template&lt;class charT, class traits, class Allocator&gt;
  bool operator&gt; (const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                  const basic_string&lt;charT, traits, Allocator&gt;& rhs) noexcept;
template&lt;class charT, class traits, class Allocator&gt;
  bool operator&gt; (const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;& rhs);
template&lt;class charT, class traits, class Allocator&gt;
  bool operator&gt; (const basic_string&lt;charT, traits, Allocator&gt;& lhs, const charT* rhs);

template&lt;class charT, class traits, class Allocator&gt;
  bool operator&lt;=(const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                  const basic_string&lt;charT, traits, Allocator&gt;& rhs) noexcept;
template&lt;class charT, class traits, class Allocator&gt;
  bool operator&lt;=(const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;& rhs);
template&lt;class charT, class traits, class Allocator&gt;
  bool operator&lt;=(const basic_string&lt;charT, traits, Allocator&gt;& lhs, const charT* rhs);

template&lt;class charT, class traits, class Allocator&gt;
  bool operator&gt;=(const basic_string&lt;charT, traits, Allocator&gt;& lhs,
                  const basic_string&lt;charT, traits, Allocator&gt;& rhs) noexcept;
template&lt;class charT, class traits, class Allocator&gt;
  bool operator&gt;=(const charT* lhs, const basic_string&lt;charT, traits, Allocator&gt;& rhs);
template&lt;class charT, class traits, class Allocator&gt;
  bool operator&gt;=(const basic_string&lt;charT, traits, Allocator&gt;& lhs, const charT* rhs);</del>

<ins>friend <i>see below</i> operator&lt;=&gt;(const basic_string& lhs, const basic_string& rhs);</ins>  
<ins>friend <i>see below</i> operator&lt;=&gt;(const basic_string& lhs, const charT* rhs);</ins>  
</code></pre></blockquote>

<blockquote>
<p><em>Effects</em>: <del>Let <code class="language-cpp">op</code> be the operator</del>. Equivalent to:
  <pre><code>return basic_string_view&lt;charT, traits&gt;(lhs) <del>op</del> <ins>&lt;=&gt;</ins> basic_string_view&lt;charT, traits&gt;(rhs);</code></pre>
<ins><em>Remarks</em>: This function is to be found via argument-dependent lookup only.</ins></p>
</blockquote>
<p>Change 20.4.1 [string.view.synop]:</p>
<blockquote><pre><code>namespace std {
  // [string.view.template], class template basic_string_view
  template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
  class basic_string_view;

  // [string.view.comparison], non-member comparison functions
  <del>template&lt;class charT, class traits&gt;</del>
  <del>  constexpr bool operator==(basic_string_view&lt;charT, traits&gt; x,</del>
  <del>                            basic_string_view&lt;charT, traits&gt; y) noexcept;</del>
  <del>template&lt;class charT, class traits&gt;</del>
  <del>  constexpr bool operator!=(basic_string_view&lt;charT, traits&gt; x,</del>
  <del>                            basic_string_view&lt;charT, traits&gt; y) noexcept;</del>
  <del>template&lt;class charT, class traits&gt;</del>
  <del>  constexpr bool operator&lt; (basic_string_view&lt;charT, traits&gt; x,</del>
  <del>                            basic_string_view&lt;charT, traits&gt; y) noexcept;</del>
  <del>template&lt;class charT, class traits&gt;</del>
  <del>  constexpr bool operator&gt; (basic_string_view&lt;charT, traits&gt; x,</del>
  <del>                            basic_string_view&lt;charT, traits&gt; y) noexcept;</del>
  <del>template&lt;class charT, class traits&gt;</del>
  <del>  constexpr bool operator&lt;=(basic_string_view&lt;charT, traits&gt; x,</del>
  <del>                            basic_string_view&lt;charT, traits&gt; y) noexcept;</del>
  <del>template&lt;class charT, class traits&gt;</del>
  <del>  constexpr bool operator&gt;=(basic_string_view&lt;charT, traits&gt; x,</del>
  <del>                            basic_string_view&lt;charT, traits&gt; y) noexcept;</del>
  <del>// see [string.view.comparison], sufficient additional overloads of comparison functions</del>
  [...]
}</code></pre></blockquote>

<p>Change 20.4.2 [string.view.template], insert wherever the editor deems appropriate</p>
<blockquote><pre><code>template&lt;class charT, class traits = char_traits&lt;charT&gt;&gt;
class basic_string_view {
  [...]
  <ins>friend constexpr bool operator==(basic_string_view, basic_string_view) noexcept { <i>see below</i> }</ins>
  <ins>friend constexpr <i>see below</i> operator&lt;=&gt;(basic_string_view, basic_string_view) noexcept { <i>see below</i> }</ins>
  [...]
};</code></pre></blockquote>

<p>Remove the entirety of 20.4.3 [string.view.comparison]. The proposed two hidden friend declarations satisfy the requirements without needing extra wording. Replace it with the following:</p>
<blockquote>
<p><pre><code>friend constexpr bool operator==(basic_string_view lhs, basic_string_view rhs) noexcept;</code></pre>
<em>Returns:</em> <code class="language-cpp">lhs.compare(rhs) == 0</code>.<br />
<em>Remarks</em>: This function is to be found via argument-dependent lookup only.
<pre><code>friend constexpr <i>see below</i> operator&lt;=&gt;(basic_string_view, basic_string_view) noexcept;</code></pre>
Let <code class="language-cpp">R</code> denote the type <code class="language-cpp">traits::comparison_category</code> if it exists, otherwise <code class="language-cpp">R</code> is <code class="language-cpp">weak_ordering</code>.<br />
<em>Returns:</em> <code class="language-cpp">static_cast&lt;R&gt;(lhs.compare(rhs) &lt;=&gt; 0)</code>.<br />
<em>Remarks</em>: This function is to be found via argument-dependent lookup only.</p>
</blockquote>
<h3 id="clause-24-algorithms-library">3.7. Clause 24: Algorithms library<a class="self-link" href="#clause-24-algorithms-library"></a></h3>
<p>Change 24.4 [algorithm.syn]:</p>
<blockquote><pre><code>namespace std {
  [...]
  // [alg.3way], three-way comparison algorithms
  <del>template&lt;class T, class U&gt;</del>
  <del>  constexpr auto compare_3way(const T& a, const U& b);</del>
  template&lt;class InputIterator1, class InputIterator2, class Cmp&gt;
    constexpr auto
      <del>lexicographical_compare_3way(InputIterator1 b1, InputIterator1 e1,</del>
      <ins>lexicographical_compare_three_way(InputIterator1 b1, InputIterator1 e1,</ins>
                                   InputIterator2 b2, InputIterator2 e2,
                                   Cmp comp)
        -&gt; common_comparison_category_t&lt;decltype(comp(*b1, *b2)), strong_ordering&gt;;
  template&lt;class InputIterator1, class InputIterator2&gt;
    constexpr auto
      <del>lexicographical_compare_3way(InputIterator1 b1, InputIterator1 e1,</del>
      <ins>lexicographical_compare_three_way(InputIterator1 b1, InputIterator1 e1,</ins>
                                   InputIterator2 b2, InputIterator2 e2);
  [...]
}</code></pre></blockquote>

<p>Change 24.7.11 [alg.3way]:</p>
<blockquote><del><code>template&lt;class T, class U&gt; constexpr auto compare_3way(const T& a, const U& b);</code>

<p><i>Effects</i>: Compares two values and produces a result of the strongest applicable comparison category type:
<ul>
<li> Returns a <=> b if that expression is well-formed.
<li> Otherwise, if the expressions a == b and a < b are each well-formed and convertible to bool, returns strong_ยญorderingโ::โequal when a == b is true, otherwise returns strong_ยญorderingโ::โless when a < b is true, and otherwise returns strong_ยญorderingโ::โgreater.
<li> Otherwise, if the expression a == b is well-formed and convertible to bool, returns strong_ยญequalityโ::โequal when a == b is true, and otherwise returns strong_ยญequalityโ::โnonequal.
<li>Otherwise, the function is defined as deleted.
</ul></del></blockquote>

<p>Change 24.7.11 [alg.3way] paragraph 2:</p>
<blockquote><pre><code>template&lt;class InputIterator1, class InputIterator2, class Cmp&gt;
  constexpr auto
    <del>lexicographical_compare_3way(InputIterator1 b1, InputIterator1 e1,</del>
    <ins>lexicographical_compare_three_way(InputIterator1 b1, InputIterator1 e1,</ins>
                                 InputIterator2 b2, InputIterator2 e2,
                                 Cmp comp);</code></pre></blockquote>

<p>Change 24.7.11 [alg.3way] paragraph 4:</p>
<blockquote><pre><code>template&lt;class InputIterator1, class InputIterator2&gt;
  constexpr auto
    <del>lexicographical_compare_3way(InputIterator1 b1, InputIterator1 e1,</del>
    <ins>lexicographical_compare_three_way(InputIterator1 b1, InputIterator1 e1,</ins>
                                 InputIterator2 b2, InputIterator2 e2);</code></pre>

<i>Effects</i>: Equivalent to:
<pre><code><del>return lexicographical_compare_3way(b1, e1, b2, e2,</del>
                                    <del>[](const auto& t, const auto& u) {</del>
                                    <del>  return compare_3way(t, u);</del>
                                    <del>});</del>
<ins>return lexicographical_compare_three_way(b1, e1, b2, e2, compare_three_way());</ins></code></pre>             
</blockquote>

<h2 id="references">4. References<a class="self-link" href="#references"></a></h2><ul><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0790r2.html">[P0790R2]</a><span style="margin-left: 5px;">"Effect of operator&lt;=&gt; on the C++ Standard Library" by David Stone, 2019-01-21</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0891r2.html">[P0891R2]</a><span style="margin-left: 5px;">"Make strong_order a Customization Point!" by Gaลกper Aลพman, Jeff Snyder, 2019-01-20</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1154r1.html">[P1154R1]</a><span style="margin-left: 5px;">"Type traits for structural comparison" by Arthur O'Dwyer, Jeff Snyder, 2019-01-19</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1185r1.html">[P1185R1]</a><span style="margin-left: 5px;">"&lt;=&gt; != ==" by Barry Revzin, 2019-01-22</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1186r1.html">[P1186R1]</a><span style="margin-left: 5px;">"When do you actually use &lt;=&gt;?" by Barry Revzin, 2019-01-22</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1188r0.html">[P1188R0]</a><span style="margin-left: 5px;">"Library utilities for &lt;=&gt;" by Barry Revzin, 2019-01-22</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1189r0.html">[P1189R0]</a><span style="margin-left: 5px;">"Add &lt;=&gt; to Library" by Barry Revzin, 2019-01-22</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1191r0.html">[P1191R0]</a><span style="margin-left: 5px;">"Adding operator&lt;=&gt; to types that are not currently comparable" by David Stone, 2018-08-22</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1380r1.html">[P1380R1]</a><span style="margin-left: 5px;">"Ambiguity and Insecurities with Three-Way Comparison" by Lawrence Crowl, 2019-01-20</span></li></ul>
</html>