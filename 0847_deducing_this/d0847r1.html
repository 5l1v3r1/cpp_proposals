<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Deducing this</title>
<style type="text/css">html {
	position: relative;
	max-width: 1024px;
	height: 100%;
}
body {
	font-family: Helvetica, arial, sans-serif;
	font-size: 14px;
	line-height: 1.6;
	padding-top: 10px;
	padding-bottom: 10px;
	background-color: white;
	padding: 30px;
}
body>*:first-child {
	margin-top: 0 !important;
}
body>*:last-child {
	margin-bottom: 0 !important;
}
a {
	color: #4183C4;
}
a.absent {
	color: #cc0000;
}
a.anchor {
	display: block;
	padding-left: 30px;
	margin-left: -30px;
	cursor: pointer;
	position: absolute;
	top: 0;
	left: 0;
	bottom: 0;
}
h1, h2, h3, h4, h5, h6 {
	margin: 20px 0 10px;
	padding: 0;
	font-weight: bold;
	-webkit-font-smoothing: antialiased;
	cursor: text;
	position: relative;
}
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
	background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
	text-decoration: none;
}
h1 tt, h1 code {
	font-size: inherit;
}
h2 tt, h2 code {
	font-size: inherit;
}
h3 tt, h3 code {
	font-size: inherit;
}
h4 tt, h4 code {
	font-size: inherit;
}
h5 tt, h5 code {
	font-size: inherit;
}
h6 tt, h6 code {
	font-size: inherit;
}
h1 {
	font-size: 28px;
	color: black;
}
h2 {
	font-size: 24px;
	border-bottom: 1px solid #cccccc;
	color: black;
}
h3 {
	font-size: 18px;
}
h4 {
	font-size: 16px;
}
h5 {
	font-size: 14px;
}
h6 {
	color: #777777;
	font-size: 14px;
}
p, blockquote, ol, dl, li, table, pre {
	margin: 15px 0;
}
hr {
	background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
	border: 0 none;
	color: #cccccc;
	height: 4px;
	padding: 0;
}
body>h2:first-child {
	margin-top: 0;
	padding-top: 0;
}
body>h1:first-child {
	margin-top: 0;
	padding-top: 0;
}
body>h1:first-child+h2 {
	margin-top: 0;
	padding-top: 0;
}
body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
	margin-top: 0;
	padding-top: 0;
}
a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
	margin-top: 0;
	padding-top: 0;
}
h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
	margin-top: 0;
}
li p.first {
	display: inline-block;
}
li {
	margin: 0;
}
ol {
	padding-left: 30px;
    margin: 5px;
    counter-reset: item;
    margin-left: -1px;
    margin-bottom: -1px;
    margin-top: -1px;
}
ol > li {
    counter-increment: item;
    margin-bottom: -1px;
    margin-top: -1px;    
}
ol ol > li {
    display: block;
    margin-bottom: -1px;
    margin-top: -1px;    
}
ol ol > li:before {
    content: counters(item, ".") ". ";
    margin-left: -30px;
    margin-bottom: -1px;
    margin-top: -1px;    
}
ul :first-child, ol :first-child {
	margin-top: 0;
}
ul ul { 
    margin-left: -15px;
}
dl {
	padding: 0;
}
dl dt {
	font-size: 14px;
	font-weight: bold;
	font-style: italic;
	padding: 0;
	margin: 15px 0 5px;
}
dl dt:first-child {
	padding: 0;
}
dl dt> :first-child {
	margin-top: 0;
}
dl dt> :last-child {
	margin-bottom: 0;
}
dl dd {
	margin: 0 0 15px;
	padding: 0 15px;
}
dl dd> :first-child {
	margin-top: 0;
}
dl dd> :last-child {
	margin-bottom: 0;
}
blockquote {
	border-left: 4px solid #dddddd;
	padding: 0 15px;
	color: #777777;
}
blockquote> :first-child {
	margin-top: 0;
}
blockquote> :last-child {
	margin-bottom: 0;
}
table {
	padding: 0;
	border-collapse: collapse;
}
table tr {
	border-top: 1px solid #cccccc;
	background-color: white;
	margin: 0;
	padding: 0;
}
table tr:nth-child(2n) {
	background-color: #f8f8f8;
}
table tr th {
	font-weight: bold;
	border: 1px solid #cccccc;
	margin: 0;
	padding: 6px 13px;
}
table tr td {
	border: 1px solid #cccccc;
	margin: 0;
	padding: 6px 13px;
}
table tr th :first-child, table tr td :first-child {
	margin-top: 0;
}
table tr th :last-child, table tr td :last-child {
	margin-bottom: 0;
}
td {
	vertical-align: top;
}
img {
	max-width: 100%;
}
span.frame {
	display: block;
	overflow: hidden;
}
span.frame>span {
	border: 1px solid #dddddd;
	display: block;
	float: left;
	overflow: hidden;
	margin: 13px 0 0;
	padding: 7px;
	width: auto;
}
span.frame span img {
	display: block;
	float: left;
}
span.frame span span {
	clear: both;
	color: #333333;
	display: block;
	padding: 5px 0 0;
}
span.align-center {
	display: block;
	overflow: hidden;
	clear: both;
}
span.align-center>span {
	display: block;
	overflow: hidden;
	margin: 13px auto 0;
	text-align: center;
}
span.align-center span img {
	margin: 0 auto;
	text-align: center;
}
span.align-right {
	display: block;
	overflow: hidden;
	clear: both;
}
span.align-right>span {
	display: block;
	overflow: hidden;
	margin: 13px 0 0;
	text-align: right;
}
span.align-right span img {
	margin: 0;
	text-align: right;
}
span.float-left {
	display: block;
	margin-right: 13px;
	overflow: hidden;
	float: left;
}
span.float-left span {
	margin: 13px 0 0;
}
span.float-right {
	display: block;
	margin-left: 13px;
	overflow: hidden;
	float: right;
}
span.float-right>span {
	display: block;
	overflow: hidden;
	margin: 13px auto 0;
	text-align: right;
}
code, tt {
	margin: 0 2px;
	padding: 0 5px;
	white-space: nowrap;
	border: 1px solid #eaeaea;
	background-color: #f8f8f8;
	border-radius: 3px;
}
pre code {
	margin: 0;
	padding: 0;
	white-space: pre;
	border: none;
	background: transparent;
}
.highlight pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	font-size: 13px;
	line-height: 19px;
	overflow: auto;
	padding: 6px 10px;
	border-radius: 3px;
}
pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	font-size: 13px;
	line-height: 19px;
	overflow: auto;
    overflow-x: hidden;
    overflow-y: hidden;
    padding: 6px 10px;
	border-radius: 3px;
}
pre code, pre tt {
	background-color: transparent;
	border: none;
}
sup {
	font-size: 0.83em;
	vertical-align: super;
	line-height: 0;
}
kbd {
	display: inline-block;
	padding: 3px 5px;
	font-size: 11px;
	line-height: 10px;
	color: #555;
	vertical-align: middle;
	background-color: #fcfcfc;
	border: solid 1px #ccc;
	border-bottom-color: #bbb;
	border-radius: 3px;
	box-shadow: inset 0 -1px 0 #bbb
}
* {
	-webkit-print-color-adjust: exact;
}
ins {
	color: #00A000
}
del {
	color: #A00000
}
a.self-link {
    position: absolute;
    top: 0;
    left: calc(-1 * (3.5rem - 26px));
    width: calc(3.5rem - 26px);
    height: 2em;
    text-align: center;
    border: none;
    transition: opacity .2s;
    opacity: .5;
    font-size: 83%;
}
a.self-link:hover {
    opacity: 1;
}
a.self-link::before {
    content: "ยง";
}</style>
<style type="text/css">/* PrismJS 1.15.0
https://prismjs.com/download.html#themes=prism&languages=markup+css+clike+c+cpp&plugins=line-highlight */
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f8f8f8;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #9a6e3a;
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function,
.token.class-name {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}

pre[data-line] {
	position: relative;
	padding: 1em 0 1em 3em;
}

.line-highlight {
	position: absolute;
	left: 0;
	right: 0;
	padding: inherit 0;
	margin-top: 1em; /* Same as .prismโs padding-top */

	background: hsla(24, 20%, 50%,.08);
	background: linear-gradient(to right, hsla(24, 20%, 50%,.1) 70%, hsla(24, 20%, 50%,0));

	pointer-events: none;

	line-height: inherit;
	white-space: pre;
}

	.line-highlight:before,
	.line-highlight[data-end]:after {
		content: attr(data-start);
		position: absolute;
		top: .4em;
		left: .6em;
		min-width: 1em;
		padding: 0 .5em;
		background-color: hsla(24, 20%, 50%,.4);
		color: hsl(24, 20%, 95%);
		font: bold 65%/1.5 sans-serif;
		text-align: center;
		vertical-align: .3em;
		border-radius: 999px;
		text-shadow: none;
		box-shadow: 0 1px white;
	}

	.line-highlight[data-end]:after {
		content: attr(data-end);
		top: auto;
		bottom: .4em;
	}

.line-numbers .line-highlight:before,
.line-numbers .line-highlight:after {
	content: none;
}

</style>
<script type="text/javascript">/* PrismJS 1.15.0
https://prismjs.com/download.html#themes=prism&languages=markup+css+clike+c+cpp+nasm+rust&plugins=line-highlight */
var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-([\w-]+)\b/i,t=0,n=_self.Prism={manual:_self.Prism&&_self.Prism.manual,disableWorkerMessageHandler:_self.Prism&&_self.Prism.disableWorkerMessageHandler,util:{encode:function(e){return e instanceof r?new r(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e,t){var r=n.util.type(e);switch(t=t||{},r){case"Object":if(t[n.util.objId(e)])return t[n.util.objId(e)];var a={};t[n.util.objId(e)]=a;for(var l in e)e.hasOwnProperty(l)&&(a[l]=n.util.clone(e[l],t));return a;case"Array":if(t[n.util.objId(e)])return t[n.util.objId(e)];var a=[];return t[n.util.objId(e)]=a,e.forEach(function(e,r){a[r]=n.util.clone(e,t)}),a}return e}},languages:{extend:function(e,t){var r=n.util.clone(n.languages[e]);for(var a in t)r[a]=t[a];return r},insertBefore:function(e,t,r,a){a=a||n.languages;var l=a[e];if(2==arguments.length){r=arguments[1];for(var i in r)r.hasOwnProperty(i)&&(l[i]=r[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in r)r.hasOwnProperty(i)&&(o[i]=r[i]);o[s]=l[s]}var u=a[e];return a[e]=o,n.languages.DFS(n.languages,function(t,n){n===u&&t!=e&&(this[t]=o)}),o},DFS:function(e,t,r,a){a=a||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],r||l),"Object"!==n.util.type(e[l])||a[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||a[n.util.objId(e[l])]||(a[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,a)):(a[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,a)))}},plugins:{},highlightAll:function(e,t){n.highlightAllUnder(document,e,t)},highlightAllUnder:function(e,t,r){var a={callback:r,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var l,i=a.elements||e.querySelectorAll(a.selector),o=0;l=i[o++];)n.highlightElement(l,t===!0,a.callback)},highlightElement:function(t,r,a){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1].toLowerCase(),i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,t.parentNode&&(o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l));var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(n.hooks.run("before-sanity-check",u),!u.code||!u.grammar)return u.code&&(n.hooks.run("before-highlight",u),u.element.textContent=u.code,n.hooks.run("after-highlight",u)),n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),r&&_self.Worker){var g=new Worker(n.filename);g.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,a&&a.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},g.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,a&&a.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,a){var l={code:e,grammar:t,language:a};return n.hooks.run("before-tokenize",l),l.tokens=n.tokenize(l.code,l.grammar),n.hooks.run("after-tokenize",l),r.stringify(n.util.encode(l.tokens),l.language)},matchGrammar:function(e,t,r,a,l,i,o){var s=n.Token;for(var u in r)if(r.hasOwnProperty(u)&&r[u]){if(u==o)return;var g=r[u];g="Array"===n.util.type(g)?g:[g];for(var c=0;c<g.length;++c){var h=g[c],f=h.inside,d=!!h.lookbehind,m=!!h.greedy,p=0,y=h.alias;if(m&&!h.pattern.global){var v=h.pattern.toString().match(/[imuy]*$/)[0];h.pattern=RegExp(h.pattern.source,v+"g")}h=h.pattern||h;for(var b=a,k=l;b<t.length;k+=t[b].length,++b){var w=t[b];if(t.length>e.length)return;if(!(w instanceof s)){if(m&&b!=t.length-1){h.lastIndex=k;var _=h.exec(e);if(!_)break;for(var j=_.index+(d?_[1].length:0),P=_.index+_[0].length,A=b,x=k,O=t.length;O>A&&(P>x||!t[A].type&&!t[A-1].greedy);++A)x+=t[A].length,j>=x&&(++b,k=x);if(t[b]instanceof s)continue;I=A-b,w=e.slice(k,x),_.index-=k}else{h.lastIndex=0;var _=h.exec(w),I=1}if(_){d&&(p=_[1]?_[1].length:0);var j=_.index+p,_=_[0].slice(p),P=j+_.length,N=w.slice(0,j),S=w.slice(P),C=[b,I];N&&(++b,k+=N.length,C.push(N));var E=new s(u,f?n.tokenize(_,f):_,y,_,m);if(C.push(E),S&&C.push(S),Array.prototype.splice.apply(t,C),1!=I&&n.matchGrammar(e,t,r,b,k,!0,u),i)break}else if(i)break}}}}},tokenize:function(e,t){var r=[e],a=t.rest;if(a){for(var l in a)t[l]=a[l];delete t.rest}return n.matchGrammar(e,r,t,0,0,!1),r},hooks:{all:{},add:function(e,t){var r=n.hooks.all;r[e]=r[e]||[],r[e].push(t)},run:function(e,t){var r=n.hooks.all[e];if(r&&r.length)for(var a,l=0;a=r[l++];)a(t)}}},r=n.Token=function(e,t,n,r,a){this.type=e,this.content=t,this.alias=n,this.length=0|(r||"").length,this.greedy=!!a};if(r.stringify=function(e,t,a){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return r.stringify(n,t,e)}).join("");var l={type:e.type,content:r.stringify(e.content,t,a),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:a};if(e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o=Object.keys(l.attributes).map(function(e){return e+'="'+(l.attributes[e]||"").replace(/"/g,"&quot;")+'"'}).join(" ");return"<"+l.tag+' class="'+l.classes.join(" ")+'"'+(o?" "+o:"")+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(n.disableWorkerMessageHandler||_self.addEventListener("message",function(e){var t=JSON.parse(e.data),r=t.language,a=t.code,l=t.immediateClose;_self.postMessage(n.highlight(a,n.languages[r],r)),l&&_self.close()},!1),_self.Prism):_self.Prism;var a=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return a&&(n.filename=a.src,n.manual||a.hasAttribute("data-manual")||("loading"!==document.readyState?window.requestAnimationFrame?window.requestAnimationFrame(n.highlightAll):window.setTimeout(n.highlightAll,16):document.addEventListener("DOMContentLoaded",n.highlightAll))),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
Prism.languages.markup={comment:/<!--[\s\S]*?-->/,prolog:/<\?[\s\S]+?\?>/,doctype:/<!DOCTYPE[\s\S]+?>/i,cdata:/<!\[CDATA\[[\s\S]*?]]>/i,tag:{pattern:/<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i,greedy:!0,inside:{tag:{pattern:/^<\/?[^\s>\/]+/i,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"attr-value":{pattern:/=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/i,inside:{punctuation:[/^=/,{pattern:/(^|[^\\])["']/,lookbehind:!0}]}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:/&#?[\da-z]{1,8};/i},Prism.languages.markup.tag.inside["attr-value"].inside.entity=Prism.languages.markup.entity,Prism.hooks.add("wrap",function(a){"entity"===a.type&&(a.attributes.title=a.content.replace(/&amp;/,"&"))}),Prism.languages.xml=Prism.languages.markup,Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup;
Prism.languages.css={comment:/\/\*[\s\S]*?\*\//,atrule:{pattern:/@[\w-]+?.*?(?:;|(?=\s*\{))/i,inside:{rule:/@[\w-]+/}},url:/url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,selector:/[^{}\s][^{};]*?(?=\s*\{)/,string:{pattern:/("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},property:/[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,important:/\B!important\b/i,"function":/[-a-z0-9]+(?=\()/i,punctuation:/[(){};:]/},Prism.languages.css.atrule.inside.rest=Prism.languages.css,Prism.languages.markup&&(Prism.languages.insertBefore("markup","tag",{style:{pattern:/(<style[\s\S]*?>)[\s\S]*?(?=<\/style>)/i,lookbehind:!0,inside:Prism.languages.css,alias:"language-css",greedy:!0}}),Prism.languages.insertBefore("inside","attr-value",{"style-attr":{pattern:/\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,inside:{"attr-name":{pattern:/^\s*style/i,inside:Prism.languages.markup.tag.inside},punctuation:/^\s*=\s*['"]|['"]\s*$/,"attr-value":{pattern:/.+/i,inside:Prism.languages.css}},alias:"language-css"}},Prism.languages.markup.tag));
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(?:true|false)\b/,"function":/\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};
Prism.languages.c=Prism.languages.extend("clike",{keyword:/\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,operator:/>>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*\/%&|^!=<>]=?/,number:/(?:\b0x[\da-f]+|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?)[ful]*/i}),Prism.languages.insertBefore("c","string",{macro:{pattern:/(^\s*)#\s*[a-z]+(?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im,lookbehind:!0,alias:"property",inside:{string:{pattern:/(#\s*include\s*)(?:<.+?>|("|')(?:\\?.)+?\2)/,lookbehind:!0},directive:{pattern:/(#\s*)\b(?:define|defined|elif|else|endif|error|ifdef|ifndef|if|import|include|line|pragma|undef|using)\b/,lookbehind:!0,alias:"keyword"}}},constant:/\b(?:__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|stdin|stdout|stderr)\b/}),delete Prism.languages.c["class-name"],delete Prism.languages.c["boolean"];
Prism.languages.cpp=Prism.languages.extend("c",{keyword:/\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|class|compl|const|constexpr|const_cast|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,"boolean":/\b(?:true|false)\b/,operator:/>>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*\/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/}),Prism.languages.insertBefore("cpp","keyword",{"class-name":{pattern:/(class\s+)\w+/i,lookbehind:!0}}),Prism.languages.insertBefore("cpp","string",{"raw-string":{pattern:/R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,alias:"string",greedy:!0}});
Prism.languages.nasm={comment:/;.*$/m,string:/(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,label:{pattern:/(^\s*)[A-Za-z._?$][\w.?$@~#]*:/m,lookbehind:!0,alias:"function"},keyword:[/\[?BITS (?:16|32|64)\]?/,{pattern:/(^\s*)section\s*[a-zA-Z.]+:?/im,lookbehind:!0},/(?:extern|global)[^;\r\n]*/i,/(?:CPU|FLOAT|DEFAULT).*$/m],register:{pattern:/\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|sp|si|di)|[cdefgs]s)\b/i,alias:"variable"},number:/(?:\b|(?=\$))(?:0[hx][\da-f]*\.?[\da-f]+(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|\d*\.?\d+(?:\.?e[+-]?\d+)?[dt]?)\b/i,operator:/[\[\]*+\-\/%<>=&|$!]/};
Prism.languages.rust={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?\*\//,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0}],string:[{pattern:/b?r(#*)"(?:\\.|(?!"\1)[^\\\r\n])*"\1/,greedy:!0},{pattern:/b?"(?:\\.|[^\\\r\n"])*"/,greedy:!0}],"char":{pattern:/b?'(?:\\(?:x[0-7][\da-fA-F]|u{(?:[\da-fA-F]_*){1,6}|.)|[^\\\r\n\t'])'/,alias:"string"},"lifetime-annotation":{pattern:/'[^\s>']+/,alias:"symbol"},keyword:/\b(?:abstract|alignof|as|be|box|break|const|continue|crate|do|else|enum|extern|false|final|fn|for|if|impl|in|let|loop|match|mod|move|mut|offsetof|once|override|priv|pub|pure|ref|return|sizeof|static|self|struct|super|true|trait|type|typeof|unsafe|unsized|use|virtual|where|while|yield)\b/,attribute:{pattern:/#!?\[.+?\]/,greedy:!0,alias:"attr-name"},"function":[/\w+(?=\s*\()/,/\w+!(?=\s*\(|\[)/],"macro-rules":{pattern:/\w+!/,alias:"function"},number:/\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(\d(?:_?\d)*)?\.?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:[iu](?:8|16|32|64)?|f32|f64))?\b/,"closure-params":{pattern:/\|[^|]*\|(?=\s*[{-])/,inside:{punctuation:/[|:,]/,operator:/[&*]/}},punctuation:/[{}[\];(),:]|\.+|->/,operator:/[-+*\/%!^]=?|=[=>]?|@|&[&=]?|\|[|=]?|<<?=?|>>?=?/};
!function(){function e(e,t){return Array.prototype.slice.call((t||document).querySelectorAll(e))}function t(e,t){return t=" "+t+" ",(" "+e.className+" ").replace(/[\n\t]/g," ").indexOf(t)>-1}function n(e,n,i){n="string"==typeof n?n:e.getAttribute("data-line");for(var o,l=n.replace(/\s+/g,"").split(","),a=+e.getAttribute("data-line-offset")||0,s=r()?parseInt:parseFloat,d=s(getComputedStyle(e).lineHeight),u=t(e,"line-numbers"),c=0;o=l[c++];){var p=o.split("-"),m=+p[0],f=+p[1]||m,h=e.querySelector('.line-highlight[data-range="'+o+'"]')||document.createElement("div");if(h.setAttribute("aria-hidden","true"),h.setAttribute("data-range",o),h.className=(i||"")+" line-highlight",u&&Prism.plugins.lineNumbers){var g=Prism.plugins.lineNumbers.getLine(e,m),y=Prism.plugins.lineNumbers.getLine(e,f);g&&(h.style.top=g.offsetTop+"px"),y&&(h.style.height=y.offsetTop-g.offsetTop+y.offsetHeight+"px")}else h.setAttribute("data-start",m),f>m&&h.setAttribute("data-end",f),h.style.top=(m-a-1)*d+"px",h.textContent=new Array(f-m+2).join(" \n");u?e.appendChild(h):(e.querySelector("code")||e).appendChild(h)}}function i(){var t=location.hash.slice(1);e(".temporary.line-highlight").forEach(function(e){e.parentNode.removeChild(e)});var i=(t.match(/\.([\d,-]+)$/)||[,""])[1];if(i&&!document.getElementById(t)){var r=t.slice(0,t.lastIndexOf(".")),o=document.getElementById(r);o&&(o.hasAttribute("data-line")||o.setAttribute("data-line",""),n(o,i,"temporary "),document.querySelector(".temporary.line-highlight").scrollIntoView())}}if("undefined"!=typeof self&&self.Prism&&self.document&&document.querySelector){var r=function(){var e;return function(){if("undefined"==typeof e){var t=document.createElement("div");t.style.fontSize="13px",t.style.lineHeight="1.5",t.style.padding=0,t.style.border=0,t.innerHTML="&nbsp;<br />&nbsp;",document.body.appendChild(t),e=38===t.offsetHeight,document.body.removeChild(t)}return e}}(),o=0;Prism.hooks.add("before-sanity-check",function(t){var n=t.element.parentNode,i=n&&n.getAttribute("data-line");if(n&&i&&/pre/i.test(n.nodeName)){var r=0;e(".line-highlight",n).forEach(function(e){r+=e.textContent.length,e.parentNode.removeChild(e)}),r&&/^( \n)+$/.test(t.code.slice(-r))&&(t.code=t.code.slice(0,-r))}}),Prism.hooks.add("complete",function l(e){var r=e.element.parentNode,a=r&&r.getAttribute("data-line");if(r&&a&&/pre/i.test(r.nodeName)){clearTimeout(o);var s=Prism.plugins.lineNumbers,d=e.plugins&&e.plugins.lineNumbers;t(r,"line-numbers")&&s&&!d?Prism.hooks.add("line-numbers",l):(n(r,a),o=setTimeout(i,1))}}),window.addEventListener("hashchange",i),window.addEventListener("resize",function(){var e=document.querySelectorAll("pre[data-line]");Array.prototype.forEach.call(e,function(e){n(e)})})}}();
</script>

</head>
<body>
<address align=right>
Document Number: D0847R1 <br />
Date: 2018-09-25 <br />
Audience: EWG <br />
Reply-To: Gaลกper Aลพman, gasper dot azman at gmail dot com<br />Simon Brand, simon at codeplay dot com<br />Ben Deane, ben at elbeno dot com<br />Barry Revzin, barry dot revzin at gmail dot com <br />
</address>
<hr /><h1 align=center><p>Deducing <code class="language-cpp">this</code></p></h1>
<h2>Contents</h2>
<div class="toc">
<ol>
<li><a href="#revision-history">Revision History</a><ol>
<li><a href="#changes-since-r0">Changes since r0</a></li>
</ol>
</li>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#proposal">Proposal</a><ol>
<li><a href="#name-lookup-candidate-functions">Name lookup: candidate functions</a></li>
<li><a href="#type-deduction">Type deduction</a></li>
<li><a href="#name-lookup-within-member-functions-with-explicit-member-type">Name lookup: within member functions with explicit member type</a></li>
<li><a href="#writing-the-function-pointer-types-for-such-functions">Writing the function pointer types for such functions</a></li>
<li><a href="#teachability-implications">Teachability Implications</a></li>
<li><a href="#can-static-member-functions-have-an-explicit-object-type">Can static member functions have an explicit object type?</a></li>
<li><a href="#interplays-with-capturing-this-and-this-in-lambdas">Interplays with capturing [this] and [*this] in lambdas</a></li>
<li><a href="#translating-code-to-use-explicit-member-types">Translating code to use explicit member types</a></li>
<li><a href="#parsing-issues">Parsing issues</a></li>
<li><a href="#alternative-solution">Alternative solution</a></li>
<li><a href="#potential-extensions">Potential Extensions</a></li>
</ol>
</li>
<li><a href="#real-world-examples">Real-World Examples</a><ol>
<li><a href="#deduplicating-code">Deduplicating Code</a></li>
<li><a href="#crtp-without-the-c-r-or-even-t">CRTP, without the C, R, or even T</a><ol>
<li><a href="#builder-pattern">Builder pattern</a></li>
<li><a href="#a-new-syntax-for-opt-in">A new syntax for opt-in</a></li>
</ol>
</li>
<li><a href="#forwarding-lambdas">Forwarding Lambdas</a></li>
<li><a href="#sfinae-friendly-callables">SFINAE-friendly callables</a></li>
</ol>
</li>
<li><a href="#acknowledgements">Acknowledgements</a></li>
<li><a href="#references">References</a></li>
</ol>
</div>

<h2 id="revision-history">1. Revision History<a class="self-link" href="#revision-history"></a></h2>
<h3 id="changes-since-r0">1.1. Changes since r0<a class="self-link" href="#changes-since-r0"></a></h3>
<p><a href="https://wg21.link/p0847r0" title="Deducing this">P0847R0</a> was presented in Rapperswil in June 2018 using an already adjusted syntax from the one used in the paper, using <code class="language-cpp">this Self&amp;&amp; self</code> to indicate the explicit object parameter rather than <code class="language-cpp">Self&amp;&amp; this self</code>. EWG took <a href="" title="RAP Wiki notes, P0847R0 - June 2018">two direction polls</a> there:</p>
<blockquote>
<p><em>If an explicitly named (e.g. <code class="language-cpp">self</code>) object parameter, should <code class="language-cpp">this</code> be implicitly or explicitly usable in member function body?</em></p>
<p><table style="font-size=8px"><tr><th>SF</th><th>F</th><th>N</th><th>A</th><th>SA</th></tr><tr><td>0</td><td>2</td><td>9</td><td>14</td><td>12</td></table></p>
</blockquote>
<p>This poll is full adopted in this revision - changing the behavior of explicit object parameter functions from modeling member functions to modeling non-member <code class="language-cpp">friend</code>s.</p>
<blockquote>
<p><em>Encourage putting this-type identifier stuff in usual cv-ref qualifier location?</em></p>
<pre class="codehilite"><code class="language-cpp">template &lt;typename Self&gt;
void foo(int) Self&amp;&amp; self;</code></pre>


<p><table><tr><th>SF</th><th>F</th><th>N</th><th>A</th><th>SA</th></tr><tr><td>9</td><td>11</td><td>10</td><td>5</td><td>2</td></table></p>
</blockquote>
<p>This revision as presented adopts a slight variant of the direction suggested by this poll (without an identifier - see <a href="#parsing-issues">parsing issues</a>), and is discussed at length in an <a href="#alternative-solution">alternative solution</a>. The syntax change is:</p>
<table style="width:100%">
<tr>
<th style="width:50%">
<p>As presented in Rapperswil</p>
</th>
<th style="width:50%">
<p>This proposal</p>
</th>
</tr>
<tr>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
struct optional {
  template &lt;typename Self&gt;
  constexpr like_t&lt;Self&amp;&amp;, T&gt; operator*(this Self&amp;&amp;) {
    return forward_like&lt;Self&gt;(*this).m_value;
  }
};</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
struct optional {
  template &lt;typename Self&gt;
  constexpr like_t&lt;Self&amp;&amp;, T&gt; operator*() Self&amp;&amp; {
    return forward&lt;Self&gt;(*this).optional::m_value;
  }
};</code></pre>
</td>
</tr>
</table>

<p>This new revision also proposes a slight change in template deduction rules specific to the new explicit member type. </p>
<h2 id="motivation">2. Motivation<a class="self-link" href="#motivation"></a></h2>
<p>In C++03, member functions could have <em>cv</em>-qualifications, so it was possible to have scenarios where a particular class would want both a <code class="language-cpp">const</code> and non-<code class="language-cpp">const</code> overload of a particular member (Of course it was possible to also want <code class="language-cpp">volatile</code> overloads, but those are less common). In these cases, both overloads do the same thing - the only difference is in the types accessed and used. This was handled by either simply duplicating the function, adjusting types and qualifications as necessary, or having one delegate to the other. An example of the latter can be found in Scott Meyers' <a href="https://www.aristeia.com/books.html" title="Effective C++, Third Edition">"Effective C++"</a>, Item 3:</p>
<pre class="codehilite"><code class="language-cpp">class TextBlock {
public:
  const char&amp; operator[](std::size_t position) const {
    // ...
    return text[position];
  }

  char&amp; operator[](std::size_t position) {
    return const_cast&lt;char&amp;&gt;(
      static_cast&lt;const TextBlock&amp;&gt;(*this)[position]
    );
  }
  // ...
};</code></pre>


<p>Arguably, neither the duplication or the delegation via <code class="language-cpp">const_cast</code> are great solutions, but they work.</p>
<p>In C++11, member functions acquired a new axis to specialize on: ref-qualifiers. Now, instead of potentially needing two overloads of a single member function, we might need four: <code class="language-cpp">&amp;</code>, <code class="language-cpp">const&amp;</code>, <code class="language-cpp">&amp;&amp;</code>, or <code class="language-cpp">const&amp;&amp;</code>. We have three approaches to deal with this: we implement the same member four times, we can have three of the overloads delegate to the fourth, or we can have all four delegate to a helper, private static member function. One example might be the overload set for <code class="language-cpp">optional&lt;T&gt;::value()</code>. The way to implement it would be something like:</p>
<table style="width:100%">
<tr>
<th style="width:33%">
<p>Quadruplication</p>
</th>
<th style="width:33%">
<p>Delegation to 4th</p>
</th>
<th style="width:33%">
<p>Delegation to helper</p>
</th>
</tr>
<tr>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
    // ...
    constexpr T&amp; value() &amp; {
        if (has_value()) {
            return this-&gt;m_value;
        }
        throw bad_optional_access();
    }

    constexpr const T&amp; value() const&amp; {
        if (has_value()) {
            return this-&gt;m_value;
        }
        throw bad_optional_access();
    }

    constexpr T&amp;&amp; value() &amp;&amp; {
        if (has_value()) {
            return std::move(this-&gt;m_value);
        }
        throw bad_optional_access();
    }

    constexpr const T&amp;&amp;
    value() const&amp;&amp; {
        if (has_value()) {
            return std::move(this-&gt;m_value);
        }
        throw bad_optional_access();
    }
    // ...
};</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
    // ...
    constexpr T&amp; value() &amp; {
        return const_cast&lt;T&amp;&gt;(
            static_cast&lt;optional const&amp;&gt;(
                *this).value());
    }

    constexpr const T&amp; value() const&amp; {
        if (has_value()) {
            return this-&gt;m_value;
        }
        throw bad_optional_access();
    }

    constexpr T&amp;&amp; value() &amp;&amp; {
        return const_cast&lt;T&amp;&amp;&gt;(
            static_cast&lt;optional const&amp;&gt;(
                *this).value());
    }

    constexpr const T&amp;&amp;
    value() const&amp;&amp; {
        return static_cast&lt;const T&amp;&amp;&gt;(
            value());
    }
    // ...
};</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
    // ...
    constexpr T&amp; value() &amp; {
        return value_impl(*this);
    }

    constexpr const T&amp; value() const&amp; {
        return value_impl(*this);
    }

    constexpr T&amp;&amp; value() &amp;&amp; {
        return value_impl(std::move(*this));
    }

    constexpr const T&amp;&amp;
    value() const&amp;&amp; {
        return value_impl(std::move(*this));
    }

private:
    template &lt;typename Opt&gt;
    static decltype(auto)
    value_impl(Opt&amp;&amp; opt) {
        if (!opt.has_value()) {
            throw bad_optional_access();
        }
        return std::forward&lt;Opt&gt;(opt).m_value;
    }


    // ...
};</code></pre>
</td>
</tr>
</table>

<p>It's not like this is a complicated function. Far from. But more or less repeating the same code four times, or artificial delegation to avoid doing so, is the kind of thing that begs for a rewrite. Except we can't really. We <em>have</em> to implement it this way. It seems like we should be able to abstract away the qualifiers. And we can... sort of. As a non-member function, we simply don't have this problem:</p>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt;
class optional {
    // ...
    template &lt;typename Opt&gt;
    friend decltype(auto) value(Opt&amp;&amp; o) {
        if (o.has_value()) {
            return std::forward&lt;Opt&gt;(o).m_value;
        }
        throw bad_optional_access();
    }
    // ...
};</code></pre>


<p>This is great - it's just one function, that handles all four cases for us. Except it's a non-member function, not a member function. Different semantics, different syntax, doesn't help.</p>
<p>There are many, many cases in code-bases where we need two or four overloads of the same member function for different <code class="language-cpp">const</code>- or ref-qualifiers. More than that, there are likely many cases that a class should have four overloads of a particular member function, but doesn't simply due to laziness by the developer. We think that there are sufficiently many such cases that they merit a better solution than simply: write it, then write it again, then write it two more times.</p>
<h2 id="proposal">3. Proposal<a class="self-link" href="#proposal"></a></h2>
<p>We propose a new way of declaring a member function that will allow for deducing the type and value category of the class instance parameter, while still being invocable as a member function. </p>
<p>Today, member functions can optionally have a <em>cv-qualifier</em> and can optionally have a <em>ref-qualifier</em>. We propose extending this to allow an explicit type name as well. This type name can simply be the class type, but more importantly it can be a function template parameter, in which case it will be deduced from the object parameter that the member function was invoked on. </p>
<p>We believe that the ability to write <em>cv-ref qualifier</em>-aware member functions without duplication will improve code maintainability, decrease the likelihood of bugs, and allow users to write fast, correct code more easily. The added ability to deduce derived types additionally will bring in new idioms not previously available to us. </p>
<p>A brief example demonstrating how to write <code class="language-cpp">optional::value()</code> and <code class="language-cpp">optional::operator-&gt;()</code> in just two functions with no duplication (instead of six) with this proposal:</p>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt;
struct optional {
    template &lt;typename Self&gt;
    constexpr auto&amp;&amp; value() Self&amp;&amp; {
        if (!this-&gt;optional::has_value()) {
            throw bad_optional_access();
        }

        return forward&lt;Self&gt;(*this).optional::m_value;
    }

    template &lt;typename Self&gt;
    constexpr auto operator-&gt;() Self {
        return addressof(this-&gt;optional::m_value);
    }
};</code></pre>


<p>What follows is a description of how explicit member object types affect all the important language constructs: name lookup, type deduction, overload resolution, and so forth. </p>
<p>This is a strict extension to the language; all existing syntax remains valid.</p>
<h3 id="name-lookup-candidate-functions">3.1. Name lookup: candidate functions<a class="self-link" href="#name-lookup-candidate-functions"></a></h3>
<p>Today, when either invoking a named function or an operator (including the call operator) on an object of class type, name lookup will include both static and non-static member functions found by regular class lookup. Non-static member functions are treated as if there were an implicit object parameter whose type is an lvalue or rvalue reference to <em>cv</em> <code class="language-cpp">X</code> (where the reference and <em>cv</em> qualifiers are determined based on the function's qualifiers) which binds to the object on which the function was invoked. </p>
<p>For non-static member functions with the new <strong>explicit</strong> member object type, lookup will work the same way as other member functions today, except rather than implicitly determining the type of the object parameter based on the <em>cv</em>- and <em>ref</em>-qualifiers of the member function, these are explicitly determined by the provided type. The following examples illustrate this concept.</p>
<table style="width:100%">
<tr>
<th style="width:50%">
<p>C++17</p>
</th>
<th style="width:50%">
<p>With Explicit Type</p>
</th>
</tr>
<tr>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">struct X {
    // implicit object has type X&amp;
    void foo();

    // implicit object has type X const&amp;
    void foo() const;

    // implicit object has type X&amp;&amp;
    void bar() &amp;&amp;;
};</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">struct X {
    // explicit object has type X&amp;
    void ex_foo() X;

    // explicit object has type X const&amp;
    void ex_foo() X const;

    // explicit object type X&amp;&amp;
    void ex_bar() X&amp;&amp;;
};</code></pre>
</td>
</tr>
</table>

<p>The overload resolution rules for this new set of candidate functions remains unchanged - we're simply being explicit rather than implicit about the object parameter. Given a call to <code class="language-cpp">x.ex_foo()</code>, overload resolution would select the first <code class="language-cpp">ex_foo()</code> overload if <code class="language-cpp">x</code> isn't <code class="language-cpp">const</code> and the second if it is. The behaviors of the two columns as proposed are exactly equivalent.</p>
<h3 id="type-deduction">3.2. Type deduction<a class="self-link" href="#type-deduction"></a></h3>
<p>One of the main motivations of this proposal is to deduce the <em>cv</em>-qualifiers and value category of the class object, so the explicit member type needs to be deducible from the object that the member function is invoked on:</p>
<pre class="codehilite"><code class="language-cpp">struct X {
    template &lt;typename Self&gt;
    void foo(int i) Self&amp;&amp;;
};

X x;
x.foo(4);            // Self deduces as X&amp;
std::move(x).foo(2); // Self deduces as X</code></pre>


<p>A common source of duplication of member functions revolves solely around wanting non-<code class="language-cpp">const</code> and <code class="language-cpp">const</code> overloads of a member function - that otherwise do exactly the same thing. To solve this problem, we propose a slight change to template deduction rules such that when deducing an explicit member type, we <em>do not</em> drop the <em>cv</em>-qualifiers. In other words:</p>
<pre class="codehilite"><code class="language-cpp">struct Y {
public:
    Y(int i) : i(i) { }
    template &lt;typename Self&gt;
    auto&amp; get() Self {
        return this-&gt;i;
    }
private:
    int i;
};

void ex(Y&amp; y, Y const&amp; cy) {
    y.get();             // deduces Self as Y, returns int&amp;
    cy.get();            // deduces Self as Y const, not Y, returns int const&amp;

    std::move(y).get();  // deduces Self as Y, returns int&amp;
    std::move(cy).get(); // deduces Self as Y const, returns int const&amp;
}</code></pre>


<p>This mimics today's behavior where a trailing <code class="language-cpp">const</code> qualifier does not mean <code class="language-cpp">const&amp;</code>, it just means <code class="language-cpp">const</code>. Without such a change to template deduction, <code class="language-cpp">Self</code> would always just deduce as <code class="language-cpp">Y</code> (and hence be pointless), <code class="language-cpp">Self&amp;</code> would deduce as <code class="language-cpp">Y&amp;</code> or <code class="language-cpp">Y const&amp;</code> but not allow binding to rvalues, and <code class="language-cpp">Self&amp;&amp;</code> would give us different functions for lvalues and rvalues - which is unnecessary and leads to code bloat.</p>
<p>Since the explicit member type is deduced from the object the function is called on, this has the interesting effect of possibly deducing <em>derived</em> types, which can best be illustrated by the following example:    </p>
<pre class="codehilite"><code class="language-cpp">struct B {
    int i = 0;

    template &lt;typename Self&gt;
    auto&amp;&amp; get() Self&amp;&amp; {
        // NB: specifically this-&gt;i, see next section as to why
        return this-&gt;i;
    }
};

struct D : B {
    // shadows B::i
    double i = 3.14;
};

B b{};
B const cb{};
D d{};

b.foo();            // #1
cb.foo();           // #2
d.foo();            // #3
std::move(d).foo(); // #4</code></pre>


<p>The proposed behavior of these calls is:</p>
<ol>
<li><code class="language-cpp">Self</code> is deduced as <code class="language-cpp">B&amp;</code>, this call returns an <code class="language-cpp">int&amp;</code> to <code class="language-cpp">B::i</code></li>
<li><code class="language-cpp">Self</code> is deduced as <code class="language-cpp">B const&amp;</code>, this calls returns an <code class="language-cpp">int const&amp;</code> to <code class="language-cpp">B::i</code></li>
<li><code class="language-cpp">Self</code> is deduced as <code class="language-cpp">D&amp;</code>, this call returns a <code class="language-cpp">double&amp;</code> to <code class="language-cpp">D::i</code></li>
<li><code class="language-cpp">Self</code> is deduced as <code class="language-cpp">D</code>, this call returns a <code class="language-cpp">double&amp;</code> to <code class="language-cpp">D::i</code></li>
</ol>
<p>When we deduce the explicit member type, we don't just deduce the <em>cv</em>- and <em>ref</em>-qualifiers. We may also get a derived type. This follows from the normal template deduction rules. In <code class="language-cpp">#3</code>, for instance, the object parameter is an lvalue of type <code class="language-cpp">D</code>, so <code class="language-cpp">Self</code> deduces as <code class="language-cpp">D&amp;</code>.</p>
<h3 id="name-lookup-within-member-functions-with-explicit-member-type">3.3. Name lookup: within member functions with explicit member type<a class="self-link" href="#name-lookup-within-member-functions-with-explicit-member-type"></a></h3>
<p>So far, we've only considered how member functions with explicit member types get found with name lookup and how they deduce that parameter. Now let's move on to how the bodies of these functions actually behave. </p>
<p>The model we are proposing is that member functions with explicit member types behave more like <em>non-member</em> <code class="language-cpp">friend</code> functions than normal non-static member functions from the perspective of lookup. In other words, everything in the class is accessible - but you cannot access them unqualified, only through an object. What object do we have? <code class="language-cpp">*this</code>. </p>
<p>Today, <code class="language-cpp">this</code> is always a <code class="language-cpp">const</code> pointer to <em>cv-qualifier</em> class type. With this proposal, for member functions with explicit member type, <code class="language-cpp">this</code> becomes a <code class="language-cpp">const</code> pointer to <code class="language-cpp">remove_reference_t&lt;T&gt;</code>:</p>
<pre class="codehilite"><code class="language-cpp">struct X {
    void a();            // this is a X* const
    void b() const;      // this is a X const* const
    void c() &amp;&amp;;         // this is a X* const (ref-qualifiers don't count)

    void d() X;          // this is a X* const (same as a)
    void e() X&amp;&amp;;        // this is a X* const (same as c)

    template &lt;typename S&gt;
    void f() S;          // this is a S* const
    template &lt;typename S&gt;
    void g() S&amp;;         // this is a S* const
    template &lt;typename S&gt;
    void h() S&amp;&amp;;        // this is a remove_reference_t&lt;S&gt;* const
};</code></pre>


<p>For some of these member functions, <code class="language-cpp">this</code> might not point to an <code class="language-cpp">X</code> - it might point to a type derived from <code class="language-cpp">X</code> and it might be dependent!</p>
<p>It is this new dependent possibility for <code class="language-cpp">this</code> and potential confusion that could arise from that that led to the skewed result from one of the polls cited earlier.</p>
<p>Consider a slightly expanded version of the previous example:</p>
<pre class="codehilite"><code class="language-cpp">struct B {
    int i = 0;

    template &lt;typename Self&gt;
    auto&amp;&amp; f1() Self&amp;&amp; { return i; }

    template &lt;typename Self&gt;
    auto&amp;&amp; f2() Self&amp;&amp; { return this-&gt;i; }

    template &lt;typename Self&gt;
    auto&amp;&amp; f3() Self&amp;&amp; { return forward&lt;Self&gt;(*this).i; }

struct D : B {
    double i = 3.14;
};</code></pre>


<p>Consider invoking each of these functions with an lvalue of type <code class="language-cpp">D</code>. As described in the previous section, <code class="language-cpp">Self</code> in each case will be <code class="language-cpp">D&amp;</code>. </p>
<p>We propose that each of these behave as follows:</p>
<ul>
<li><code class="language-cpp">f1</code> is ill-formed due to the inability to find <code class="language-cpp">i</code>. Remember the model here is non-member <code class="language-cpp">friend</code>s, so any non-static access must be through an object, and our only object is <code class="language-cpp">*this</code>.</li>
<li><code class="language-cpp">f2</code> returns an lvalue reference to <code class="language-cpp">D::i</code>, because <code class="language-cpp">this</code> is a <code class="language-cpp">D* const</code>.</li>
<li><code class="language-cpp">f3</code> behaves the same as <code class="language-cpp">f2</code> here, since we're invoking on an lvalue. If we were invoking on an rvalue of type <code class="language-cpp">D</code>, then this would <code class="language-cpp">f2</code> would behave the same by <code class="language-cpp">f3</code> would now return an rvalue reference to <code class="language-cpp">D::i</code>.</li>
</ul>
<p>But what if I really wanted to return <code class="language-cpp">B::i</code>? How do I do that? Today, we have two options. You could either cast <code class="language-cpp">this</code> to the appropriately qualified pointer to <code class="language-cpp">B</code> (or <code class="language-cpp">*this</code> to the appropriately qualified reference to <code class="language-cpp">B</code>), or you could use a more explicit member access syntax:</p>
<pre class="codehilite"><code class="language-cpp">template &lt;typename Self&gt;
auto&amp;&amp; f4() Self&amp;&amp; {
    // a forwarding reference to B::i
    return static_cast&lt;like_t&lt;Self, B&gt;&amp;&amp;&gt;(*this).i;
}

template &lt;typename Self&gt;
auto&amp;&amp; f5() Self&amp;&amp; {
    // lvalue reference to B::i (const or non-const)
    return this-&gt;B::i;
}

template &lt;typename Self&gt;
auto&amp;&amp; f6() Self&amp;&amp; {
    // forwarding reference to B::i
    return forward&lt;Self&gt;(*this).B::i;
}</code></pre>


<p>This is admittedly tricky, so we encourage authors to come up with a syntax where in we can deduce <code class="language-cpp">B</code> directly (instead of deducing <code class="language-cpp">D</code> in these cases).</p>
<h3 id="writing-the-function-pointer-types-for-such-functions">3.4. Writing the function pointer types for such functions<a class="self-link" href="#writing-the-function-pointer-types-for-such-functions"></a></h3>
<p>The proposed change allows for deducing the object parameter's value category and <em>cv</em>-qualifiers. But the member functions themselves are otherwise the same as you could express today, and their types do not change.</p>
<p>In other words, given:</p>
<pre class="codehilite"><code class="language-cpp">struct Y {
    int f(int, int) const&amp;;
    int g(int, int) Y const&amp;;
};</code></pre>


<p><code class="language-cpp">Y::f</code> and <code class="language-cpp">Y::g</code> are equivalent from a signature standpoint, so both <code class="language-cpp">&amp;Y::f</code> and <code class="language-cpp">&amp;Y::g</code> have the type <code class="language-cpp">int(Y::*)(int, int) const&amp;</code>.</p>
<p>Deduction doesn't change this either - it's just that we add the ability to deduce the class type as well as normal argument types:</p>
<pre class="codehilite"><code class="language-cpp">struct Z {
    template &lt;typename Self, typename T&gt;
    void h(T&amp;&amp;) Self&amp;&amp;;
};

struct DZ : Z { };

Z z;
z.h(1); // the pointer to the member function invoked by this
        // expression is void (Z::*)(int&amp;&amp;) &amp;

auto pmf = &amp;Z::h&lt;Z&amp;, int&gt;;
(z.*pmf)(1); // same as above

DZ const dz;
dz.h(2.0);  // the pointer to member function invoked by this 
            // expression is void (DZ::*)(double&amp;&amp;) const&amp;

auto pmf2 = &amp;Z::h&lt;DZ const&amp;, double&gt;
(dz.*pmf2)(2.0); // same as above</code></pre>


<h3 id="teachability-implications">3.5. Teachability Implications<a class="self-link" href="#teachability-implications"></a></h3>
<p>A natural extension of having trailing <em>cv-</em> and <em>ref-qualifiers</em> to non-static member functions is providing an explicit type that those qualifers refer to, instead of the implied class type. This keeps all of the qualifiers in the same place. The ability to deduce this type follows once we have a place where we can name it. </p>
<p>While having <code class="language-cpp">this</code> become dependent is novel, requiring all access through <code class="language-cpp">this</code> and forbidding "free" member access ensures that these functions will still be clear to write and understand. </p>
<h3 id="can-static-member-functions-have-an-explicit-object-type">3.6. Can <code class="language-cpp">static</code> member functions have an explicit object type?<a class="self-link" href="#can-static-member-functions-have-an-explicit-object-type"></a></h3>
<p>Since <code class="language-cpp">static</code> functions can also be invoked on objects, it raises the question of whether we could deduce that object as well (even if the function, being <code class="language-cpp">static</code>, would not take a binding to it). </p>
<p>But no. Static member functions currently do not have an implicit <code class="language-cpp">this</code> parameter, and therefore have no reason to provide an explicit type for one. </p>
<h3 id="interplays-with-capturing-this-and-this-in-lambdas">3.7. Interplays with capturing <code class="language-cpp">[this]</code> and <code class="language-cpp">[*this]</code> in lambdas<a class="self-link" href="#interplays-with-capturing-this-and-this-in-lambdas"></a></h3>
<p>Providing an explicit member type for lambdas still works, and even has some use, but the rules for what <code class="language-cpp">this</code> means in a lambda today still apply: <code class="language-cpp">this</code> can only ever refer to a captured member pointer of an outer member function, and never be a pointer to the lambda instance itself:</p>
<pre class="codehilite"><code class="language-cpp">struct X {
    int x, y;

    auto getter() const
    {
        return [*this]&lt;typename Self&gt;() Self&amp;&amp; {
            return x       // still refers to X::x
                + this-&gt;y; // still refers to X::y
        };
    }
};</code></pre>


<p>If other language features play with what <code class="language-cpp">this</code> means, they are completely orthogonal and do not have interplays with this proposal. However, it should be obvious that developers have great potential for introducing hard-to-read code if they are at all changing the meaning of <code class="language-cpp">this</code> in function bodies, especially in conjunction with this proposal.</p>
<h3 id="translating-code-to-use-explicit-member-types">3.8. Translating code to use explicit member types<a class="self-link" href="#translating-code-to-use-explicit-member-types"></a></h3>
<p>The most common qualifier overload sets for member functions are:</p>
<ol>
<li><code class="language-cpp">const</code> and non-<code class="language-cpp">const</code></li>
<li><code class="language-cpp">&amp;</code>, <code class="language-cpp">const&amp;</code>, <code class="language-cpp">&amp;&amp;</code>, and <code class="language-cpp">const&amp;&amp;</code></li>
<li><code class="language-cpp">const&amp;</code> and <code class="language-cpp">&amp;&amp;</code></li>
</ol>
<p>Some examples:</p>
<table>
<tr>
<th>

</th>
<th>
<p>Today</p>
</th>
<th>
<p>Proposed</p>
</th>
</tr>
<tr>
<td>
<p><code class="language-cpp">const</code> and non-<code class="language-cpp">const</code></p>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">struct foo {
    void bar();
    void bar() const;
};</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">struct foo {
    template &lt;typename Self&gt;
    void bar() Self;
}</code></pre>
</td>
</tr>
<td>
<p><code class="language-cpp">&amp;</code>, <code class="language-cpp">const&amp;</code>, <br /><code class="language-cpp">&amp;&amp;</code>, and <code class="language-cpp">const&amp;&amp;</code></p>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">struct foo {
  void quux() &amp;;
  void quux() const&amp;;
  void quux() &amp;&amp;;
  void quux() const&amp;&amp;;
};</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">struct foo {
    template &lt;typename Self&gt;
    void quux(Self&amp;&amp;);
};</code></pre>
</td>
</tr>
<tr>
<td>
<p>Just <code class="language-cpp">const&amp;</code> and <code class="language-cpp">&amp;&amp;</code></p>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">struct foo {
    void baz() const&amp;;
    void baz() &amp;&amp;;
};</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">struct foo {
    template &lt;typename Self&gt;
    void baz() Self&amp;&amp;;
};</code></pre>
</td>
</tr>
</table>

<p>The first two cases are neatly and exactly handled. For the third case, there is no direct equivalent - but such situations are typically just laziness on the part of the library developer rather than having a meaningful foundation; they are also simple to disable with a requires clause, now that the object type can be captured.</p>
<h3 id="parsing-issues">3.9. Parsing issues<a class="self-link" href="#parsing-issues"></a></h3>
<p>With the addition of a new type name after the <em>parameter-declaration-clause</em>, we potentially run into a clash with the existing <em>virt-specifier</em>s. In other words, this:</p>
<pre class="codehilite"><code class="language-cpp">struct B {
    virtual B* override() = 0;
};

struct override : B {
    override* override() override override; // #1
    override* override() override;          // #2
    override* override();                   // #3
};</code></pre>


<p>The same problem would occur with <code class="language-cpp">final</code>. </p>
<p>Dealing with <code class="language-cpp">#3</code> is easy - there is nothing to do. For <code class="language-cpp">#1</code> and <code class="language-cpp">#2</code>, the rule we propose is that we try to parse the explicit member type <em>first</em>, if possible. That is, for <code class="language-cpp">#2</code>, this is a member function with an explicit member type <code class="language-cpp">override</code> (that happens to override <code class="language-cpp">B::override</code>) but does not actually have a <em>virt-specifier</em>. For <code class="language-cpp">#1</code> then, the first use of <code class="language-cpp">override</code> is the explicit object type and the second use would be the <em>virt-specifier</em> <code class="language-cpp">override</code>. This changes the meaning of <code class="language-cpp">#2</code> from what it is today, but in practice we don't think anybody actually writes this seriously so it is unlikely to break real code.</p>
<p>As a result, this would be ill-formed:</p>
<pre class="codehilite"><code class="language-cpp">struct D : B {
    D* override() override D; // error
};</code></pre>


<p>because <code class="language-cpp">override</code> cannot be the explicit member type, so it's treated as the <em>virt-specifier</em>, and then <code class="language-cpp">D</code> cannot go in that spot.</p>
<p>But both of these would be okay, with <code class="language-cpp">override const</code> being the explicit member type:</p>
<pre class="codehilite"><code class="language-cpp">struct override : B {
    override* override() override const override; // ok
    override* override() const override override; // ok
};</code></pre>


<p>In the presented design, the type name is something that can be looked up - it's going to be the class name or a template parameter name or something. So adopting new context-sensitive keywords is also unlikely to cause a problem.</p>
<p>However, the design briefly discussed in Rapperswil would have allowed an arbitrary trailing identifier. That is:</p>
<pre class="codehilite"><code class="language-cpp">struct X {
    template &lt;typename Self&gt;
    auto&amp; foo() Self&amp;&amp; self {
        return self.i; // &lt;== self.i instead of this-&gt;i
    }
    int i;
};

struct override : B {
    override* override() override override override; // #4
};</code></pre>


<p>We feel that this would be grabbing too much real estate with minimal benefit - as it would constrain further evolution of the standard too much.</p>
<h3 id="alternative-solution">3.10. Alternative solution<a class="self-link" href="#alternative-solution"></a></h3>
<p>The initial revision approached the problem of deducing the object parameter with the introduction of an explicit object parameter rather than an explicit member type. The explicit object parameter fits more closely with many programmers' mental model of the this pointer being the first parameter to member functions "under the hood" and is comparable to usage in other languages, e.g. Python and Rust. The explicit member type is more consistent with the member functions we have today where the <em>cv-</em> and <em>ref-qualifiers</em> are trailing rather than leading. </p>
<p>The explicit parameter approach gave us the ability to have recursive lambdas without a new language feature:</p>
<pre class="codehilite"><code class="language-cpp">auto fib = [](this auto const&amp; self, int n) {
    if (n &lt; 2) return n;
    return self(n-1) + self(n-2);
};</code></pre>


<p>While this proposal lets us give a name to the lambda's <em>type</em>, it does not let us give a name to the lambda <em>instance</em>. So such recursion would still require a new language feature, such as <a href="https://wg21.link/p0839" title="Recursive Lambdas">P0839</a>.</p>
<p>However, it would prevent us from being able to just deduce <code class="language-cpp">const</code>-ness, as this proposal does. </p>
<p>Additionally, a named object parameter is arguably less confusing than having <code class="language-cpp">this</code> potentially refer to a different type - and makes it less surprising that we cannot directly acces our members without said parameter. Here is a comparison between this proposal and the R0 proposal adjusted for requiring explicit access for the initial <code class="language-cpp">optional</code> example. They are pretty similar:</p>
<table style="width:100%">
<tr>
<th style="width:50%">
<p>Explicit member type</p>
</th>
<th style="width:50%">
<p>Explicit object parameter</p>
</th>
</tr>
<tr>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
struct optional {
    template &lt;typename Self&gt;
    constexpr auto&amp;&amp; value() Self&amp;&amp; {
        if (!this-&gt;optional::has_value()) {
            throw bad_optional_access();
        }

        return forward&lt;Self&gt;(*this).optional::m_value;
    }





    template &lt;typename Self&gt;
    constexpr auto operator-&gt;() Self {
        return addressof(this-&gt;optional::m_value);
    }





    template &lt;typename Self, typename F&gt;
    constexpr auto and_then(F&amp;&amp; f) Self&amp;&amp; {
        using val = decltype((
            forward&lt;Self&gt;(*this).optional::m_value));
        using result = invoke_result_t&lt;F, val&gt;;

        static_assert(
          is_optional&lt;result&gt;::value,
          &quot;F must return an optional&quot;);

        return has_value()
            ? invoke(forward&lt;F&gt;(f),
                     forward&lt;Self&gt;(*this).optional::m_value
            : nullopt;
    }

};</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
struct optional {
    template &lt;typename Self&gt;
    constexpr auto&amp;&amp; value(this Self&amp;&amp; self) {
        // access is via self, not this
        if (!self.optional::has_value()) {
            throw bad_optional_access();
        }

        return forward&lt;Self&gt;(self).optional::m_value;
    }

    // NB: we deduce as Self&amp;&amp; here. We cannot just deduce
    // 'const'-ness because &quot;Self self&quot; looks like a value
    // parameter
    template &lt;typename Self&gt;
    constexpr auto operator-&gt;(Self&amp;&amp; self) {
        return addressof(self.optional::m_value);
    }

    // NB: the function parameter is the first parameter to
    // the function but is listed second. This would be 
    // invoked as opt.and_then(f)
    // Otherwise only difference is the name self vs this
    template &lt;typename Self, typename F&gt;
    constexpr auto and_then(this Self&amp;&amp; self, F&amp;&amp; f) {
        using val = decltype((
            forward&lt;Self&gt;(self).optional::m_value));
        using result = invoke_result_t&lt;F, val&gt;;

        static_assert(
          is_optional&lt;result&gt;::value,
          &quot;F must return an optional&quot;);

        return has_value()
            ? invoke(forward&lt;F&gt;(f),
                     forward&lt;Self&gt;(self).optional::m_value
            : nullopt;
    }
};</code></pre>
</td>
</tr>
</table>

<h3 id="potential-extensions">3.11. Potential Extensions<a class="self-link" href="#potential-extensions"></a></h3>
<p>There are a few syntactic extensions that would make it easier to deal with the case where we deduce a derived type but never actually want to use the derived type. </p>
<p>Today, it is legal to use a <em>qualified-id</em> to directly access a member of a particular object in the hierarchy. But there does not exist a syntax (outside of a <code class="language-cpp">static_cast</code>) to just get the base object. If we extend the access syntax to just allow for the naming of a type, we could get automatic qualification:</p>
<pre class="codehilite" data-line="7"><code class="language-cpp">struct B {
    int i;

    template &lt;typename Self&gt;
    auto foo() Self {
        auto i = this-&gt;B::i; // legal today
        auto b = this-&gt;B; // illegal today, proposed to have obvious meaning
    };
};

struct D : B { };

void ex(B&amp; b, D const&amp; cd) {
    b.foo();  // deduces Self as B, 'b' has type B*
    cd.foo(); // deduces Self as D const, 'b' has type B const*
}</code></pre>


<p>We could also introduce a new "magic" cast that just gives us a pointer to the type we're in right now from <code class="language-cpp">this</code>:</p>
<pre class="codehilite"><code class="language-cpp">struct B {
    template &lt;typename Self&gt;
    auto foo() Self {
        // core proposal to get a B [const]*
        auto b1 = static_cast&lt;conditional_t&lt;is_const_v&lt;Self&gt;, B const, B&gt;*&gt;(this);

        // above extension to get a B [const]*
        auto b2 = this-&gt;B;

        // magic cast
        auto b3 = this_cast(this);
    }
};</code></pre>


<p>This problem extends further than just to <code class="language-cpp">Self</code>, though. It is common to only want to deduce the ref-qualifier in all sorts of contexts. Any "make it easy to get the base class pointer"-style feature suffers extra instantiations when we only really want the instantiations for the base class. A complementary feature could be proposed that constrains <em>deduction</em> (as opposed to removing candidates once they are deduced, as with <code class="language-cpp">requires</code>, with the following straw-man syntax:</p>
<pre class="codehilite"><code class="language-cpp">struct B;

template &lt;typename T : B&gt;
void foo(T&amp;&amp; x) {
   static_assert(std::is_same_v&lt;B, std::remove_reference_t&lt;T&gt;&gt;);
}</code></pre>


<p>This would create a template function that may only generate functions that take a <code class="language-cpp">B</code>, ensuring that, when they participate in overload resolution, we don't generate additional instantiations. Such a proposal would change how templates participate in overload resolution, however, and is not to be attempted haphazardly.</p>
<p>If we had that, we could use it to constrain the deduction of <code class="language-cpp">Self</code>.</p>
<h2 id="real-world-examples">4. Real-World Examples<a class="self-link" href="#real-world-examples"></a></h2>
<h3 id="deduplicating-code">4.1. Deduplicating Code<a class="self-link" href="#deduplicating-code"></a></h3>
<p>This proposal can de-duplicate and de-quadruplicate a large amount of code. In each case, the single function is only slightly more complex than the initial two or four, which makes for a huge win. What follows are a few examples of how repeated code can be reduced.</p>
<p>The particular implementation of optional is Simon's, and can be viewed on <a href="https://github.com/TartanLlama/optional" title="Simon Brand's implementation of optional&lt;T&gt;">GitHub</a>, and this example includes some functions that are proposed in <a href="https://wg21.link/p0798" title="Monadic operations for std::optional">P0798</a>, with minor changes to better suit this format:</p>
<table style="width:100%">
<tr>
<th style="width:50%">
<p>C++17</p>
</th>
<th style="width:50%">
<p>This proposal</p>
</th>
</tr>
<tr>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">class TextBlock {
public:
  const char&amp; operator[](std::size_t position) const {
    // ...
    return text[position];
  }

  char&amp; operator[](std::size_t position) {
    return const_cast&lt;char&amp;&gt;(
      static_cast&lt;const TextBlock&amp;&gt;
        (this)[position]
    );
  }
  // ...
};</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">class TextBlock {
public:
  template &lt;typename Self&gt;
  auto&amp; operator[](std::size_t position) Self {
    // ...
    return this-&gt;text[position];
  }
  // ...
};</code></pre>
</td>
</tr>
<tr>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
  // ...
  constexpr T* operator-&gt;() {
    return std::addressof(this-&gt;m_value);
  }

  constexpr const T*
  operator-&gt;() const {
    return std::addressof(this-&gt;m_value);
  }
  // ...
};</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
  // ...
  template &lt;typename Self&gt;
  constexpr auto operator-&gt;() Self {
    return std::addressof(this-&gt;m_value);
  }
  // ...
};</code></pre>
</td>
</tr>
<tr>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
  // ...
  constexpr T&amp; operator*() &amp; {
    return this-&gt;m_value;
  }

  constexpr const T&amp; operator*() const&amp; {
    return this-&gt;m_value;
  }

  constexpr T&amp;&amp; operator*() &amp;&amp; {
    return std::move(this-&gt;m_value);
  }

  constexpr const T&amp;&amp;
  operator*() const&amp;&amp; {
    return std::move(this-&gt;m_value);
  }

  constexpr T&amp; value() &amp; {
    if (has_value()) {
      return this-&gt;m_value;
    }
    throw bad_optional_access();
  }

  constexpr const T&amp; value() const&amp; {
    if (has_value()) {
      return this-&gt;m_value;
    }
    throw bad_optional_access();
  }

  constexpr T&amp;&amp; value() &amp;&amp; {
    if (has_value()) {
      return std::move(this-&gt;m_value);
    }
    throw bad_optional_access();
  }

  constexpr const T&amp;&amp; value() const&amp;&amp; {
    if (has_value()) {
      return std::move(this-&gt;m_value);
    }
    throw bad_optional_access();
  }
  // ...
};</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
  // ...
  template &lt;typename Self&gt;
  constexpr like_t&lt;Self, T&gt;&amp;&amp; operator*() Self&amp;&amp; {
    return forward_like&lt;Self&gt;(*this).m_value;
  }

  template &lt;typename Self&gt;
  constexpr like_t&lt;Self, T&gt;&amp;&amp; value() Self&amp;&amp; {
    if (this-&gt;has_value()) {
      return forward_like&lt;Self&gt;(*this).m_value;
    }
    throw bad_optional_access();
  }
  // ...
};</code></pre>
</td>
</tr>
<tr>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
  // ...
  template &lt;typename F&gt;
  constexpr auto and_then(F&amp;&amp; f) &amp; {
    using result =
      invoke_result_t&lt;F, T&amp;&gt;;
    static_assert(
      is_optional&lt;result&gt;::value,
      &quot;F must return an optional&quot;);

    return has_value()
        ? invoke(forward&lt;F&gt;(f), **this)
        : nullopt;
  }

  template &lt;typename F&gt;
  constexpr auto and_then(F&amp;&amp; f) &amp;&amp; {
    using result =
      invoke_result_t&lt;F, T&amp;&amp;&gt;;
    static_assert(
      is_optional&lt;result&gt;::value,
      &quot;F must return an optional&quot;);

    return has_value()
        ? invoke(forward&lt;F&gt;(f),
                 std::move(**this))
        : nullopt;
  }

  template &lt;typename F&gt;
  constexpr auto and_then(F&amp;&amp; f) const&amp; {
    using result =
      invoke_result_t&lt;F, const T&amp;&gt;;
    static_assert(
      is_optional&lt;result&gt;::value,
      &quot;F must return an optional&quot;);

    return has_value()
        ? invoke(forward&lt;F&gt;(f), **this)
        : nullopt;
  }

  template &lt;typename F&gt;
  constexpr auto and_then(F&amp;&amp; f) const&amp;&amp; {
    using result =
      invoke_result_t&lt;F, const T&amp;&amp;&gt;;
    static_assert(
      is_optional&lt;result&gt;::value,
      &quot;F must return an optional&quot;);

    return has_value()
        ? invoke(forward&lt;F&gt;(f),
                 std::move(**this))
        : nullopt;
  }
  // ...
};</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename T&gt;
class optional {
  // ...
  template &lt;typename Self, typename F&gt;
  constexpr auto and_then(F&amp;&amp; f) Self&amp;&amp; {
    using val = decltype((
        forward&lt;Self&gt;(*this).m_value));
    using result = invoke_result_t&lt;F, val&gt;;

    static_assert(
      is_optional&lt;result&gt;::value,
      &quot;F must return an optional&quot;);

    return has_value()
        ? invoke(forward&lt;F&gt;(f),
                 forward&lt;Self&gt;(self).m_value)
        : nullopt;
  }
  // ...
};</code></pre>
</td>
</table>

<p>Keep in mind that there are a few more functions in P0798 that have this lead to this explosion of overloads, so the code difference and clarity is dramatic.</p>
<p>For those that dislike returning auto in these cases, it is very easy to write a metafunction that matches the appropriate qualifiers from a type. Certainly simpler than copying and pasting code and hoping that the minor changes were made correctly in every case.</p>
<h3 id="crtp-without-the-c-r-or-even-t">4.2. CRTP, without the C, R, or even T<a class="self-link" href="#crtp-without-the-c-r-or-even-t"></a></h3>
<p>Today, a common design pattern is the Curiously Recurring Template Pattern. This implies passing the derived type as a template parameter to a base class template, as a way of achieving static polymorphism. If we wanted to just outsource implementing postfix incrementing to a base, we could use CRTP for that. But with explicit object parameters that deduce to the derived objects already, we don't need any curious recurrence. We can just use standard inheritance and let deduction just do its thing. The base class doesn't even need to be a template:</p>
<table style="width:100%">
<tr>
<th style="width:50%">
<p>C++17</p>
</th>
<th style="width:50%">
<p>Proposed</p>
</th>
</tr>
<tr>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename Derived&gt;
struct add_postfix_increment {
    Derived operator++(int) {
        auto&amp; self = static_cast&lt;Derived&amp;&gt;(*this);

        Derived tmp(self);
        ++self;
        return tmp;
    }
};

struct some_type : add_postfix_increment&lt;some_type&gt; {
    some_type&amp; operator++() { ... }
};</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">struct add_postfix_increment {
    template &lt;typename Self&gt;
    Self operator++(int) Self {
        Self tmp(self);
        ++self;
        return tmp;
    }
};



struct some_type : add_postfix_increment {
    some_type&amp; operator++() { ... }
};</code></pre>
</td>
</tr>
</table>

<p>The example at right isn't much shorter, but it is certainly simpler.</p>
<h4 id="builder-pattern">4.2.1. Builder pattern<a class="self-link" href="#builder-pattern"></a></h4>
<p>However, once we start to do any more with CRTP, it can get increasingly complex very fast... whereas with this proposal, it stays remarkably simple.</p>
<p>Let's say we have a builder that does a lot of things. We might start with:</p>
<pre class="codehilite"><code class="language-cpp">struct Builder {
  Builder&amp; a() { /* ... */; return *this; }
  Builder&amp; b() { /* ... */; return *this; }
  Builder&amp; c() { /* ... */; return *this; }
};

Builder().a().b().a().b().c();</code></pre>


<p>But now, we want to create a specialized builder that has new operations <code class="language-cpp">d()</code> and <code class="language-cpp">e()</code>. This specialized builder needs new member functions, and we don't want to burden existing users with them. But we also want <code class="language-cpp">Special().a().d()</code> to work - so we need to use CRTP to <em>conditionally</em> return either a <code class="language-cpp">Builder&amp;</code> or a <code class="language-cpp">Special&amp;</code>:</p>
<table style="width:100%">
<tr>
<th style="width:50%">
<p>C++ today</p>
</th>
<th>
<p>Proposed</p>
</th>
</tr>
<tr>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename D=void&gt;
class Builder {
  using Derived = conditional_t&lt;is_void_v&lt;D&gt;, Builder, D&gt;;
  Derived&amp; self() {
    return *static_cast&lt;Derived*&gt;(this);
  }

public:
  Derived&amp; a() { /* ... */; return self(); }
  Derived&amp; b() { /* ... */; return self(); }
  Derived&amp; c() { /* ... */; return self(); }
};

struct Special : Builder&lt;Special&gt; {
  Special&amp; d() { /* ... */; return *this; }
  Special&amp; e() { /* ... */; return *this; }
};

Builder().a().b().a().b().c();
Special().a().d().e().a();</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">struct Builder {
    template &lt;typename Self&gt;
    Self&amp; a() Self&amp;&amp; { /* ... */; return self; }

    template &lt;typename Self&gt;
    Self&amp; b() Self&amp;&amp; { /* ... */; return self; }

    template &lt;typename Self&gt;
    Self&amp; c() Self&amp;&amp; { /* ... */; return self; }        
};

struct Special : Builder {
    Special&amp; d() { /* ... */; return *this; }
    Special&amp; e() { /* ... */; return *this; }
};

Builder().a().b().a().b().c();
Special().a().d().e().a();</code></pre>
</td>
</tr>
</table>

<p>The code on the right is dramatically easier to understand and more accessible to more programmers than the code on the left.</p>
<p>But what, there's more.</p>
<p>What if we add a <em>super</em>-specialized builder, that is a more special form of <code class="language-cpp">Special</code>? Now we need <code class="language-cpp">Special</code> to itself opt-in to CRTP so it knows which type to pass to <code class="language-cpp">Builder</code> so that everything in the hierarchy can return the correct type. It's roughly at this point that people just give up and start gently weeping. But with this proposal, no problem!</p>
<table style="width:100%">
<tr>
<th style="width:50%">
<p>C++ today</p>
</th>
<th>
<p>Proposed</p>
</th>
</tr>
<tr>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">template &lt;typename D=void&gt;
class Builder {
protected:
  using Derived = conditional_t&lt;is_void_v&lt;D&gt;, Builder, D&gt;;
  Derived&amp; self() {
    return *static_cast&lt;Derived*&gt;(this);
  }

public:
  Derived&amp; a() { /* ... */; return self(); }
  Derived&amp; b() { /* ... */; return self(); }
  Derived&amp; c() { /* ... */; return self(); }
};

template &lt;typename D=void&gt;
struct Special
  : Builder&lt;conditional_t&lt;is_void_v&lt;D&gt;,Special&lt;D&gt;,D&gt;
{
  using Derived = typename Special::Builder::Derived;
  Derived&amp; d() { /* ... */; return this-&gt;self(); }
  Derived&amp; e() { /* ... */; return this-&gt;self(); }
};

struct Super : Special&lt;Super&gt;
{
    Super&amp; f() { /* ... */; return *this; }
};

Builder().a().b().a().b().c();
Special().a().d().e().a();
Super().a().d().f().e();</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">struct Builder {
    template &lt;typename Self&gt;
    Self&amp; a() Self&amp;&amp; { /* ... */; return self; }

    template &lt;typename Self&gt;
    Self&amp; b() Self&amp;&amp; { /* ... */; return self; }

    template &lt;typename Self&gt;
    Self&amp; c() Self&amp;&amp; { /* ... */; return self; }        
};

struct Special : Builder {
    template &lt;typename Self&gt;
    Self&amp; d() Self&amp;&amp; { /* ... */; return self; }

    template &lt;typename Self&gt;
    Self&amp; e() Self&amp;&amp; { /* ... */; return self; }
};

struct Super : Special {
    Super&amp; f() Self&amp;&amp; { /* ... */; return *this; }
};

Builder().a().b().a().b().c();
Special().a().d().e().a();
Super().a().d().f().e();</code></pre>
</td>
</tr>
</table>

<p>That is just so much easier on the right. There are simply so many situations where this idiom, if available, would give programmers an easier, accessible solution to problems that they just cannot easily solve today.</p>
<h4 id="a-new-syntax-for-opt-in">4.2.2. A new syntax for opt-in<a class="self-link" href="#a-new-syntax-for-opt-in"></a></h4>
<p>Today, with <a href="https://wg21.link/p0515" title="Consistent comparison">P0515</a>, the way that you opt-in to a defaulted comparison is via:</p>
<pre class="codehilite"><code class="language-cpp">struct A {
    int i;
    char c;
    double d;

    auto operator&lt;=&gt;(A const&amp;) const = default;
};</code></pre>


<p>This isn't that much to type, and it's a massive improvement over the C++17 implementation of equivalent functionality. But in larger classes, it's easy to lose these kinds of important declarations in the noise. We could use this new non-CRTP version of CRTP to provide a novel annotation for types, which would lead to even less typing for this kind of opt-in while also ensuring that the annotation that is provided is much more visible. </p>
<table style="width:100%">
<tr>
<th style="width:50%">
<p>C++ today</p>
</th>
<th>
<p>Proposed</p>
</th>
</tr>
<tr>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">struct A {
    int i;
    char c;
    double d;

    auto operator&lt;=&gt;(A const&amp;) const = default;
};</code></pre>
</td>
<td>
<pre style="background:transparent;border:0px"><code class="language-cpp">struct Ord {
    template &lt;typename Self&gt;
    auto operator&lt;=&gt;(Self const&amp; rhs) Self const&amp; = default;
};

struct A
    : Ord // &lt;== first thing we write
{
    int i;
    char c;
    double d;

    // no other declarations
};</code></pre>
</td>
</tr>
</table>

<h3 id="forwarding-lambdas">4.3. Forwarding Lambdas<a class="self-link" href="#forwarding-lambdas"></a></h3>
<p>This proposal allows you to store values in a lambda and then either move or copy them out, depending on the lambda is invoked. We could already do this today for class types:</p>
<pre class="codehilite"><code class="language-cpp">template &lt;typename T&gt;
struct Holder {
    T value;

    T&amp;        operator()() &amp;       { return value; }
    T const&amp;  operator()() const&amp;  { return value; }
    T&amp;&amp;       operator()() &amp;&amp;      { return move(value); }
    T const&amp;&amp; operator()() const&amp;&amp; { return move(value); }
};</code></pre>


<p>But now you can do this with a lambda too:</p>
<pre class="codehilite"><code class="language-cpp">auto holder = [value=...]&lt;typename Self&gt;() Self&amp;&amp; {
    return static_cast&lt;decltype((value))&gt;(value);
};</code></pre>


<h3 id="sfinae-friendly-callables">4.4. SFINAE-friendly callables<a class="self-link" href="#sfinae-friendly-callables"></a></h3>
<p>A seemingly unrelated problem to the question of code quadruplication is that of writing these numerous overloads for function wrappers, as demonstrated in <a href="https://wg21.link/p0826" title="SFINAE-friendly std::bind">P0826</a>. Consider what happens if we implement <code class="language-cpp">std::not_fn()</code>, as currently specified:</p>
<pre class="codehilite"><code class="language-cpp">template &lt;typename F&gt;
class call_wrapper {
    F f;
public:
    // ...
    template &lt;typename... Args&gt;
    auto operator()(Args&amp;&amp;... ) &amp;
        -&gt; decltype(!declval&lt;invoke_result_t&lt;F&amp;, Args...&gt;&gt;());

    template &lt;typename... Args&gt;
    auto operator()(Args&amp;&amp;... ) const&amp;
        -&gt; decltype(!declval&lt;invoke_result_t&lt;const F&amp;, Args...&gt;&gt;());

    // ... same for &amp;&amp; and const &amp;&amp; ...
};

template &lt;typename F&gt;
auto not_fn(F&amp;&amp; f) {
    return call_wrapper&lt;std::decay_t&lt;F&gt;&gt;{std::forward&lt;F&gt;(f)};
}</code></pre>


<p>As described in the paper, this implementation has two pathological cases: one in which the callable is SFINAE-unfriendly (which would cause a call to be ill-formed, when it could otherwise work), and one in which overload is deleted (which would cause a call to fall-back to a different overload, when it should fail):</p>
<pre class="codehilite"><code class="language-cpp">struct unfriendly {
    template &lt;typename T&gt;
    auto operator()(T v) {
        static_assert(std::is_same_v&lt;T, int&gt;);
        return v;
    }

    template &lt;typename T&gt;
    auto operator()(T v) const {
        static_assert(std::is_same_v&lt;T, double&gt;);
        return v;
    }
};

struct fun {
    template &lt;typename... Args&gt;
    void operator()(Args&amp;&amp;...) = delete;

    template &lt;typename... Args&gt;
    bool operator()(Args&amp;&amp;...) const { return true; }
};

std::not_fn(unfriendly{})(1); // static assert!
                              // even though the non-const overload is viable and would be the best
                              // match, during overload resolution, both overloads of unfriendly have
                              // to be instantiated - and the second one is a hard compile error.

std::not_fn(fun{})();         // ok!? Returns false
                              // even though we want the non-const overload to be deleted, the const
                              // overload of the call_wrapper ends up being viable - and the only viable
                              // candidate.</code></pre>


<p>Gracefully handling SFINAE-unfriendly callables is <strong>not solvable</strong> in C++ today. Preventing fallback can be solved by the addition of yet another four overloads, so that each of the four <em>cv</em>/ref-qualifiers leads to a pair of overloads: one enabled and one <code class="language-cpp">deleted</code>.</p>
<p>This proposal solves both problems by simply allowing <code class="language-cpp">this</code> to be deduced. The following is a complete implementation of <code class="language-cpp">std::not_fn</code>:</p>
<pre class="codehilite"><code class="language-cpp">template &lt;typename F&gt;
struct call_wrapper {
    F f;

    template &lt;typename Self, typename... Args&gt;
    auto operator()(Args&amp;&amp;... args) Self&amp;&amp;
        -&gt; decltype(!invoke(forward_like&lt;Self&gt;(this-&gt;f), forward&lt;Args&gt;(args)...))
    {
        return !invoke(forward_like&lt;Self&gt;(this-&gt;f), forward&lt;Args&gt;(args)...);
    }
};

template &lt;typename F&gt;
auto not_fn(F&amp;&amp; f) {
    return call_wrapper&lt;decay_t&lt;F&gt;&gt;{forward&lt;F&gt;(f)};
}

not_fn(unfriendly{})(1); // ok
not_fn(fun{})();         // error</code></pre>


<p>Here, there is only one overload with everything deduced together. The first example now works correctly. <code class="language-cpp">Self</code> gets deduced as <code class="language-cpp">call_wrapper&lt;unfriendly&gt;</code>, and the one <code class="language-cpp">operator()</code> will only consider <code class="language-cpp">unfriendly</code>'s non-<code class="language-cpp">const</code> call operator. The <code class="language-cpp">const</code> one is simply never considered, so does not have an opportunity to cause problems. The call works. </p>
<p>The second example now fails correctly. Previously, we had four candidates: the two non-<code class="language-cpp">const</code> ones were removed from the overload set due to <code class="language-cpp">fun</code>'s non-<code class="language-cpp">const</code> call operator being <code class="language-cpp">delete</code>d, and the two <code class="language-cpp">const</code> ones which were viable. But now, we only have one candidate. <code class="language-cpp">Self</code> gets deduced as <code class="language-cpp">call_wrapper&lt;fun&gt;</code>, which requires <code class="language-cpp">fun</code>'s non-<code class="language-cpp">const</code> call operator to be well-formed. Since it is not, the call is an error. There is no opportunity for fallback since there is only one overload ever considered. </p>
<p>As a result, this singular overload then has precisely the desired behavior: working, for <code class="language-cpp">unfriendly</code>, and not working, for <code class="language-cpp">fun</code>.</p>
<p>Note that this could also be implemented as a lambda completely within the body of <code class="language-cpp">not_fn</code>:</p>
<pre class="codehilite"><code class="language-cpp">template &lt;typename F&gt;
auto not_fn(F&amp;&amp; f) {
    return [f=forward&lt;F&gt;(f)]&lt;typename Self, typename... Args&gt;(auto&amp;&amp;.. args) Self&amp;&amp;
        -&gt; decltype(!invoke(forward_like&lt;Self&gt;(f), forward&lt;Args&gt;(args)...))
    {
        return !invoke(forward_like&lt;Self&gt;(f), forward&lt;Args&gt;(args)...);
    };
}</code></pre>


<h2 id="acknowledgements">5. Acknowledgements<a class="self-link" href="#acknowledgements"></a></h2>
<p>The authors would like to thank:</p>
<ul>
<li>Jonathan Wakely, for bringing us all together by pointing out we were writing the same paper, twice</li>
<li>Chandler Carruth for a lot of feedback and guidance around design issues</li>
<li>Graham Heynes, Andrew Bennieston, Jeff Snyder for early feedback regarding the meaning of <code class="language-cpp">this</code> inside function bodies</li>
<li>Amy Worthington, Jackie Chen, Vittorio Romeo, Tristan Brindle, Agustรญn Bergรฉ, Louis Dionne, and Michael Park for early feedback</li>
<li>Guilherme Hartmann for his guidance with the implementation</li>
</ul>
<h2 id="references">6. References<a class="self-link" href="#references"></a></h2><ul><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0515r3.pdf">[P0515]</a><span style="margin-left: 5px;">"Consistent comparison" by Herb Sutter, Jens Maurer, Walter E. Brown, 2017-11-10</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0798r0.html">[P0798]</a><span style="margin-left: 5px;">"Monadic operations for std::optional" by Simon Brand, 2017-10-06</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0826r0.html">[P0826]</a><span style="margin-left: 5px;">"SFINAE-friendly std::bind" by Agustรญn Bergรฉ, 2017-10-12</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0839r0.html">[P0839]</a><span style="margin-left: 5px;">"Recursive Lambdas" by Richard Smith, 2017-10-16</span></li><li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0847r0.html">[P0847R0]</a><span style="margin-left: 5px;">"Deducing this" by Gaลกper Aลพman, Simon Brand, Ben Deane, Barry Revzin, 2018-02-12</span></li><li><a href="https://github.com/TartanLlama/optional">[brand.optional]</a><span style="margin-left: 5px;">Simon Brand's implementation of optional&lt;T&gt;</span></li><li><a href="https://www.aristeia.com/books.html">[meyers.effective]</a><span style="margin-left: 5px;">"Effective C++, Third Edition" by Scott Meyers, 2005</span></li><li><a href="">[rap.p0847r0]</a><span style="margin-left: 5px;">RAP Wiki notes, P0847R0 - June 2018</span></li></ul>
</html>