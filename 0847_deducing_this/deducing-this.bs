<pre class='metadata'>
Title: Deducing `this`
Status: D
ED: http://wg21.link/P0847
Shortname: D0847
Level: 1
Date: 2018-09-30
Editor: Gašper Ažman, gasper dot azman at gmail dot com
Editor: Simon Brand, simon at codeplay dot com
Editor: Ben Deane, ben at elbeno dot com
Editor: Barry Revzin, barry dot revzin at gmail dot com
Group: wg21
Audience: EWG
Markup Shorthands: markdown yes
Default Highlight: C++
Abstract: We propose a new mechanism for specifying or deducing the value category of an instance of a class. In other words, a way to tell from within a member function whether the object it's invoked on is an lvalue or an rvalue, whether it is const or volatile, and what type the object is.
</pre>

<pre class="biblio">
{
    "Effective": {
        "authors": ["Scott Meyers"],
        "title": "Effective C++, Third Edition",
        "href": "https://www.aristeia.com/books.html",
        "date": "2005"
    }
}
</pre>

# Revision History # {#revision-history}

## Changes since r0 ## {#changes-since-r0}

[[P0847R0]] was presented in Rapperswil in June 2018 using an already adjusted syntax from the one used in the paper, using `this Self&& self` to indicate the explicit object parameter rather than the `Self&& this self` that appeared in r0 of this paper. 

EWG strongly encouraged us to look in two new directions:

- a different syntax, placing the type of the object parameter after the member function parameter declarations (where the *cv-ref* qualifiers are today)
- a different name lookup scheme, to not have implicit/unqualified access from inside of new-style member functions that have an explicit self-type annotation (regardless of syntax).

This revision carefully explores both of these directions and presents different syntaxes and lookup schemes and discusses in depth multiple different use-cases and how each of the syntaxes can or cannot address the use-cases. 

# Motivation # {#motivation}

In C++03, member functions could have *cv*-qualifications, so it was possible to have scenarios where a particular class would want both a `const` and non-`const` overload of a particular member (Of course it was possible to also want `volatile` overloads, but those are less common). In these cases, both overloads do the same thing - the only difference is in the types accessed and used. This was handled by either simply duplicating the function, adjusting types and qualifications as necessary, or having one delegate to the other. An example of the latter can be found in Scott Meyers' "Effective C++" [[Effective]], Item 3:

```cpp
class TextBlock {
public:
  const char& operator[](std::size_t position) const {
    // ...
    return text[position];
  }

  char& operator[](std::size_t position) {
    return const_cast<char&>(
      static_cast<const TextBlock&>(*this)[position]
    );
  }
  // ...
};
```

Arguably, neither the duplication or the delegation via `const_cast` are great solutions, but they work.

In C++11, member functions acquired a new axis to specialize on: ref-qualifiers. Now, instead of potentially needing two overloads of a single member function, we might need four: `&`, `const&`, `&&`, or `const&&`. We have three approaches to deal with this: we implement the same member four times, we can have three of the overloads delegate to the fourth, or we can have all four delegate to a helper, private static member function. One example might be the overload set for `optional<T>::value()`. The way to implement it would be something like:

<table style="width:100%">
<tr>
<th style="width:33%">
Quadruplication
</th>
<th style="width:33%">
Delegation to 4th
</th>
<th style="width:33%">
Delegation to helper
</th>
</tr>
<tr>
<td>
```cpp
template <typename T>
class optional {
  // ...
  constexpr T& value() & {
    if (has_value()) {
      return this->m_value;
    }
    throw bad_optional_access();
  }

  constexpr const T& value() const& {
    if (has_value()) {
      return this->m_value;
    }
    throw bad_optional_access();
  }

  constexpr T&& value() && {
    if (has_value()) {
      return std::move(this->m_value);
    }
    throw bad_optional_access();
  }

  constexpr const T&&
  value() const&& {
    if (has_value()) {
      return std::move(this->m_value);
    }
    throw bad_optional_access();
  }
  // ...
};
```
</td>
<td>
```cpp
template <typename T>
class optional {
  // ...
  constexpr T& value() & {
    return const_cast<T&>(
      static_cast<optional const&>(
        *this).value());
  }

  constexpr const T& value() const& {
    if (has_value()) {
      return this->m_value;
    }
    throw bad_optional_access();
  }

  constexpr T&& value() && {
    return const_cast<T&&>(
      static_cast<optional const&>(
        *this).value());
  }

  constexpr const T&&
  value() const&& {
    return static_cast<const T&&>(
      value());
  }
  // ...
};
```
</td>
<td>
```cpp
template <typename T>
class optional {
  // ...
  constexpr T& value() & {
    return value_impl(*this);
  }

  constexpr const T& value() const& {
    return value_impl(*this);
  }

  constexpr T&& value() && {
    return value_impl(std::move(*this));
  }

  constexpr const T&&
  value() const&& {
    return value_impl(std::move(*this));
  }

private:
  template <typename Opt>
  static decltype(auto)
  value_impl(Opt&& opt) {
    if (!opt.has_value()) {
      throw bad_optional_access();
    }
    return std::forward<Opt>(opt).m_value;
  }
  // ...
};
```
</td>
</tr>
</table>

It's not like this is a complicated function. Far from. But more or less repeating the same code four times, or artificial delegation to avoid doing so, is the kind of thing that begs for a rewrite. Except we can't really. We *have* to implement it this way. It seems like we should be able to abstract away the qualifiers. And we can... sort of. As a non-member function, we simply don't have this problem:

```cpp
template <typename T>
class optional {
    // ...
    template <typename Opt>
    friend decltype(auto) value(Opt&& o) {
        if (o.has_value()) {
            return std::forward<Opt>(o).m_value;
        }
        throw bad_optional_access();
    }
    // ...
};
```

This is great - it's just one function, that handles all four cases for us. Except it's a non-member function, not a member function. Different semantics, different syntax, doesn't help.

There are many, many cases in code-bases where we need two or four overloads of the same member function for different `const`- or ref-qualifiers. More than that, there are likely many cases that a class should have four overloads of a particular member function, but doesn't simply due to laziness by the developer. We think that there are sufficiently many such cases that they merit a better solution than simply: write it, then write it again, then write it two more times.

# Proposal # {#proposal}

We propose a new way of declaring non-static member functions that will allow for deducing the type and value category of the class instance parameter, while still being invocable with regular member function syntax. 

We believe that the ability to write *cv-ref qualifier*-aware member functions without duplication will improve code maintainability, decrease the likelihood of bugs, and allow users to write fast, correct code more easily. 

The proposal is also sufficiently general and sufficiently orthogonal that it allows for several new exciting features and design patterns for C++:

- [recursive lambdas](#recursive-lambdas)
- a new approach to [mixins](#crtp), a CRTP without the CRT
- perfect, sfinae-friendly [call wrappers](#sfinae-friendly-callables)
- more efficient member function [invocation](#by-value-member-functions)

These will be explored in detail in the [examples](#real-world-examples) section.

## Proposed Syntaxes ## {#proposed-syntaxes}

There are three different syntaxes that we can use to solve this problem. We will use them throughout the examples in the rest of proposal. This section just briefly goes through the syntax options - the semantics will be more thoroughly explained in later sections.

### Explicit object parameter ### {#explicit-object-parameter}

A non-static member function can be declared to take as its first parameter an *explicit object parameter*, denoted with the prefixed keyword `this`. Once we elevate the object parameter to a proper function parameter, it can easily be deduced following normal function template deduction rules:

```cpp
struct X {
    void foo(this X const& self, int i);
    
    template <typename Self>
    void bar(this Self&& self);
};

struct D : X { };

void ex(X& x, D const& d) {
    x.foo(42);          // 'self' is bound to 'x', 'i' is 42
    x.bar();            // deduces Self as X&, calls X::bar<X&>
    std::move(x).bar(); // deduces Self as X, calls X::bar<X>
    
    d.foo(17);          // 'self' is bound to 'd'
    d.bar();            // deduces Self as D const&, calls X::bar<D const&>
}
```

Member functions with an explicit object parameter cannot be `static` or have *cv*- or *ref*-qualifiers. 

A call to a member function will interpret the object parameter as the first argument to such a member function, the first argument in the parenthesized expression list as the second parameter, and so forth. 

Following normal deduction rules, the template parameter corresponding to the explicit object parameter can deduce to a type derived from the class the member function is declared in (as in the example above for `d.bar()`).

### Explicit member type, with identifier ### {#explicit-member-type-with-identifier}

Today, member functions can optionally have a *cv-qualifier* and can optionally have a *ref-qualifier*. We can extend this to allow a full type and an identifier - so that the trailer of the member function declaration effectively becomes a variable declaration for the object parameter:

```cpp
struct X {
    void foo(int i) X const& self;
    
    template <typename Self>
    void bar() Self&& self;
}; 

struct D : X { };

void ex(X& x, D const& d) {
    x.foo(42);          // 'self' is bound to 'x', 'i' is 42
    x.bar();            // deduces Self as X&, calls X::bar<X&>
    std::move(x).bar(); // deduces Self as X, calls X::bar<X>
    
    d.foo(17);          // 'self' is bound to 'd'
    d.bar();            // deduces Self as D const&, calls X::bar<D const&>
}
```

Effectively, this is taking the previously introduced explicit object parameter syntax and simply declaring it after in the parameter declaration clause instead of at the front of it. Existing member functions behave as if the class name were just omitted. 

Member functions with an explicit member type cannot be `static`. 
    
### Explicit member type, without identifier ### {#explicit-member-type-without-identifier}

Similar to the above, except without a possible identifier. 

```cpp
struct X {
    void foo(int i) X const&;
    
    template <typename Self>
    void bar() Self&&;
}; 

struct D : X { };

void ex(X& x, D const& d) {
    x.foo(42);          // this is a X const*
    x.bar();            // deduces Self as X&, this is a X*
    std::move(x).bar(); // deduces Self as X, this is a X*
    
    d.foo(17);          // this is a X const*
    d.bar();            // deduces Self as D const&, this is a D const*
}
```

Because we need a way to refer to the derived object and we no longer have a way to name it, `this` would become a const pointer to the specified type after having its reference stripped. In the previous syntaxes, `this` could either retain its current meaning or cease to exist at all (see [name lookup](#name-lookup-within-member-functions)), but without an extra name we need to have `this` refer to the object parameter - which in some cases means that `this` would be a pointer to a derived type.
    
### Quick comparison ### {#quick-comparison}

A brief example demonstrating how to write `optional::value()` and `optional::operator->()` in just two functions with no duplication (instead of six) with each of the three proposed syntaxes.

There are several options we have as to the semantics of `this` within member function bodies, so this quick example just takes the most conservative approach - it is merely meant to be illustrative:

<table style="width:100%">
<tr>
<th style="width:33%">
Explicit object parameter
</th>
<th style="width:33%">
Explicit member type<br />with identifier
</th>
<th style="width:33%">
Explicit member type<br />without identifier
</th>
</tr>
<tr>
<td>
```cpp
template <typename T>
struct optional {
  template <typename Self>
  constexpr auto&& value(this Self&& self) {
    if (!self.has_value()) {
      throw bad_optional_access();
    }
        
    return forward<Self>(*self).m_value;
  }
    
  template <typename Self>
  constexpr auto operator->(this Self&& self) {
    return addressof(self.m_value);
  }
};
```
</td>
<td>
```cpp
template <typename T>
struct optional {
  template <typename Self>
  constexpr auto&& value() Self&& self {
    if (!self.has_value()) {
      throw bad_optional_access();
    }
        
    return forward<Self>(*self).m_value;
  }
    
  template <typename Self>
  constexpr auto operator->() Self self {
    return addressof(self.m_value);
  }
};
```
</td>
<td>
```cpp
template <typename T>
struct optional {
  template <typename Self>
  constexpr auto&& value() Self&& {
    if (!this->has_value()) {
      throw bad_optional_access();
    }
        
    return forward<Self>(*this).m_value;
  }
    
  template <typename Self>
  constexpr auto operator->() Self {
    return addressof(this->m_value);
  }
};
```
</td>
</tr>
</table>

Note that the two syntaxes with explicit member type declare the `self` parameter to just have type `Self` while the explicit object parameter syntax still uses `Self&&`. This will be explained further in the section about [by value `this`](#by-value-this).

## Proposed semantics ## {#proposed-semantics}

What follows is a description of how deducing `this` affects all the important language constructs: name lookup, type deduction, overload resolution, and so forth. 

This is a strict extension to the language; nearly all existing syntax remains valid. See [parsing issues](#parsing-issues) for the pathological case that may change meaning. 

### Name lookup: candidate functions ### {#name-lookup-candidate-functions}

Today, when either invoking a named function or an operator (including the call operator) on an object of class type, name lookup will include both static and non-static member functions found by regular class lookup. Non-static member functions are treated as if there were an implicit object parameter whose type is an lvalue or rvalue reference to *cv* `X` (where the reference and *cv* qualifiers are determined based on the function's qualifiers) which binds to the object on which the function was invoked. 

For non-static member functions using any of the new syntax (whether an **explicit** object parameter or a full **explicit** member type), lookup will work the same way as other member functions today, except rather than implicitly determining the type of the object parameter based on the *cv*- and *ref*-qualifiers of the member function, these are explicitly determined by the provided type. The following examples illustrate this concept.

<table style="width:100%">
<tr>
<th style="width:33%">C++17</th>
<th style="width:33%">With Explicit Object</th>
<th style="width:33%">With Explicit Type</th>
</tr>
<tr>
<td>
```cpp
struct X {
  // implicit object has type X&
  void foo() &;

  // implicit object has type X const&
  void foo() const&;

  // implicit object has type X&&
  void bar() &&;
};
```
</td>
<td>
```cpp
struct X {
  // explicit object has type X&
  void foo(this X&);
  
  // explicit object has type X const&
  void foo(this X const&);
  
  // explicit object has type X&&
  void bar(this X&&);
};
```
<td>
```cpp
struct X {
  // explicit object has type X&
  void foo() X&;

  // explicit object has type X const&
  void foo() X const&;

  // explicit object type X&&
  void bar() X&&;
};
```
</td>
</tr>
</table>

Name lookup on an expression like `obj.foo()` today would find both overloads of `foo` in the first column today - and potentially the non-const overload would not be a viable candidate if `obj` were const. 

With either of the proposed syntaxes, either explicit object or explicit type, `obj.foo()` would continue to find both overloads of `foo` - with the non-const one potentially not being a viable candidate.

The only change with how we lookup candidate functions is that, in the case of an explicit object parameter, the argument list is shifted by one. The first listed parameter would be the object parameter, and the second listed parameter would correspond to the first called argument.

We are not changing anything about overload *resolution* - simply extending the candidate set to include this new way of writing a non-static member function. We're simply being explicit rather than implicit about the object parameter. Given a call to `x.foo()`, overload resolution would still select the first `foo()` overload if `x` isn't `const` and the second if it is.

The behaviors of the three columns as proposed are exactly equivalent.

The only change as far as candidates are considered is that the proposal allows for deduction of the object parameter - which is new for the language.

### Type deduction ### {#type-deduction}

One of the main motivations of this proposal is to deduce the *cv*-qualifiers and value category of the class object, so the explicit member object or type needs to be deducible from the object that the member function is invoked on.

If either the explicit object parameter's type or explicit member type is a deduced reference type, all of the usual template deduction rules apply as expected:

<table style="width:100%">
<tr>
<th style="width:50%">Explicit object parameter</th>
<th style="width:50%">Explicit member type</th>
</tr>
<tr>
<td>
```cpp
struct X {
  template <typename Self>
  void foo(this Self&&, int);
};

struct D : X { };

void ex(X& x, D& d) {
    x.foo(1);       // Self=X&
    move(x).foo(2); // Self=X
    d.foo(3);       // Self=D&
}
```
</td>
<td>
```cpp
struct X {
  template <typename Self>
  void foo(int) Self&&;
};

struct D : X { };

void ex(X& x, D& d) {
    x.foo(1);       // Self=X&
    move(x).foo(2); // Self=X
    d.foo(3);       // Self=D&
}
```
</td>
</tr>
</table>

It's important to stress that deduction can deduce a derived type. In the last line, regardless of syntax, `Self` deduces as `D&`. This has implications of [name lookup within member function bodies](#name-lookup-within-member-functions), and also leads to a potential [template deduction extension](#potential-extensions).

### By value `this` ### {#by-value-this}

But what if the explicit type does not have reference type? This is one key point where the proposed rules for having an explicit object parameter and having an explicit member type diverge. For both syntaxes, there is a clear meaning - it's just that it is very different clear meaning.

In the case of explicit object parameter, what does this mean:

```c++
struct less_than {
    template <typename T, typename U>
    bool operator()(this less_than, T const& lhs, U const& rhs) {
        return lhs < rhs;
    }
};

less_than{}(4, 5);
```

Following the proposing rules for candidate lookup - the call operator here would be a candidate, with the object parameter binding to the object and the other two parameters binding to the arguments. Having a value parameter is nothing new in the language at all - it has a clear and obvious meaning. It's just that we've never been able to take an object parameter by value before. For why we might want to do this, see [by-value member functions](#by-value-member-functions).

In the case of explicit member type, what does this mean:

```c++
template <typename T, size_t N>
struct array {
    template <typename Self>
    auto& operator[](size_t) Self;
};
```

A common source of duplication of member functions revolves solely around wanting non-`const` and `const` overloads of a member function - that otherwise do exactly the same thing. The normal template deduction rules would drop *cv*-qualifiers, meaning that:

```c++
using A = array<int, 10>;
void ex(A& a, A const&, ca) {
    a[0];  // deduces Self=A
    ca[0]; // deduces Self=A, same function
}
```

But with normal member function declarations today, we don't have this same notion of a "value" - the implicit object parameter is always a reference. We're used to writing either nothing or `const` at the end of member functions. Which is analogous to writing `C` or `C const`. It would follow that allowing the deduction of a naked (i.e. non-reference) template parameter to preserve *cv*-qualifiers would do the expected thing and be useful. 

In other words, we propose that `ca[0]` deduces `Self` as `A const` in the previous example. 
    
This mimics today's behavior where a trailing `const` qualifier does not mean `const&`, it just means `const`. Without such a change to template deduction, `Self` would always just deduce as `A` (and hence be pointless), `Self&` would deduce as `A&` or `A const&` but not allow binding to rvalues, and `Self&&` would give us different functions for lvalues and rvalues - which is unnecessary and leads to code bloat.

### Name lookup: within member functions ### {#name-lookup-within-member-functions}

So far, we've only considered how member functions with explicit member types get found with name lookup and how they deduce that parameter. Now let's move on to how the bodies of these functions actually behave.

Since either the explicit object parameter or member type is deduced from the object the function is called on, this has the interesting effect of possibly deducing *derived* types. And we need to carefully consider how name lookup works in this context.

To avoid repetition, we'll use an explicit object parameter for this example:
    
```cpp
struct B {
    int i = 0;

    template <typename Self> auto&& f1(this Self&&) { return i;  }
    template <typename Self> auto&& f2(this Self&&) { return this->i; }    
    template <typename Self> auto&& f3(this Self&&) { return forward_like<Self>(*this).i; }    
    template <typename Self> auto&& f4(this Self&&) { return forward<Self>(*this).i; }        
    template <typename Self> auto&& f5(this Self&& self) { return forward<Self>(self).i; }
};

struct D : B {
    // shadows B::i
    double i = 3.14;
};
```

The question is: what do each of these five functions do? Should any of them be ill-formed? What is the safe thing to do?

We think there are three approaches here that we could take:

1. If there is an explicit object parameter, `this` is inaccessible and you need to qualify every access. There is no implicit lookup of members through `this`. This makes `f1` through `f4` ill-formed and only `f5` is well-formed. However, while `B().f5()` returns a reference to `B::i`, `D().f5()` returns a reference to `D::i`, since `self` is a reference to `D`.

2. If there is an explicit object parameter, `this` is accessible and points to the base subobject. There is no implicit lookup of members, all access must be through `this` or `self` explicitly. This makes `f1` ill-formed. But `f2` would be well-formed and always return a reference to `B::i`. Importantly, `this` would be *dependent* if the explicit object parameter was deduced - `this->i` is always going to be an `int` but it could be an `int` or an `int const` depending on whether the `B` object is const. `f3` would always be well-formed and would be the right way to return a forwarding reference to `B::i`. `f4` would be well-formed when invoked on a `B` but ill-formed if invoked on a `D` (because of the requested implicit downcast). And `f5` would be well-formed, as before.

3. Regardless, `this` is accessible and points to the base subobject and we allow implicit lookup as today. This is mostly the same as the previous choice, except that now `f1` is well-formed and exactly equivalent to `f2`.

The wording of EWG poll in Rapperswil was:

> If an explicitly named (e.g. `self`) object parameter, should `this` be implicitly or explicitly usable in member function body?

Which suggests slight variations of options 1 and 2 above where we differentiate based on whether the explicit object parameter is *named* or not. In other words, potentially:

```c++
struct B {
    int i = 0;
    
    // ok: object parameter not named, so 'this' is implicitly accessible
    template <typename Self> auto&& f1a(this Self&&) { return i; }
    
    // error: object parameter named, so 'this' is inaccessible
    template <typename Self> auto&& f1b(this Self&& self) { return i; }
};
```

That seems a little too subtle a differentiation.

Here is a comparison of the implementation of `optional::value()` that is very careful about not accessing anything from the derived object, based on these three name lookup semantics:

<table style="width:100%">
<tr>
<th>`this`<br />inaccessible</th>
<td>
```c++
template <typename Self>
auto&& value(this Self&& self) {
  if (!self.optional::has_value()) {
    throw bad_optional_access();
  }
  
  return forward<Self>(self).optional::m_value;
}
```
</td>
</tr>
<tr>
<th>`this` accessible<br />but explicit</th>
<td>
```c++
template <typename Self>
auto&& value(this Self&&) {
  if (!this->has_value()) {
    throw bad_optional_access();
  }
  
  return forward_like<Self>(*this).m_value;
}
```
</td>
</tr>
<tr>
<th>`this` accessible<br />and implicit</th>
<td>
```c++
template <typename Self>
auto&& value(this Self&&) {
  if (!has_value()) {
    throw bad_optional_access();
  }
  
  return forward_like<Self>(m_value);
}
```
</td>
</tr>
</table>

Note that with the last two choices here - we do not even provide a name to the explicit object parameter, which is a good way to sidestep any problems with incorrect access. 

What do these options mean if we consider an explicit member type syntax? If we provide an *identifier*, then the name lookup semantics would be exactly the same as they would be for having an explicit object parameter. It's just that the named parameter is in a different location in the declaration - otherwise it has the same meaning. 

But if we take the explicit member type syntax without an identifier, we can't have this differentiation between what `this` might refer to and what `self` might refer to. We can really only have one possible name: `this`. And `this` would now have to change types: `this` becomes a `const` pointer to `remove_reference_t<T>`:

```cpp
struct X {
    void a();            // this is a X* const
    void b() const;      // this is a X const* const
    void c() &&;         // this is a X* const (ref-qualifiers don't count)

    void d() X;          // this is a X* const (same as a)
    void e() X&&;        // this is a X* const (same as c)
    
    template <typename S>
    void f() S;          // this is a S* const (which be a pointer to const or not!)
    template <typename S>
    void g() S&;         // this is a S* const
    template <typename S>
    void h() S&&;        // this is a remove_reference_t<S>* const
};
```

For some of these member functions, `this` might not point to an `X` - it might point to a type derived from `X`. With this syntax, we end up with a slightly different choice of syntaxes:

```c++
struct B {
    int i = 0;

    template <typename Self> auto&& f1() Self&& { return i;  }
    template <typename Self> auto&& f2() Self&& { return this->i; }    
    template <typename Self> auto&& f3() Self&& { return forward_like<Self>(*this).i; }    
    template <typename Self> auto&& f4() Self&& { return forward<Self>(*this).i; }        
};
```

First, note that `f3` and `f4` are exactly equivalent with this syntax - since `this` is some kind of pointer to `Self`, there is no differentiation. Our only real options are:

1. `this` is not implicitly accessible and you need to qualify every access. That is, `f1` is ill-formed.

2. `this` is implicitly accessible - but since `this` is no longer necessarily a pointer to `B`, `f1` does not necessary return `B::i`.

What this means is that, without an identifier, there is no way to syntactically differentiate between *specifically* accessing something in `B` and accessing something through whatever is deduced as the object parameter. The same is true if, having an identifier, if we choose option #1 (`this` is always inaccessible). We would have to write one of the following:

```cpp
// for each of these examples, we are using 'self' as the named
// identifier for the object parameter. If we are using the syntax
// that does not allow for an identifier, replace it mentally with
// *this instead.

// explicitly cast self to the appropriately qualified B
// note that we have to cast self, not self.i
return static_cast<like_t<Self, B>&&>(self).i;

// use the explicit subobject syntax. Note that this is always
// an lvalue reference - not a forwarding reference
return self.B::i;

// use the explicit subobject syntax to get a forwarding reference
return forward<Self>(self).B::i;
```

This is quite complex, so we think there would be benefit to having the ability to syntactically differentiate between referring to the deduced, most derived object and the non-deduced, class-we're-in object.

### Writing the function pointer types for such functions ### {#writing-function-pointer-types}

The proposed change allows for deducing the object parameter's value category and *cv*-qualifiers. But the member functions themselves are otherwise the same as you could express today, and their types do not change.

In other words, given:

```cpp
struct Y {
    int f(int, int) const&;
    int g(int, int) Y const&;
    int h(this Y const&, int, int);
};
```
    
`Y::f`, `Y::g`, and `Y::h` are equivalent from a signature standpoint, so all of them have the type `int(Y::*)(int, int) const&`.

Where this becomes interesting is when deduction kicks in. These rules would be the same regardless of syntax, so we'll use the explicit object parameter syntax to avoid repetition:

```cpp
struct B {
    template <typename Self>
    void foo(this Self&&);
};

struct D : B { };
```

The type of `&B::foo<B>` is `void (B::*)() &&` and the type of `&B::foo<B const&>` is `void (B::*)() const&`. This is just a normal member function.

The type of `&D::foo<B>` is `void (B::*)() &&`. This is effectively the same thing that would happen if `foo` were a normal, C++17 member function.

The type of `&B::foo<D>` is `void (D::*)() &&`. That is, it is as if it were a member function of `D`. 

### Pathological cases ### {#pathological-cases}

It is important to mention the pathological cases. First, what happens if `D` is incomplete but becomes valid later:

```cpp
struct D;
struct B {
    void foo(this D&);
};
struct D : B { };
```

Following the precedent of [[P0929R2]], we think this should be fine, if strange. If `D` is incomplete, we just postpone checking until the point of call (or formation of pointer to member, etc.). At that point, the call will simply either not be viable or the formation of pointer-to-member would be ill-formed.

For non-related, complete classes or non-classes:

```cpp
struct A { };
struct B {
    void foo(this A&);
    void bar(this int);
};
```

The declaration can be immediately diagnosed as ill-formed. 

                
### Teachability Implications ### {#teachability-implications}

Explicitly naming the object as the `this`-designated first parameter fits with many programmers' mental model of the `this` pointer being the first parameter to member functions "under the hood" and is comparable to usage in other languages, e.g. Python and Rust. It also works as a more obvious way to teach how `std::bind`, `std::thread`, `std::function`, and so forth work with a member function pointer by making the pointer explicit.

A natural extension of having trailing *cv-* and *ref-qualifiers* to non-static member functions is providing an explicit type that those qualifiers refer to, instead of the implied class type. This keeps all of the qualifiers in the same place, which is more "C++-ic" in this sense. The ability to deduce this type follows once we have a place where we can name it.

We do not believe there are teachability problems with either choice of syntax. However, 

While having `this` become dependent is novel, requiring all access through `this` and forbidding "free" member access ensures that these functions will still be clear to write and understand. 

### Can `static` member functions have an explicit object type? ### {#static-member-functions}

No. Static member functions currently do not have an implicit object parameter, and therefore have no reason to provide an explicit one.

### Interplays with capturing `[this]` and `[*this]` in lambdas ### {#interplays-with-capturing-this}

Providing either an explicit object parameter or explicit member type for lambdas still works, but the rules for what `this` means in a lambda today still apply: `this` can only ever refer to a captured member pointer of an outer member function, and never be a pointer to the lambda instance itself:

```cpp
struct X {
    int x, y;

    auto getter() const
    {
        return [*this]<typename Self>() Self&& {
            return x       // still refers to X::x
                + this->y; // still refers to X::y
        };
    }
};
```

If other language features play with what `this` means, they are completely orthogonal and do not have interplays with this proposal. However, it should be obvious that developers have great potential for introducing hard-to-read code if they are at all changing the meaning of `this` in function bodies, especially in conjunction with this proposal.

### Parsing issues ### {#parsing-issues}

The explicit object parameter syntax has no parsing issues that we are aware of. It is purely a syntax extension. 

With the addition of a new type name after the *parameter-declaration-clause*, we potentially run into a clash with the existing *virt-specifier*s. Especially if we allow for an arbitrary identifier.

Consider:

```cpp
struct B {
    virtual B* override() = 0;
};

struct override : B {
    override* override() override override override; // #1
    override* override() override override;          // #2
    override* override() override;                   // #3
    override* override();                            // #4
};
```

The same problem would occur with `final`. 

In order to disambiguate between a trailing explicit member type, a trailing arbitrary identifier, and a *virt-specifier* (or any future trailing context-sensitive keyword), we would have to adopt set a preference - which would probably be to parse out the type first, the identifier second (if an identifier is allowed), and then anything else last.

If we go with the syntax that allows for an identifier: `#1` would have an explicit object of type `override` named `override` that is an `override`, `#2` would just declare an object with an identifier that does not make use of the override *virt-specifier*, and `#3` would provide an explicit object type without an identifier. Notably today, `#3` is valid code - and it would remain valid code, but the meaning of the `override` identifier would change. 

If we go with the syntax that does *not* allow for an identifier: `#1` would be ill-formed, `#2` would declare an explicit object having type `override` that has the *virt-specifier* `override`, and `#3` would likewise change meaning. 

In practice, we don't think anybody actually writes code like this seriously, so it is unlikely to break real code.
   
We feel that allowing for an arbitrary identifier would be grabbing too much real estate with minimal benefit - as it would constrain further evolution of the standard too much and make it more difficult to use. Let's say we then added a new context-sensitive keyword, like `super`. A user might try to write:

```cpp
struct Y {
    // intending to use the new context-sensitive keyword but
    // really is providing a name to the object parameter
    void a() super;
    
    // same
    void b() Y super;
    
    // okay, these finally use the keyword as desired - the user
    // has to provide an identifier, even if they don't want one
    void c() _ super;
    void d() Y _ super;
};
```

Without an arbitrary identifier, `a()` and `b()` both treat `super` as the context-sensitive keyword as likely intended, with the only edge case being in the scenario where you have a type named `super`. 
    
## Potential Extensions ## {#potential-extensions}

One of the pitfalls mentioned in having a deduced object parameter or a deduced member type is when all you want to do is deduce the *cv*-qualifiers and value category of the object parameter, but you end up deducing a derived type as well. Any access through an object that might have derived type could be error-prone if it's not intended! 

We could propose some kind of "make it easy to get the base class pointer"-style syntax, but even if we had such a thing, the feature would suffer from extra instantiations. For `optional::value()`, we really only want four instantiations: `&`, `const&`, `&&`, and `const&&`. If some inherits from `optional`, we don't want additional extra instantiations of those functions - which won't do anything new anyway. This is code bloat - and error prone. 

This problem extends further than just to `Self`, though. It is common to only want to deduce the ref-qualifier in all sorts of contexts. A complementary feature could be proposed that constrains *deduction* (as opposed to removing candidates once they are deduced, as with `requires`, with the following straw-man syntax:

```cpp
struct B {
    template <typename Self : B>
    auto front(this Self&& self);
};
struct D : B { };

// also works for free functions
template <typename T : B>
void foo(T&& x) {
   static_assert(std::is_same_v<B, std::remove_reference_t<T>>);
}

B{}.front(); // calls B::front<B>
D{}.front(); // also calls B::front<B>

foo(B{}); // calls foo<B>
foo(D{}); // also calls foo<B>
```

This would create a function template that may only generate functions that take a `B`, ensuring that, when they participate in overload resolution, we don't generate additional instantiations. Such a proposal would change how templates participate in overload resolution, however, and is not to be attempted haphazardly.

# Real-World Examples # {#real-world-examples}

## Deduplicating Code ## {#deduplicationg-code}

This proposal can de-duplicate and de-quadruplicate a large amount of code. In each case, the single function is only slightly more complex than the initial two or four, which makes for a huge win. What follows are a few examples of how repeated code can be reduced.

The particular implementation of optional is Simon's, and can be viewed on [GitHub](https://github.com/TartanLlama/optional), and this example includes some functions that are proposed in [[P0798R0]], with minor changes to better suit this format:

<table style="width:100%">
<tr>
<th style="width:50%">
C++17
</th>
<th style="width:50%">
This proposal
</th>
</tr>
<tr>
<td>
```cpp
class TextBlock {
public:
  const char& operator[](std::size_t position) const {
    // ...
    return text[position];
  }

  char& operator[](std::size_t position) {
    return const_cast<char&>(
      static_cast<const TextBlock&>
        (this)[position]
    );
  }
  // ...
};
```
</td>
<td>
```cpp
class TextBlock {
public:
  template <typename Self>
  auto& operator[](std::size_t position) Self {
    // ...
    return this->text[position];
  }
  // ...
};
```
</td>
</tr>
<tr>
<td>
```cpp
template <typename T>
class optional {
  // ...
  constexpr T* operator->() {
    return std::addressof(this->m_value);
  }

  constexpr const T*
  operator->() const {
    return std::addressof(this->m_value);
  }
  // ...
};
```
</td>
<td>
```cpp
template <typename T>
class optional {
  // ...
  template <typename Self>
  constexpr auto operator->() Self {
    return std::addressof(this->m_value);
  }
  // ...
};
```
</td>
</tr>
<tr>
<td>
```cpp
template <typename T>
class optional {
  // ...
  constexpr T& operator*() & {
    return this->m_value;
  }

  constexpr const T& operator*() const& {
    return this->m_value;
  }

  constexpr T&& operator*() && {
    return std::move(this->m_value);
  }

  constexpr const T&&
  operator*() const&& {
    return std::move(this->m_value);
  }

  constexpr T& value() & {
    if (has_value()) {
      return this->m_value;
    }
    throw bad_optional_access();
  }

  constexpr const T& value() const& {
    if (has_value()) {
      return this->m_value;
    }
    throw bad_optional_access();
  }

  constexpr T&& value() && {
    if (has_value()) {
      return std::move(this->m_value);
    }
    throw bad_optional_access();
  }

  constexpr const T&& value() const&& {
    if (has_value()) {
      return std::move(this->m_value);
    }
    throw bad_optional_access();
  }
  // ...
};
```
</td>
<td>
```cpp
template <typename T>
class optional {
  // ...
  template <typename Self>
  constexpr like_t<Self, T>&& operator*() Self&& {
    return forward_like<Self>(*this).m_value;
  }

  template <typename Self>
  constexpr like_t<Self, T>&& value() Self&& {
    if (this->has_value()) {
      return forward_like<Self>(*this).m_value;
    }
    throw bad_optional_access();
  }
  // ...
};
```
</td>
</tr>
<tr>
<td>
```cpp
template <typename T>
class optional {
  // ...
  template <typename F>
  constexpr auto and_then(F&& f) & {
    using result =
      invoke_result_t<F, T&>;
    static_assert(
      is_optional<result>::value,
      "F must return an optional");

    return has_value()
        ? invoke(forward<F>(f), **this)
        : nullopt;
  }

  template <typename F>
  constexpr auto and_then(F&& f) && {
    using result =
      invoke_result_t<F, T&&>;
    static_assert(
      is_optional<result>::value,
      "F must return an optional");

    return has_value()
        ? invoke(forward<F>(f),
                 std::move(**this))
        : nullopt;
  }

  template <typename F>
  constexpr auto and_then(F&& f) const& {
    using result =
      invoke_result_t<F, const T&>;
    static_assert(
      is_optional<result>::value,
      "F must return an optional");

    return has_value()
        ? invoke(forward<F>(f), **this)
        : nullopt;
  }

  template <typename F>
  constexpr auto and_then(F&& f) const&& {
    using result =
      invoke_result_t<F, const T&&>;
    static_assert(
      is_optional<result>::value,
      "F must return an optional");

    return has_value()
        ? invoke(forward<F>(f),
                 std::move(**this))
        : nullopt;
  }
  // ...
};
```
</td>
<td>
```cpp
template <typename T>
class optional {
  // ...
  template <typename Self, typename F>
  constexpr auto and_then(F&& f) Self&& {
    using val = decltype((
        forward<Self>(*this).m_value));
    using result = invoke_result_t<F, val>;

    static_assert(
      is_optional<result>::value,
      "F must return an optional");

    return has_value()
        ? invoke(forward<F>(f),
                 forward<Self>(self).m_value)
        : nullopt;
  }
  // ...
};
```
</td>
</table>

Keep in mind that there are a few more functions in P0798 that have this lead to this explosion of overloads, so the code difference and clarity is dramatic.

For those that dislike returning auto in these cases, it is very easy to write a metafunction that matches the appropriate qualifiers from a type. Certainly simpler than copying and pasting code and hoping that the minor changes were made correctly in every case.

## CRTP, without the C, R, or even T ## {#crtp}

Today, a common design pattern is the Curiously Recurring Template Pattern. This implies passing the derived type as a template parameter to a base class template, as a way of achieving static polymorphism. If we wanted to just outsource implementing postfix incrementing to a base, we could use CRTP for that. But with explicit object parameters that deduce to the derived objects already, we don't need any curious recurrence. We can just use standard inheritance and let deduction just do its thing. The base class doesn't even need to be a template:


<table style="width:100%">
<tr>
<th style="width:50%">
C++17
</th>
<th style="width:50%">
Proposed
</th>
</tr>
<tr>
<td>
```cpp
template <typename Derived>
struct add_postfix_increment {
    Derived operator++(int) {
        auto& self = static_cast<Derived&>(*this);

        Derived tmp(self);
        ++self;
        return tmp;
    }
};

struct some_type : add_postfix_increment<some_type> {
    some_type& operator++() { ... }
};
```
</td>
<td>
```cpp
struct add_postfix_increment {
    template <typename Self>
    Self operator++(int) Self {
        Self tmp(self);
        ++self;
        return tmp;
    }
};



struct some_type : add_postfix_increment {
    some_type& operator++() { ... }
};
```
</td>
</tr>
</table>

The example at right isn't much shorter, but it is certainly simpler.

### Builder pattern ### {#builder-pattern}

However, once we start to do any more with CRTP, it can get increasingly complex very fast... whereas with this proposal, it stays remarkably simple.

Let's say we have a builder that does a lot of things. We might start with:

```cpp
struct Builder {
  Builder& a() { /* ... */; return *this; }
  Builder& b() { /* ... */; return *this; }
  Builder& c() { /* ... */; return *this; }
};

Builder().a().b().a().b().c();    
```

But now, we want to create a specialized builder that has new operations `d()` and `e()`. This specialized builder needs new member functions, and we don't want to burden existing users with them. But we also want `Special().a().d()` to work - so we need to use CRTP to _conditionally_ return either a `Builder&` or a `Special&`:

<table style="width:100%">
<tr>
<th style="width:50%">
C++ today
</th>
<th>
Proposed
</th>
</tr>
<tr>
<td>
```cpp
template <typename D=void>
class Builder {
  using Derived = conditional_t<is_void_v<D>, Builder, D>;
  Derived& self() {
    return *static_cast<Derived*>(this);
  }
  
public:
  Derived& a() { /* ... */; return self(); }
  Derived& b() { /* ... */; return self(); }
  Derived& c() { /* ... */; return self(); }
};

struct Special : Builder<Special> {
  Special& d() { /* ... */; return *this; }
  Special& e() { /* ... */; return *this; }
};

Builder().a().b().a().b().c();
Special().a().d().e().a();
```
</td>
<td>
```cpp
struct Builder {
    template <typename Self>
    Self& a() Self&& { /* ... */; return self; }
    
    template <typename Self>
    Self& b() Self&& { /* ... */; return self; }        
    
    template <typename Self>
    Self& c() Self&& { /* ... */; return self; }        
};

struct Special : Builder {
    Special& d() { /* ... */; return *this; }
    Special& e() { /* ... */; return *this; }
};

Builder().a().b().a().b().c();
Special().a().d().e().a();
```
</td>
</tr>
</table>

The code on the right is dramatically easier to understand and more accessible to more programmers than the code on the left.

But what, there's more.

What if we add a _super_-specialized builder, that is a more special form of `Special`? Now we need `Special` to itself opt-in to CRTP so it knows which type to pass to `Builder` so that everything in the hierarchy can return the correct type. It's roughly at this point that people just give up and start gently weeping. But with this proposal, no problem!
    
<table style="width:100%">
<tr>
<th style="width:50%">
C++ today
</th>
<th>
Proposed
</th>
</tr>
<tr>
<td>
```cpp
template <typename D=void>
class Builder {
protected:
  using Derived = conditional_t<is_void_v<D>, Builder, D>;
  Derived& self() {
    return *static_cast<Derived*>(this);
  }
  
public:
  Derived& a() { /* ... */; return self(); }
  Derived& b() { /* ... */; return self(); }
  Derived& c() { /* ... */; return self(); }
};

template <typename D=void>
struct Special
  : Builder<conditional_t<is_void_v<D>,Special<D>,D>
{
  using Derived = typename Special::Builder::Derived;
  Derived& d() { /* ... */; return this->self(); }
  Derived& e() { /* ... */; return this->self(); }
};

struct Super : Special<Super>
{
    Super& f() { /* ... */; return *this; }
};

Builder().a().b().a().b().c();
Special().a().d().e().a();
Super().a().d().f().e();
```
</td>
<td>
```cpp
struct Builder {
    template <typename Self>
    Self& a() Self&& { /* ... */; return self; }
    
    template <typename Self>
    Self& b() Self&& { /* ... */; return self; }        
    
    template <typename Self>
    Self& c() Self&& { /* ... */; return self; }        
};

struct Special : Builder {
    template <typename Self>
    Self& d() Self&& { /* ... */; return self; }
    
    template <typename Self>
    Self& e() Self&& { /* ... */; return self; }
};

struct Super : Special {
    Super& f() Self&& { /* ... */; return *this; }
};

Builder().a().b().a().b().c();
Special().a().d().e().a();
Super().a().d().f().e();
```
</td>
</tr>
</table>  

That is just so much easier on the right. There are simply so many situations where this idiom, if available, would give programmers an easier, accessible solution to problems that they just cannot easily solve today.

### A new syntax for opt-in ### {#new-syntax-opt-in}

Today, with [[P0515R3]], the way that you opt-in to a defaulted comparison is via:

```cpp
struct A {
    int i;
    char c;
    double d;
    
    auto operator<=>(A const&) const = default;
};
```
    
This isn't that much to type, and it's a massive improvement over the C++17 implementation of equivalent functionality. But in larger classes, it's easy to lose these kinds of important declarations in the noise. We could use this new non-CRTP version of CRTP to provide a novel annotation for types, which would lead to even less typing for this kind of opt-in while also ensuring that the annotation that is provided is much more visible. 

<table style="width:100%">
<tr>
<th style="width:50%">
C++ today
</th>
<th>
Proposed
</th>
</tr>
<tr>
<td>
```cpp
struct A {
    int i;
    char c;
    double d;
    
    auto operator<=>(A const&) const = default;
};
```
</td>
<td>
```cpp
struct Ord {
    template <typename Self>
    auto operator<=>(Self const& rhs) Self const& = default;
};

struct A
    : Ord // <== first thing we write
{
    int i;
    char c;
    double d;
    
    // no other declarations
};
```
</td>
</tr>
</table>

## Recursive Lambdas ## {#recursive-lambdas}

This proposal allows you to store values in a lambda and then either move or copy them out, depending on the lambda is invoked. We could already do this today for class types:

```cpp
template <typename T>
struct Holder {
    T value;
    
    T&        operator()() &       { return value; }
    T const&  operator()() const&  { return value; }
    T&&       operator()() &&      { return move(value); }
    T const&& operator()() const&& { return move(value); }
};
```
    
But now you can do this with a lambda too:

```cpp
auto holder = [value=...]<typename Self>() Self&& {
    return static_cast<decltype((value))>(value);
};
```

## SFINAE-friendly callables ## {#sfinae-friendly-callables}

A seemingly unrelated problem to the question of code quadruplication is that of writing these numerous overloads for function wrappers, as demonstrated in [[P0826R0]]. Consider what happens if we implement `std::not_fn()`, as currently specified:

```cpp
template <typename F>
class call_wrapper {
    F f;
public:
    // ...
    template <typename... Args>
    auto operator()(Args&&... ) &
        -> decltype(!declval<invoke_result_t<F&, Args...>>());

    template <typename... Args>
    auto operator()(Args&&... ) const&
        -> decltype(!declval<invoke_result_t<const F&, Args...>>());

    // ... same for && and const && ...
};

template <typename F>
auto not_fn(F&& f) {
    return call_wrapper<std::decay_t<F>>{std::forward<F>(f)};
}
```

As described in the paper, this implementation has two pathological cases: one in which the callable is SFINAE-unfriendly (which would cause a call to be ill-formed, when it could otherwise work), and one in which overload is deleted (which would cause a call to fall-back to a different overload, when it should fail):

```cpp
struct unfriendly {
    template <typename T>
    auto operator()(T v) {
        static_assert(std::is_same_v<T, int>);
        return v;
    }

    template <typename T>
    auto operator()(T v) const {
        static_assert(std::is_same_v<T, double>);
        return v;
    }
};

struct fun {
    template <typename... Args>
    void operator()(Args&&...) = delete;

    template <typename... Args>
    bool operator()(Args&&...) const { return true; }
};

std::not_fn(unfriendly{})(1); // static assert!
                              // even though the non-const overload is viable and would be the best
                              // match, during overload resolution, both overloads of unfriendly have
                              // to be instantiated - and the second one is a hard compile error.

std::not_fn(fun{})();         // ok!? Returns false
                              // even though we want the non-const overload to be deleted, the const
                              // overload of the call_wrapper ends up being viable - and the only viable
                              // candidate.
```

Gracefully handling SFINAE-unfriendly callables is **not solvable** in C++ today. Preventing fallback can be solved by the addition of yet another four overloads, so that each of the four *cv*/ref-qualifiers leads to a pair of overloads: one enabled and one `deleted`.

This proposal solves both problems by simply allowing `this` to be deduced. The following is a complete implementation of `std::not_fn`:

```cpp
template <typename F>
struct call_wrapper {
    F f;

    template <typename Self, typename... Args>
    auto operator()(Args&&... args) Self&&
        -> decltype(!invoke(forward_like<Self>(this->f), forward<Args>(args)...))
    {
        return !invoke(forward_like<Self>(this->f), forward<Args>(args)...);
    }
};

template <typename F>
auto not_fn(F&& f) {
    return call_wrapper<decay_t<F>>{forward<F>(f)};
}

not_fn(unfriendly{})(1); // ok
not_fn(fun{})();         // error
```

Here, there is only one overload with everything deduced together. The first example now works correctly. `Self` gets deduced as `call_wrapper<unfriendly>`, and the one `operator()` will only consider `unfriendly`'s non-`const` call operator. The `const` one is simply never considered, so does not have an opportunity to cause problems. The call works. 

The second example now fails correctly. Previously, we had four candidates: the two non-`const` ones were removed from the overload set due to `fun`'s non-`const` call operator being `delete`d, and the two `const` ones which were viable. But now, we only have one candidate. `Self` gets deduced as `call_wrapper<fun>`, which requires `fun`'s non-`const` call operator to be well-formed. Since it is not, the call is an error. There is no opportunity for fallback since there is only one overload ever considered. 

As a result, this singular overload then has precisely the desired behavior: working, for `unfriendly`, and not working, for `fun`.

Note that this could also be implemented as a lambda completely within the body of `not_fn`:

```cpp
template <typename F>
auto not_fn(F&& f) {
    return [f=forward<F>(f)]<typename Self, typename... Args>(auto&&.. args) Self&&
        -> decltype(!invoke(forward_like<Self>(f), forward<Args>(args)...))
    {
        return !invoke(forward_like<Self>(f), forward<Args>(args)...);
    };
}
```

## By-value member functions ## {#by-value-member-functions}

TBD.

# Acknowledgements # {#acknowledgements}

The authors would like to thank:

- Jonathan Wakely, for bringing us all together by pointing out we were writing the same paper, twice
- Chandler Carruth for a lot of feedback and guidance around design issues
- Graham Heynes, Andrew Bennieston, Jeff Snyder for early feedback regarding the meaning of `this` inside function bodies
- Amy Worthington, Jackie Chen, Vittorio Romeo, Tristan Brindle, Agustín Bergé, Louis Dionne, and Michael Park for early feedback
- Guilherme Hartmann for his guidance with the implementation